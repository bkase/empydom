"use strict";
(function(FUNCTION_TABLE_OFFSET) {
  var Module = {};
  var args = [];
  Module.arguments = [];
  var __globalConstructor__ = function globalConstructor() {};
  var $0___SIZE = 96;
  var $1___SIZE = 16;
  var $2___SIZE = 196;
  var $3___SIZE = 256;
  var $4___SIZE = 16;
  var $5___SIZE = 40;
  var $6___SIZE = 20;
  var $7___SIZE = 20;
  var $8___SIZE = 80;
  var $9___SIZE = 20;
  var $10___SIZE = 208;
  var $11___SIZE = 176;
  var $12___SIZE = 40;
  var $13___SIZE = 288;
  var $14___SIZE = 320;
  var $15___SIZE = 224;
  var $16___SIZE = 196;
  var $17___SIZE = 320;
  var $18___SIZE = 48;
  var $19___SIZE = 32;
  var $20___SIZE = 224;
  var $21___SIZE = 80;
  var $22___SIZE = 80;
  var $23___SIZE = 16;
  var $24___SIZE = 240;
  var $25___SIZE = 80;
  var $26___SIZE = 120;
  var $struct_FILE___SIZE = 148;
  var $struct_FILE___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 70, 71, 72, 76, 84, 88, 92, 96, 100, 104, 108 ];
  var $struct_PyBlockingIOErrorObject___SIZE = 36;
  var $struct_PyBufferProcs___SIZE = 24;
  var $struct_PyByteArrayObject___SIZE = 24;
  var $struct_PyEnvironmentErrorObject___SIZE = 32;
  var $struct_PyGetSetDef___SIZE = 20;
  var $struct_PyIntObject___SIZE = 12;
  var $struct_PyLongObject___SIZE = 0;
  var $struct_PyLongObject___FLATTENER = [];
  var $struct_PyMappingMethods___SIZE = 12;
  var $struct_PyMemberDef___SIZE = 20;
  var $struct_PyMethodDef___SIZE = 16;
  var $struct_PyNumberMethods___SIZE = 156;
  var $struct_PyObject___SIZE = 8;
  var $struct_PySequenceMethods___SIZE = 40;
  var $struct_PyStringObject___SIZE = 24;
  var $struct_PyTupleObject___SIZE = 16;
  var $struct_PyUnicodeObject___SIZE = 24;
  var $struct_PyVarObject___SIZE = 12;
  var $struct_Py_buffer___SIZE = 52;
  var $struct_Py_buffer___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48 ];
  var $struct__IO_marker___SIZE = 12;
  var $struct__typeobject___SIZE = 196;
  var $struct_anon___SIZE = 12;
  var $struct_buffered___SIZE = 100;
  var $struct_buffered___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 40, 44, 52, 60, 68, 76, 84, 88, 92, 96 ];
  var $struct_bytesio___SIZE = 32;
  var $struct_cookie_type___SIZE = 24;
  var $struct_cookie_type___FLATTENER = [ 0, 8, 12, 16, 20 ];
  var $struct_encodefuncentry___SIZE = 8;
  var $struct_fileio___SIZE = 24;
  var $struct_iobase___SIZE = 16;
  var $struct_nldecoder_object___SIZE = 20;
  var $struct_rwpair___SIZE = 24;
  var $struct_stat___SIZE = 96;
  var $struct_stat___FLATTENER = [ 0, 8, 12, 16, 20, 24, 28, 32, 40, 44, 52, 56, 64, 72, 80, 88 ];
  var $struct_stringio___SIZE = 48;
  var $struct_stringio___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 25, 26, 27, 28, 32, 36, 40, 44 ];
  var $struct_textio___SIZE = 96;
  var $struct_textio___FLATTENER = [ 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 49, 50, 51, 52, 53, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92 ];
  var $struct_timespec___SIZE = 8;
  var $union_PyGC_Head___SIZE = 12;
  var _bufferediobase_doc;
  var __str;
  var __str1;
  var __str2;
  var __str3;
  var _bufferediobase_detach_doc;
  var __str4;
  var _bufferediobase_read_doc;
  var _bufferediobase_read1_doc;
  var __str5;
  var _bufferediobase_write_doc;
  var __str6;
  var __str7;
  var _bufferediobase_methods;
  var __str8;
  var _PyBufferedIOBase_Type;
  var __str9;
  var __str10;
  var ___PRETTY_FUNCTION___8511;
  var __str11;
  var __str12;
  var __str13;
  var __str14;
  var __str15;
  var __str16;
  var _eintr_int_9041;
  var __str17;
  var ___PRETTY_FUNCTION___9046;
  var __str18;
  var __str19;
  var __str20;
  var __str21;
  var __str22;
  var __str23;
  var __str24;
  var __str25;
  var __str26;
  var __str27;
  var __str28;
  var __str29;
  var __str30;
  var __str31;
  var __str32;
  var __str33;
  var __str34;
  var _bufferedreader_doc;
  var _C_170_9977;
  var __str35;
  var __str36;
  var __str37;
  var __str38;
  var __str39;
  var ___PRETTY_FUNCTION___10317;
  var __str40;
  var __str41;
  var __str42;
  var __str43;
  var __str44;
  var __str45;
  var __str46;
  var __str47;
  var __str48;
  var __str49;
  var __str50;
  var __str51;
  var _bufferedreader_methods;
  var _bufferedreader_members;
  var __str52;
  var _bufferedreader_getset;
  var __str53;
  var _PyBufferedReader_Type;
  var __str54;
  var _bufferedwriter_doc;
  var _C_210_10512;
  var __str55;
  var __str56;
  var __str57;
  var __str58;
  var __str59;
  var __str60;
  var ___PRETTY_FUNCTION___10710;
  var _bufferedwriter_methods;
  var _bufferedwriter_members;
  var _bufferedwriter_getset;
  var __str61;
  var _PyBufferedWriter_Type;
  var _bufferedrwpair_doc;
  var __str62;
  var __str63;
  var ___PRETTY_FUNCTION___11077;
  var _bufferedrwpair_methods;
  var _bufferedrwpair_getset;
  var __str64;
  var _PyBufferedRWPair_Type;
  var _bufferedrandom_doc;
  var _C_248_11275;
  var _bufferedrandom_methods;
  var _bufferedrandom_members;
  var _bufferedrandom_getset;
  var __str65;
  var _PyBufferedRandom_Type;
  var __str66;
  var __str167;
  var ___PRETTY_FUNCTION___8386;
  var __str268;
  var __str369;
  var ___PRETTY_FUNCTION___8425;
  var __str470;
  var ___PRETTY_FUNCTION___8462;
  var __str571;
  var _flush_doc;
  var __str672;
  var _getval_doc;
  var _isatty_doc;
  var _tell_doc;
  var _read_doc;
  var __str773;
  var __str874;
  var ___PRETTY_FUNCTION___8590;
  var _read1_doc;
  var _readline_doc;
  var __str975;
  var _readlines_doc;
  var __str1076;
  var _readinto_doc;
  var __str1177;
  var __str1278;
  var ___PRETTY_FUNCTION___8792;
  var _truncate_doc;
  var __str1379;
  var __str1480;
  var _seek_doc;
  var __str1581;
  var __str1682;
  var __str1783;
  var __str1884;
  var _write_doc;
  var _writelines_doc;
  var _close_doc;
  var __str1985;
  var __str2086;
  var ___PRETTY_FUNCTION___9082;
  var __str2187;
  var __str2288;
  var __str2389;
  var __str2490;
  var __str2591;
  var ___PRETTY_FUNCTION___9166;
  var __str2692;
  var ___PRETTY_FUNCTION___9203;
  var _C_82_9238;
  var __str2793;
  var __str2894;
  var __str2995;
  var __str3096;
  var _bytesio_getsetlist;
  var __str3197;
  var __str3298;
  var __str3399;
  var __str34100;
  var __str35101;
  var __str36102;
  var __str37103;
  var __str38104;
  var __str39105;
  var __str40106;
  var __str41107;
  var __str42108;
  var __str43109;
  var __str44110;
  var __str45111;
  var __str46112;
  var __str47113;
  var __str48114;
  var __str49115;
  var _bytesio_methods;
  var _bytesio_doc;
  var __str50116;
  var _PyBytesIO_Type;
  var __str117;
  var __str1118;
  var __str2119;
  var __str3120;
  var ___PRETTY_FUNCTION___8510;
  var __str4121;
  var __str5122;
  var __str6123;
  var __str7124;
  var ___PRETTY_FUNCTION___8604;
  var __str8125;
  var _kwlist_8591;
  var __str9126;
  var __str10127;
  var __str11128;
  var __str12129;
  var __str13130;
  var __str14131;
  var __str15132;
  var __str16133;
  var __str17134;
  var __str18135;
  var __str19136;
  var ___PRETTY_FUNCTION___8813;
  var __str20137;
  var __str21138;
  var __str22139;
  var __str23140;
  var __str24141;
  var __str25142;
  var __str26143;
  var __str27144;
  var __str28145;
  var __str29146;
  var __str30147;
  var __str31148;
  var __str32149;
  var __str33150;
  var __str34151;
  var __str35152;
  var __str36153;
  var _fileio_doc;
  var _read_doc154;
  var _readall_doc;
  var _write_doc155;
  var _fileno_doc;
  var _seek_doc156;
  var _truncate_doc157;
  var _tell_doc158;
  var _readinto_doc159;
  var _close_doc160;
  var _isatty_doc161;
  var _seekable_doc;
  var _readable_doc;
  var _writable_doc;
  var __str37162;
  var __str38163;
  var __str39164;
  var __str40165;
  var __str41166;
  var __str42167;
  var __str43168;
  var __str44169;
  var __str45170;
  var __str46171;
  var __str47172;
  var __str48173;
  var _fileio_methods;
  var __str49174;
  var __str50175;
  var __str51176;
  var __str52177;
  var _fileio_getsetlist;
  var __str53178;
  var _PyFileIO_Type;
  var _iobase_doc;
  var _iobase_seek_doc;
  var __str181;
  var _iobase_tell_doc;
  var __str1182;
  var _iobase_truncate_doc;
  var __str2183;
  var _iobase_flush_doc;
  var __str3184;
  var __str4185;
  var _iobase_close_doc;
  var __str5186;
  var __str6187;
  var ___PRETTY_FUNCTION___8582;
  var _iobase_seekable_doc;
  var __str7188;
  var _iobase_readable_doc;
  var __str8189;
  var _iobase_writable_doc;
  var __str9190;
  var _iobase_fileno_doc;
  var __str10191;
  var _iobase_isatty_doc;
  var _iobase_readline_doc;
  var __str11192;
  var __str12193;
  var __str13194;
  var __str14195;
  var __str15196;
  var __str16197;
  var __str17198;
  var __str18199;
  var ___PRETTY_FUNCTION___8823;
  var _iobase_readlines_doc;
  var __str19200;
  var __str20201;
  var __str21202;
  var __str22203;
  var __str23204;
  var __str24205;
  var __str25206;
  var __str26207;
  var __str27208;
  var __str28209;
  var __str29210;
  var __str30211;
  var __str31212;
  var __str32213;
  var __str33214;
  var __str34215;
  var __str35216;
  var __str36217;
  var __str37218;
  var __str38219;
  var _iobase_methods;
  var __str39220;
  var _iobase_getset;
  var __str40221;
  var _PyIOBase_Type;
  var _rawiobase_doc;
  var __str41223;
  var __str42224;
  var _rawiobase_readall_doc;
  var __str43225;
  var _rawiobase_methods;
  var __str44226;
  var _PyRawIOBase_Type;
  var _module_doc;
  var __str232;
  var __str1233;
  var ___PRETTY_FUNCTION___8402;
  var __str2234;
  var __str3235;
  var _blockingioerror_members;
  var __str4236;
  var __str5237;
  var __PyExc_BlockingIOError;
  var _PyExc_BlockingIOError;
  var _open_doc;
  var _C_6_8496;
  var __str6239;
  var __str7240;
  var __str8241;
  var __str9242;
  var __str10243;
  var __str11244;
  var __str12245;
  var __str13246;
  var __str14247;
  var __str15248;
  var __str16249;
  var __str17250;
  var __str18251;
  var __str19252;
  var __str20253;
  var __str21254;
  var __str22255;
  var __str23256;
  var __str24257;
  var __str25258;
  var __str26259;
  var __str27260;
  var __str28261;
  var __str29262;
  var __str30263;
  var __str31264;
  var ___PRETTY_FUNCTION___8759;
  var __str32265;
  var __str33266;
  var __PyIO_os_module;
  var __PyIO_locale_module;
  var __PyIO_unsupported_operation;
  var __str34268;
  var _module_methods;
  var __str35269;
  var __str36270;
  var __str37271;
  var __str38272;
  var __str39273;
  var __str40274;
  var __str41275;
  var __str42276;
  var __str43277;
  var __str44278;
  var __str45279;
  var __str46280;
  var __str47281;
  var __str48282;
  var __str49283;
  var __str50284;
  var __str51285;
  var __str52286;
  var __str53287;
  var __PyIO_str_close;
  var __str54289;
  var __PyIO_str_closed;
  var __str55291;
  var __PyIO_str_decode;
  var __str56292;
  var __PyIO_str_encode;
  var __PyIO_str_fileno;
  var __str57294;
  var __PyIO_str_flush;
  var __str58296;
  var __PyIO_str_getstate;
  var __PyIO_str_isatty;
  var __str59298;
  var __PyIO_str_newlines;
  var __str60299;
  var __PyIO_str_nl;
  var __str61300;
  var __PyIO_str_read;
  var __str62302;
  var __PyIO_str_read1;
  var __str63303;
  var __PyIO_str_readable;
  var __str64305;
  var __PyIO_str_readinto;
  var __str65307;
  var __PyIO_str_readline;
  var __str66309;
  var __PyIO_str_reset;
  var __str67;
  var __PyIO_str_seek;
  var __str68;
  var __PyIO_str_seekable;
  var __str69;
  var __PyIO_str_setstate;
  var __str70;
  var __PyIO_str_tell;
  var __str71;
  var __PyIO_str_truncate;
  var __str72;
  var __PyIO_str_write;
  var __str73;
  var __PyIO_str_writable;
  var __PyIO_empty_str;
  var __PyIO_empty_bytes;
  var __PyIO_zero;
  var _stringio_doc;
  var __str319;
  var __str1320;
  var ___PRETTY_FUNCTION___8390;
  var __str2321;
  var ___PRETTY_FUNCTION___8432;
  var __str3322;
  var __str4323;
  var __str5324;
  var __str6325;
  var _stringio_getvalue_doc;
  var __str7326;
  var __str8327;
  var _stringio_tell_doc;
  var _stringio_read_doc;
  var __str9328;
  var __str10329;
  var __str11330;
  var _stringio_readline_doc;
  var __str12331;
  var __str13332;
  var _stringio_truncate_doc;
  var __str14333;
  var __str15334;
  var _stringio_seek_doc;
  var __str16335;
  var __str17336;
  var __str18337;
  var __str19338;
  var _stringio_write_doc;
  var __str20339;
  var _stringio_close_doc;
  var __str21340;
  var ___PRETTY_FUNCTION___8969;
  var __str22341;
  var ___PRETTY_FUNCTION___9039;
  var _C_71_9078;
  var __str23342;
  var __str24343;
  var __str25344;
  var __str26345;
  var __str27346;
  var __str28347;
  var __str29348;
  var __str30349;
  var __str31350;
  var ___PRETTY_FUNCTION___9300;
  var __str32351;
  var __str33352;
  var __str34353;
  var __str35354;
  var __str36355;
  var __str37356;
  var __str38357;
  var __str39358;
  var __str40359;
  var __str41360;
  var __str42361;
  var __str43362;
  var __str44363;
  var __str45364;
  var __str46365;
  var __str47366;
  var __str48367;
  var _stringio_methods;
  var __str49368;
  var __str50369;
  var __str51370;
  var _stringio_getset;
  var __str52371;
  var _PyStringIO_Type;
  var _textiobase_doc;
  var _textiobase_detach_doc;
  var __str374;
  var _textiobase_read_doc;
  var __str1375;
  var _textiobase_readline_doc;
  var __str2376;
  var _textiobase_write_doc;
  var __str3377;
  var _textiobase_encoding_doc;
  var _textiobase_newlines_doc;
  var _textiobase_errors_doc;
  var _textiobase_methods;
  var __str4378;
  var __str5379;
  var __str6380;
  var _textiobase_getset;
  var __str7381;
  var _PyTextIOBase_Type;
  var _incrementalnewlinedecoder_doc;
  var _C_1_8453;
  var __str8383;
  var __str9384;
  var __str10385;
  var __str11386;
  var __str12387;
  var __str13388;
  var __str14389;
  var __str15390;
  var ___PRETTY_FUNCTION___8544;
  var _C_56_8766;
  var __str16391;
  var __str17392;
  var __str18393;
  var __str19394;
  var __str20395;
  var __str21396;
  var __str22397;
  var __str23398;
  var __str24399;
  var __str25400;
  var __str26401;
  var __str27402;
  var __str28403;
  var __str29404;
  var __str30405;
  var __str31406;
  var _incrementalnewlinedecoder_methods;
  var _incrementalnewlinedecoder_getset;
  var __str32407;
  var _PyIncrementalNewlineDecoder_Type;
  var _textiowrapper_doc;
  var _encodefuncs;
  var __str33409;
  var __str34410;
  var __str35411;
  var __str36412;
  var __str37413;
  var __str38414;
  var __str39415;
  var __str40416;
  var __str41417;
  var _C_89_9102;
  var __str42418;
  var __str43419;
  var __str44420;
  var __str45421;
  var __str46422;
  var __str47423;
  var __str48424;
  var __str49425;
  var __str50426;
  var __str51427;
  var __str52428;
  var __str53429;
  var __str54430;
  var __str55431;
  var __str56432;
  var ___PRETTY_FUNCTION___9643;
  var __str57433;
  var __str58434;
  var __str59435;
  var __str60436;
  var __str61437;
  var __str62438;
  var __str63439;
  var ___PRETTY_FUNCTION___10137;
  var __str64440;
  var __str65441;
  var __str66442;
  var ___PRETTY_FUNCTION___10181;
  var __str67443;
  var __str68444;
  var __str69445;
  var __str70446;
  var ___PRETTY_FUNCTION___10683;
  var __str71447;
  var __str72448;
  var __str73449;
  var __str74;
  var __str75;
  var __str76;
  var __str77;
  var __str78;
  var __str79;
  var __str80;
  var __str81;
  var __str82;
  var __str83;
  var __str84;
  var ___PRETTY_FUNCTION___11136;
  var __str85;
  var __str86;
  var __str87;
  var __str88;
  var __str89;
  var ___PRETTY_FUNCTION___11423;
  var __str90;
  var __str91;
  var __str92;
  var __str93;
  var __str94;
  var __str95;
  var __str96;
  var __str97;
  var __str98;
  var __str99;
  var __str100;
  var __str101;
  var __str102;
  var __str103;
  var __str104;
  var __str105;
  var _textiowrapper_methods;
  var _textiowrapper_members;
  var __str106;
  var __str107;
  var _textiowrapper_getset;
  var __str108;
  var _PyTextIOWrapper_Type;
  function _bufferediobase_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 76;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 76);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buf = __stackBase__ + 16;
      var $len = __stackBase__ + 68;
      var $data = __stackBase__ + 72;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 2:
      
      var $5 = HEAP[$buf + 8];
      var $6 = HEAP[$self_addr];
      var $7 = __PyObject_CallMethod_SizeT($6, __str1, __str2, allocate([ $5, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$data] = $7;
      
      
      if (HEAP[$data] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$data] + 4] + 84] & 134217728) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 4:
      
      
      
      var $20 = HEAP[HEAP[$data]] - 1;
      
      var $22 = HEAP[$data];
      HEAP[$22] = $20;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $31 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $32 = HEAP[$data];
      FUNCTION_TABLE[$31]($32);
      __label__ = 6;
      break;
     case 6:
      var $33 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($33, __str3);
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $37 = HEAP[HEAP[$data] + 8];
      HEAP[$len] = $37;
      var $38 = HEAP[$len];
      
      
      
      var $42 = HEAP[$data] + 20;
      
      var $44 = HEAP[$buf];
      _llvm_memcpy_p0i8_p0i8_i32($44, $42, $38, 1, 0);
      _PyBuffer_Release($buf);
      
      
      
      var $48 = HEAP[HEAP[$data]] - 1;
      
      var $50 = HEAP[$data];
      HEAP[$50] = $48;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $59 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $60 = HEAP[$data];
      FUNCTION_TABLE[$59]($60);
      __label__ = 9;
      break;
     case 9:
      var $61 = HEAP[$len];
      var $62 = _PyLong_FromSsize_t($61);
      HEAP[$0] = $62;
      __label__ = 11;
      break;
     case 10:
      _PyBuffer_Release($buf);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 11:
      var $63 = HEAP[$0];
      HEAP[$retval] = $63;
      __label__ = 12;
      break;
     case 12:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_unsupported($message) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $message;
      var $1 = HEAP[__PyIO_unsupported_operation];
      var $2 = HEAP[__stackBase__];
      _PyErr_SetString($1, $2);
      HEAP[$0] = 0;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_detach($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      var $1 = _bufferediobase_unsupported(__str4);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _bufferediobase_unsupported(__str1);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_read1($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _bufferediobase_unsupported(__str5);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferediobase_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _bufferediobase_unsupported(__str6);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      var $_py_tmp12 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $5 = HEAP[$self_addr];
      var $6 = __PyIOBase_finalize($5);
      
      if ($6 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      var $10 = HEAP[$self_addr] + -12;
      HEAP[$g] = $10;
      
      
      
      
      var $15 = HEAP[HEAP[$g] + 8] == -2;
      if ($15) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str9, __str10, 370, ___PRETTY_FUNCTION___8511);
      throw "Reached an unreachable!";
     case 4:
      
      
      var $18 = HEAP[$g] + 8;
      HEAP[$18] = -2;
      
      
      
      
      
      
      
      var $26 = HEAP[HEAP[$g]];
      
      var $28 = HEAP[HEAP[$g] + 4];
      HEAP[$28] = $26;
      
      
      
      
      
      
      
      var $36 = HEAP[HEAP[$g] + 4];
      
      var $38 = HEAP[HEAP[$g]] + 4;
      HEAP[$38] = $36;
      
      
      var $41 = HEAP[$g];
      HEAP[$41] = 0;
      
      var $43 = HEAP[$self_addr] + 12;
      HEAP[$43] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 96] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $49 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($49);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $56 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $56;
      
      var $58 = HEAP[$self_addr] + 8;
      HEAP[$58] = 0;
      
      
      
      var $62 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $64 = HEAP[$_py_tmp];
      HEAP[$64] = $62;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $73 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $74 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$73]($74);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      var $81 = HEAP[HEAP[$self_addr] + 40];
      _PyMem_Free($81);
      
      var $83 = HEAP[$self_addr] + 40;
      HEAP[$83] = 0;
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 12:
      
      
      var $90 = HEAP[HEAP[$self_addr] + 92];
      HEAP[$_py_tmp12] = $90;
      
      var $92 = HEAP[$self_addr] + 92;
      HEAP[$92] = 0;
      
      
      
      var $96 = HEAP[HEAP[$_py_tmp12]] - 1;
      
      var $98 = HEAP[$_py_tmp12];
      HEAP[$98] = $96;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp12]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $107 = HEAP[HEAP[HEAP[$_py_tmp12] + 4] + 24];
      var $108 = HEAP[$_py_tmp12];
      FUNCTION_TABLE[$107]($108);
      __label__ = 14;
      break;
     case 14:
      
      
      
      
      
      var $114 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $116 = HEAP[$self_addr];
      FUNCTION_TABLE[$114]($116);
      __label__ = 15;
      break;
     case 15:
      __label__ = 16;
      break;
     case 16:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      var $vret4 = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 7;
      break;
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $20 = HEAP[HEAP[$self_addr] + 92];
      var $21 = HEAP[$visit_addr];
      var $22 = HEAP[$arg_addr];
      var $23 = FUNCTION_TABLE[$21]($20, $22);
      HEAP[$vret4] = $23;
      
      
      if (HEAP[$vret4] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $26 = HEAP[$vret4];
      HEAP[$0] = $26;
      __label__ = 7;
      break;
     case 6:
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 7:
      var $27 = HEAP[$0];
      HEAP[$retval] = $27;
      __label__ = 8;
      break;
     case 8:
      var $retval8 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      var $_py_tmp7 = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      var $6 = HEAP[$self_addr];
      var $7 = __PyIOBase_finalize($6);
      
      if ($7 < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      HEAP[$0] = -1;
      __label__ = 10;
      break;
     case 3:
      
      var $10 = HEAP[$self_addr] + 12;
      HEAP[$10] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $17 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $17;
      
      var $19 = HEAP[$self_addr] + 8;
      HEAP[$19] = 0;
      
      
      
      var $23 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $25 = HEAP[$_py_tmp];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $35 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$34]($35);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $42 = HEAP[HEAP[$self_addr] + 92];
      HEAP[$_py_tmp7] = $42;
      
      var $44 = HEAP[$self_addr] + 92;
      HEAP[$44] = 0;
      
      
      
      var $48 = HEAP[HEAP[$_py_tmp7]] - 1;
      
      var $50 = HEAP[$_py_tmp7];
      HEAP[$50] = $48;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp7]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $59 = HEAP[HEAP[HEAP[$_py_tmp7] + 4] + 24];
      var $60 = HEAP[$_py_tmp7];
      FUNCTION_TABLE[$59]($60);
      __label__ = 9;
      break;
     case 9:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 10:
      var $61 = HEAP[$0];
      HEAP[$retval] = $61;
      __label__ = 11;
      break;
     case 11:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_simple_flush($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_flush];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_closed($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $closed = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = -1;
      __label__ = 10;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_closed];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_GetAttr($14, $11);
      HEAP[$res] = $15;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = -1;
      __label__ = 10;
      break;
     case 7:
      var $18 = HEAP[$res];
      var $19 = _PyObject_IsTrue($18);
      HEAP[$closed] = $19;
      
      
      
      var $23 = HEAP[HEAP[$res]] - 1;
      
      var $25 = HEAP[$res];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $35 = HEAP[$res];
      FUNCTION_TABLE[$34]($35);
      __label__ = 9;
      break;
     case 9:
      var $36 = HEAP[$closed];
      HEAP[$0] = $36;
      __label__ = 10;
      break;
     case 10:
      var $37 = HEAP[$0];
      HEAP[$retval] = $37;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_closed_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_closed];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_GetAttr($14, $11);
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_close($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $r = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 5:
      var $11 = HEAP[$self_addr];
      var $12 = _buffered_closed($11);
      HEAP[$r] = $12;
      
      
      if (HEAP[$r] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$res] = __Py_NoneStruct;
      
      
      
      var $20 = HEAP[HEAP[$res]] + 1;
      
      var $22 = HEAP[$res];
      HEAP[$22] = $20;
      __label__ = 13;
      break;
     case 8:
      var $23 = HEAP[__PyIO_str_flush];
      
      var $25 = HEAP[$self_addr];
      var $26 = _PyObject_CallMethodObjArgs($25, $23, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $26;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      
      var $34 = HEAP[HEAP[$res]] - 1;
      
      var $36 = HEAP[$res];
      HEAP[$36] = $34;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $46 = HEAP[$res];
      FUNCTION_TABLE[$45]($46);
      __label__ = 12;
      break;
     case 12:
      var $47 = HEAP[__PyIO_str_close];
      
      
      var $50 = HEAP[HEAP[$self_addr] + 8];
      var $51 = _PyObject_CallMethodObjArgs($50, $47, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $51;
      __label__ = 13;
      break;
     case 13:
      var $52 = HEAP[$res];
      HEAP[$0] = $52;
      __label__ = 14;
      break;
     case 14:
      var $53 = HEAP[$0];
      HEAP[$retval] = $53;
      __label__ = 15;
      break;
     case 15:
      var $retval13 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_detach($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $raw = __stackBase__ + 16;
      var $res = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_flush];
      
      var $13 = HEAP[$self_addr];
      var $14 = _PyObject_CallMethodObjArgs($13, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $14;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $20 = HEAP[HEAP[$res]] - 1;
      
      var $22 = HEAP[$res];
      HEAP[$22] = $20;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $31 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $32 = HEAP[$res];
      FUNCTION_TABLE[$31]($32);
      __label__ = 9;
      break;
     case 9:
      
      
      var $35 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$raw] = $35;
      
      var $37 = HEAP[$self_addr] + 8;
      HEAP[$37] = 0;
      
      var $39 = HEAP[$self_addr] + 16;
      HEAP[$39] = 1;
      
      var $41 = HEAP[$self_addr] + 12;
      HEAP[$41] = 0;
      var $42 = HEAP[$raw];
      HEAP[$0] = $42;
      __label__ = 10;
      break;
     case 10:
      var $43 = HEAP[$0];
      HEAP[$retval] = $43;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_seekable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_seekable];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_readable];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_writable];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_name_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 8];
      var $14 = _PyObject_GetAttrString($13, __str13);
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_mode_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 8];
      var $14 = _PyObject_GetAttrString($13, __str14);
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_fileno($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_fileno];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_isatty($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_isatty];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 8];
      var $15 = _PyObject_CallMethodObjArgs($14, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_check_blocking_error() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval = __stackBase__;
      var $0 = __stackBase__ + 4;
      var $t = __stackBase__ + 8;
      var $v = __stackBase__ + 12;
      var $tb = __stackBase__ + 16;
      var $err = __stackBase__ + 20;
      
      _PyErr_Fetch($t, $v, $tb);
      
      
      if (HEAP[$v] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      var $3 = HEAP[_PyExc_BlockingIOError];
      var $4 = HEAP[$v];
      var $5 = _PyErr_GivenExceptionMatches($4, $3);
      
      if ($5 == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $7 = HEAP[$tb];
      var $8 = HEAP[$v];
      var $9 = HEAP[$t];
      _PyErr_Restore($9, $8, $7);
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 3:
      
      var $11 = HEAP[$v];
      HEAP[$err] = $11;
      var $12 = HEAP[$tb];
      var $13 = HEAP[$v];
      var $14 = HEAP[$t];
      _PyErr_Restore($14, $13, $12);
      
      var $16 = HEAP[$err] + 32;
      HEAP[$0] = $16;
      __label__ = 4;
      break;
     case 4:
      var $17 = HEAP[$0];
      HEAP[$retval] = $17;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_raw_tell($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 20;
      var $res = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      var $1 = HEAP[__PyIO_str_tell];
      
      
      var $4 = HEAP[HEAP[$self_addr] + 8];
      var $5 = _PyObject_CallMethodObjArgs($4, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $5;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 2:
      var $8 = HEAP[_PyExc_ValueError];
      var $9 = HEAP[$res];
      var $10 = _PyNumber_AsOff_t($9, $8);
      HEAP[$n] = $10;
      
      
      
      var $14 = HEAP[HEAP[$res]] - 1;
      
      var $16 = HEAP[$res];
      HEAP[$16] = $14;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $26 = HEAP[$res];
      FUNCTION_TABLE[$25]($26);
      __label__ = 4;
      break;
     case 4:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 5:
      var $29 = _PyErr_Occurred();
      
      if ($29 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $31 = HEAP[_PyExc_IOError];
      var $32 = HEAP[$n];
      var $33 = _PyErr_Format($31, __str15, allocate([ $32, 0, 0, 0, 0, 0, 0, 0 ], [ "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      __label__ = 7;
      break;
     case 7:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 8:
      
      var $35 = HEAP[$self_addr] + 32;
      var $36 = HEAP[$n];
      HEAP[$35] = $36;
      var $37 = HEAP[$n];
      HEAP[$0] = $37;
      __label__ = 9;
      break;
     case 9:
      var $38 = HEAP[$0];
      HEAP[$retval] = $38;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_raw_seek($self, $target, $whence) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $target_addr = __stackBase__ + 4;
      var $whence_addr = __stackBase__ + 12;
      var $retval = __stackBase__ + 16;
      var $0 = __stackBase__ + 24;
      var $res = __stackBase__ + 32;
      var $posobj = __stackBase__ + 36;
      var $whenceobj = __stackBase__ + 40;
      var $n = __stackBase__ + 44;
      
      HEAP[$self_addr] = $self;
      HEAP[$target_addr] = $target;
      HEAP[$whence_addr] = $whence;
      var $1 = HEAP[$target_addr];
      var $2 = _PyLong_FromLongLong($1);
      HEAP[$posobj] = $2;
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 2:
      var $5 = HEAP[$whence_addr];
      var $6 = _PyLong_FromLong($5);
      HEAP[$whenceobj] = $6;
      
      
      if (HEAP[$whenceobj] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      
      var $12 = HEAP[HEAP[$posobj]] - 1;
      
      var $14 = HEAP[$posobj];
      HEAP[$14] = $12;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $24 = HEAP[$posobj];
      FUNCTION_TABLE[$23]($24);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 6:
      var $25 = HEAP[__PyIO_str_seek];
      
      
      var $28 = HEAP[HEAP[$self_addr] + 8];
      var $29 = HEAP[$posobj];
      var $30 = HEAP[$whenceobj];
      var $31 = _PyObject_CallMethodObjArgs($28, $25, allocate([ $29, 0, 0, 0, $30, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $31;
      
      
      
      var $35 = HEAP[HEAP[$posobj]] - 1;
      
      var $37 = HEAP[$posobj];
      HEAP[$37] = $35;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $46 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $47 = HEAP[$posobj];
      FUNCTION_TABLE[$46]($47);
      __label__ = 8;
      break;
     case 8:
      
      
      
      var $51 = HEAP[HEAP[$whenceobj]] - 1;
      
      var $53 = HEAP[$whenceobj];
      HEAP[$53] = $51;
      
      
      
      
      if (HEAP[HEAP[$whenceobj]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $62 = HEAP[HEAP[HEAP[$whenceobj] + 4] + 24];
      var $63 = HEAP[$whenceobj];
      FUNCTION_TABLE[$62]($63);
      __label__ = 10;
      break;
     case 10:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 12:
      var $66 = HEAP[_PyExc_ValueError];
      var $67 = HEAP[$res];
      var $68 = _PyNumber_AsOff_t($67, $66);
      HEAP[$n] = $68;
      
      
      
      var $72 = HEAP[HEAP[$res]] - 1;
      
      var $74 = HEAP[$res];
      HEAP[$74] = $72;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $83 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $84 = HEAP[$res];
      FUNCTION_TABLE[$83]($84);
      __label__ = 14;
      break;
     case 14:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      var $87 = _PyErr_Occurred();
      
      if ($87 == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      var $89 = HEAP[_PyExc_IOError];
      var $90 = HEAP[$n];
      var $91 = _PyErr_Format($89, __str15, allocate([ $90, 0, 0, 0, 0, 0, 0, 0 ], [ "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      __label__ = 17;
      break;
     case 17:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 18:
      
      var $93 = HEAP[$self_addr] + 32;
      var $94 = HEAP[$n];
      HEAP[$93] = $94;
      var $95 = HEAP[$n];
      HEAP[$0] = $95;
      __label__ = 19;
      break;
     case 19:
      var $96 = HEAP[$0];
      HEAP[$retval] = $96;
      __label__ = 20;
      break;
     case 20:
      var $retval19 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_init($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $n = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str16);
      HEAP[$0] = -1;
      __label__ = 15;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      var $12 = HEAP[HEAP[$self_addr] + 40];
      _PyMem_Free($12);
      __label__ = 4;
      break;
     case 4:
      
      
      var $15 = HEAP[HEAP[$self_addr] + 84];
      var $16 = _PyMem_Malloc($15);
      
      var $18 = HEAP[$self_addr] + 40;
      HEAP[$18] = $16;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $23 = _PyErr_NoMemory();
      HEAP[$0] = -1;
      __label__ = 15;
      break;
     case 6:
      
      
      
      var $27 = HEAP[HEAP[$self_addr] + 84] - 1;
      HEAP[$n] = $27;
      __label__ = 8;
      break;
     case 7:
      
      var $29 = HEAP[$n] >> 1;
      HEAP[$n] = $29;
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if ((HEAP[$n] & 1 & 255) != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if (HEAP[$n] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      var $38 = HEAP[HEAP[$self_addr] + 84] - 1;
      
      var $40 = HEAP[$self_addr] + 88;
      HEAP[$40] = $38;
      __label__ = 12;
      break;
     case 11:
      
      var $42 = HEAP[$self_addr] + 88;
      HEAP[$42] = 0;
      __label__ = 12;
      break;
     case 12:
      var $43 = HEAP[$self_addr];
      var $44 = __buffered_raw_tell($43);
      var $45 = $44 == -1;
      if ($45) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      _PyErr_Clear();
      __label__ = 14;
      break;
     case 14:
      HEAP[$0] = 0;
      __label__ = 15;
      break;
     case 15:
      var $46 = HEAP[$0];
      HEAP[$retval] = $46;
      __label__ = 16;
      break;
     case 16:
      var $retval15 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __trap_eintr() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval = __stackBase__;
      var $0 = __stackBase__ + 4;
      var $typ = __stackBase__ + 8;
      var $val = __stackBase__ + 12;
      var $tb = __stackBase__ + 16;
      var $env_err = __stackBase__ + 20;
      
      
      
      if (HEAP[_eintr_int_9041] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      var $3 = _PyLong_FromLong(4);
      HEAP[_eintr_int_9041] = $3;
      
      
      if (HEAP[_eintr_int_9041] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str17, __str10, 699, ___PRETTY_FUNCTION___9046);
      throw "Reached an unreachable!";
     case 3:
      var $6 = HEAP[_PyExc_EnvironmentError];
      var $7 = _PyErr_ExceptionMatches($6);
      
      if ($7 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 5:
      _PyErr_Fetch($typ, $val, $tb);
      _PyErr_NormalizeException($typ, $val, $tb);
      
      var $10 = HEAP[$val];
      HEAP[$env_err] = $10;
      
      
      if (HEAP[$env_err] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      ___assert_fail(__str18, __str10, 706, ___PRETTY_FUNCTION___9046);
      throw "Reached an unreachable!";
     case 7:
      
      
      
      
      if (HEAP[HEAP[$env_err] + 20] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 8:
      var $17 = HEAP[_eintr_int_9041];
      
      
      var $20 = HEAP[HEAP[$env_err] + 20];
      var $21 = _PyObject_RichCompareBool($20, $17, 2);
      
      if ($21 > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 9:
      var $23 = HEAP[$typ];
      
      
      var $26 = HEAP[$23] - 1;
      var $27 = $23;
      HEAP[$27] = $26;
      
      
      
      if (HEAP[$23] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $35 = HEAP[HEAP[HEAP[$typ] + 4] + 24];
      var $36 = HEAP[$typ];
      FUNCTION_TABLE[$35]($36);
      __label__ = 11;
      break;
     case 11:
      var $37 = HEAP[$val];
      
      
      var $40 = HEAP[$37] - 1;
      var $41 = $37;
      HEAP[$41] = $40;
      
      
      
      if (HEAP[$37] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $49 = HEAP[HEAP[HEAP[$val] + 4] + 24];
      var $50 = HEAP[$val];
      FUNCTION_TABLE[$49]($50);
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$tb] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $53 = HEAP[$tb];
      
      
      var $56 = HEAP[$53] - 1;
      var $57 = $53;
      HEAP[$57] = $56;
      
      
      
      if (HEAP[$53] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $65 = HEAP[HEAP[HEAP[$tb] + 4] + 24];
      var $66 = HEAP[$tb];
      FUNCTION_TABLE[$65]($66);
      __label__ = 16;
      break;
     case 16:
      HEAP[$0] = 1;
      __label__ = 18;
      break;
     case 17:
      var $67 = HEAP[$tb];
      var $68 = HEAP[$val];
      var $69 = HEAP[$typ];
      _PyErr_Restore($69, $68, $67);
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 18:
      var $70 = HEAP[$0];
      HEAP[$retval] = $70;
      __label__ = 19;
      break;
     case 19:
      var $retval18 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_flush($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 41;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 41);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_86 = __stackBase__ + 12;
      var $iftmp_84 = __stackBase__ + 20;
      var $0 = __stackBase__ + 21;
      var $res = __stackBase__ + 25;
      var $n = __stackBase__ + 29;
      var $_py_tmp = __stackBase__ + 37;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 25;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      var $17 = HEAP[HEAP[$self_addr] + 8];
      var $18 = __PyFileIO_closed($17);
      
      var $20 = $18 != 0;
      HEAP[$iftmp_84] = $20;
      __label__ = 8;
      break;
     case 7:
      var $21 = HEAP[$self_addr];
      var $22 = _buffered_closed($21);
      
      var $24 = $22 != 0;
      HEAP[$iftmp_84] = $24;
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$iftmp_84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $26 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($26, __str19);
      HEAP[$0] = 0;
      __label__ = 25;
      break;
     case 10:
      var $27 = HEAP[$self_addr];
      var $28 = __bufferedwriter_flush_unlocked($27, 0);
      HEAP[$res] = $28;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      var $42 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($42) {
        __label__ = 16;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $50 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($50) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      
      
      var $61 = HEAP[HEAP[$self_addr] + 44] - HEAP[HEAP[$self_addr] + 52];
      HEAP[$iftmp_86] = $61;
      __label__ = 19;
      break;
     case 18:
      HEAP[$iftmp_86] = 0;
      __label__ = 19;
      break;
     case 19:
      var $62 = HEAP[$self_addr];
      var $63 = HEAP[$iftmp_86];
      var $64 = __buffered_raw_seek($62, $63, 1);
      HEAP[$n] = $64;
      
      var $66 = HEAP[$n] == -1;
      if ($66) {
        __label__ = 20;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 20:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 21:
      var $69 = HEAP[$res];
      HEAP[$_py_tmp] = $69;
      HEAP[$res] = 0;
      
      
      
      var $73 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $75 = HEAP[$_py_tmp];
      HEAP[$75] = $73;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $84 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $85 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$84]($85);
      __label__ = 23;
      break;
     case 23:
      var $86 = HEAP[$self_addr];
      __bufferedreader_reset_buf($86);
      __label__ = 24;
      break;
     case 24:
      var $87 = HEAP[$res];
      HEAP[$0] = $87;
      __label__ = 25;
      break;
     case 25:
      var $88 = HEAP[$0];
      HEAP[$retval] = $88;
      __label__ = 26;
      break;
     case 26:
      var $retval25 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval25;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_peek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      var $res = __stackBase__ + 20;
      var $_py_tmp = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$n] = 0;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str20, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      var $18 = HEAP[$self_addr];
      var $19 = __bufferedwriter_flush_unlocked($18, 1);
      HEAP[$res] = $19;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      var $24 = HEAP[$res];
      HEAP[$_py_tmp] = $24;
      HEAP[$res] = 0;
      
      
      
      var $28 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $30 = HEAP[$_py_tmp];
      HEAP[$30] = $28;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $39 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $40 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$39]($40);
      __label__ = 12;
      break;
     case 12:
      var $41 = HEAP[$n];
      var $42 = HEAP[$self_addr];
      var $43 = __bufferedreader_peek_unlocked($42, $41);
      HEAP[$res] = $43;
      __label__ = 13;
      break;
     case 13:
      var $44 = HEAP[$res];
      HEAP[$0] = $44;
      __label__ = 14;
      break;
     case 14:
      var $45 = HEAP[$0];
      HEAP[$retval] = $45;
      __label__ = 15;
      break;
     case 15:
      var $retval13 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 25;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 25);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_94 = __stackBase__ + 12;
      var $0 = __stackBase__ + 13;
      var $n = __stackBase__ + 17;
      var $res = __stackBase__ + 21;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$n] = -1;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str21, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $n, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 7:
      
      var $15 = HEAP[$n] < -1;
      if ($15) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $16 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($16, __str22);
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 9:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      var $23 = HEAP[HEAP[$self_addr] + 8];
      var $24 = __PyFileIO_closed($23);
      
      var $26 = $24 != 0;
      HEAP[$iftmp_94] = $26;
      __label__ = 12;
      break;
     case 11:
      var $27 = HEAP[$self_addr];
      var $28 = _buffered_closed($27);
      
      var $30 = $28 != 0;
      HEAP[$iftmp_94] = $30;
      __label__ = 12;
      break;
     case 12:
      
      
      if (HEAP[$iftmp_94] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $32 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($32, __str23);
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 14:
      
      var $34 = HEAP[$n] == -1;
      if ($34) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $35 = HEAP[$self_addr];
      var $36 = __bufferedreader_read_all($35);
      HEAP[$res] = $36;
      __label__ = 20;
      break;
     case 16:
      var $37 = HEAP[$n];
      var $38 = HEAP[$self_addr];
      var $39 = __bufferedreader_read_fast($38, $37);
      HEAP[$res] = $39;
      
      
      if (HEAP[$res] == __Py_NoneStruct) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      
      var $45 = HEAP[HEAP[$res]] - 1;
      
      var $47 = HEAP[$res];
      HEAP[$47] = $45;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $56 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $57 = HEAP[$res];
      FUNCTION_TABLE[$56]($57);
      __label__ = 19;
      break;
     case 19:
      var $58 = HEAP[$n];
      var $59 = HEAP[$self_addr];
      var $60 = __bufferedreader_read_generic($59, $58);
      HEAP[$res] = $60;
      __label__ = 20;
      break;
     case 20:
      var $61 = HEAP[$res];
      HEAP[$0] = $61;
      __label__ = 21;
      break;
     case 21:
      var $62 = HEAP[$0];
      HEAP[$retval] = $62;
      __label__ = 22;
      break;
     case 22:
      var $retval21 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_read1($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_104 = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $have = __stackBase__ + 24;
      var $r = __stackBase__ + 28;
      var $res = __stackBase__ + 32;
      var $_py_tmp = __stackBase__ + 36;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str24, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 7:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $16 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($16, __str25);
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 9:
      
      
      if (HEAP[$n] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $19 = _PyString_FromStringAndSize(0, 0);
      HEAP[$0] = $19;
      __label__ = 34;
      break;
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 12:
      var $24 = HEAP[$self_addr];
      var $25 = __bufferedwriter_flush_unlocked($24, 1);
      HEAP[$res] = $25;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $30 = HEAP[$res];
      HEAP[$_py_tmp] = $30;
      HEAP[$res] = 0;
      
      
      
      var $34 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $36 = HEAP[$_py_tmp];
      HEAP[$36] = $34;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $46 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$45]($46);
      __label__ = 16;
      break;
     case 16:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      
      var $58 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($58) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      
      
      
      
      var $67 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_104] = $67;
      __label__ = 21;
      break;
     case 20:
      HEAP[$iftmp_104] = 0;
      __label__ = 21;
      break;
     case 21:
      var $68 = HEAP[$iftmp_104];
      HEAP[$have] = $68;
      
      
      if (HEAP[$have] > 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 22:
      
      
      
      if (HEAP[$n] > HEAP[$have]) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      var $74 = HEAP[$have];
      HEAP[$n] = $74;
      __label__ = 24;
      break;
     case 24:
      var $75 = HEAP[$n];
      
      
      
      
      
      
      
      var $83 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      var $84 = _PyString_FromStringAndSize($83, $75);
      HEAP[$res] = $84;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      
      
      
      var $92 = HEAP[HEAP[$self_addr] + 44] + HEAP[$n];
      
      var $94 = HEAP[$self_addr] + 44;
      HEAP[$94] = $92;
      __label__ = 33;
      break;
     case 26:
      var $95 = HEAP[$self_addr];
      __bufferedreader_reset_buf($95);
      var $96 = HEAP[$self_addr];
      var $97 = __bufferedreader_fill_buffer($96);
      HEAP[$r] = $97;
      
      var $99 = HEAP[$r] == -1;
      if ($99) {
        __label__ = 33;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      
      var $101 = HEAP[$r] == -2;
      if ($101) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      HEAP[$r] = 0;
      __label__ = 29;
      break;
     case 29:
      
      
      
      if (HEAP[$n] > HEAP[$r]) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      var $105 = HEAP[$r];
      HEAP[$n] = $105;
      __label__ = 31;
      break;
     case 31:
      var $106 = HEAP[$n];
      
      
      var $109 = HEAP[HEAP[$self_addr] + 40];
      var $110 = _PyString_FromStringAndSize($109, $106);
      HEAP[$res] = $110;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      var $114 = HEAP[$n];
      
      var $116 = HEAP[$self_addr] + 44;
      HEAP[$116] = $114;
      __label__ = 33;
      break;
     case 33:
      var $117 = HEAP[$res];
      HEAP[$0] = $117;
      __label__ = 34;
      break;
     case 34:
      var $118 = HEAP[$0];
      HEAP[$retval] = $118;
      __label__ = 35;
      break;
     case 35:
      var $retval33 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval33;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      var $15 = HEAP[$self_addr];
      var $16 = __bufferedwriter_flush_unlocked($15, 0);
      HEAP[$res] = $16;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      var $22 = HEAP[HEAP[$res]] - 1;
      
      var $24 = HEAP[$res];
      HEAP[$24] = $22;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $33 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $34 = HEAP[$res];
      FUNCTION_TABLE[$33]($34);
      __label__ = 9;
      break;
     case 9:
      
      var $36 = HEAP[$self_addr];
      var $37 = HEAP[$args_addr];
      var $38 = _bufferediobase_readinto($36, $37);
      HEAP[$res] = $38;
      __label__ = 10;
      break;
     case 10:
      var $39 = HEAP[$res];
      HEAP[$0] = $39;
      __label__ = 11;
      break;
     case 11:
      var $40 = HEAP[$0];
      HEAP[$retval] = $40;
      __label__ = 12;
      break;
     case 12:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __buffered_readline($self, $limit) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 77;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 77);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $limit_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_116 = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $iftmp_114 = __stackBase__ + 20;
      var $res = __stackBase__ + 21;
      var $chunks = __stackBase__ + 25;
      var $n = __stackBase__ + 29;
      var $written = __stackBase__ + 33;
      var $start = __stackBase__ + 37;
      var $s = __stackBase__ + 41;
      var $end = __stackBase__ + 45;
      var $_py_tmp = __stackBase__ + 49;
      var $_py_tmp31 = __stackBase__ + 53;
      var $_py_tmp36 = __stackBase__ + 57;
      var $_py_tmp57 = __stackBase__ + 61;
      var $_py_tmp62 = __stackBase__ + 65;
      var $_py_tmp70 = __stackBase__ + 69;
      var $_py_tmp75 = __stackBase__ + 73;
      
      HEAP[$self_addr] = $self;
      HEAP[$limit_addr] = $limit;
      HEAP[$res] = 0;
      HEAP[$chunks] = 0;
      HEAP[$written] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      var $8 = __PyFileIO_closed($7);
      
      var $10 = $8 != 0;
      HEAP[$iftmp_114] = $10;
      __label__ = 3;
      break;
     case 2:
      var $11 = HEAP[$self_addr];
      var $12 = _buffered_closed($11);
      
      var $14 = $12 != 0;
      HEAP[$iftmp_114] = $14;
      __label__ = 3;
      break;
     case 3:
      
      
      if (HEAP[$iftmp_114] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $16 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($16, __str26);
      HEAP[$0] = 0;
      __label__ = 78;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      var $28 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($28) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      
      var $37 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_116] = $37;
      __label__ = 10;
      break;
     case 9:
      HEAP[$iftmp_116] = 0;
      __label__ = 10;
      break;
     case 10:
      var $38 = HEAP[$iftmp_116];
      HEAP[$n] = $38;
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      if (HEAP[$n] > HEAP[$limit_addr]) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      var $44 = HEAP[$limit_addr];
      HEAP[$n] = $44;
      __label__ = 13;
      break;
     case 13:
      
      
      
      
      
      
      
      var $52 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$start] = $52;
      var $53 = HEAP[$n];
      var $54 = HEAP[$start];
      var $55 = _memchr($54, 10, $53);
      HEAP[$s] = $55;
      
      
      if (HEAP[$s] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      
      
      var $63 = HEAP[$s] - HEAP[$start] + 1;
      var $64 = HEAP[$start];
      var $65 = _PyString_FromStringAndSize($64, $63);
      HEAP[$res] = $65;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      
      
      
      
      
      
      var $78 = HEAP[HEAP[$self_addr] + 44] + (HEAP[$s] - HEAP[$start] + 1);
      
      var $80 = HEAP[$self_addr] + 44;
      HEAP[$80] = $78;
      __label__ = 16;
      break;
     case 16:
      __label__ = 73;
      break;
     case 17:
      
      
      
      if (HEAP[$n] == HEAP[$limit_addr]) {
        __label__ = 18;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 18:
      var $84 = HEAP[$start];
      var $85 = HEAP[$n];
      var $86 = _PyString_FromStringAndSize($84, $85);
      HEAP[$res] = $86;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      
      var $94 = HEAP[HEAP[$self_addr] + 44] + HEAP[$n];
      
      var $96 = HEAP[$self_addr] + 44;
      HEAP[$96] = $94;
      __label__ = 20;
      break;
     case 20:
      __label__ = 73;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 22:
      var $101 = HEAP[$self_addr];
      var $102 = __bufferedwriter_flush_unlocked($101, 1);
      HEAP[$res] = $102;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 23:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 24:
      var $107 = HEAP[$res];
      HEAP[$_py_tmp] = $107;
      HEAP[$res] = 0;
      
      
      
      var $111 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $113 = HEAP[$_py_tmp];
      HEAP[$113] = $111;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $122 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $123 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$122]($123);
      __label__ = 26;
      break;
     case 26:
      var $124 = _PyList_New(0);
      HEAP[$chunks] = $124;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      
      
      if (HEAP[$n] > 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 28:
      var $129 = HEAP[$start];
      var $130 = HEAP[$n];
      var $131 = _PyString_FromStringAndSize($129, $130);
      HEAP[$res] = $131;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      var $134 = HEAP[$chunks];
      var $135 = HEAP[$res];
      var $136 = _PyList_Append($134, $135);
      
      if ($136 < 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 30:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      var $140 = HEAP[$res];
      HEAP[$_py_tmp31] = $140;
      HEAP[$res] = 0;
      
      
      
      var $144 = HEAP[HEAP[$_py_tmp31]] - 1;
      
      var $146 = HEAP[$_py_tmp31];
      HEAP[$146] = $144;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp31]] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $155 = HEAP[HEAP[HEAP[$_py_tmp31] + 4] + 24];
      var $156 = HEAP[$_py_tmp31];
      FUNCTION_TABLE[$155]($156);
      __label__ = 33;
      break;
     case 33:
      __label__ = 73;
      break;
     case 34:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 35:
      var $159 = HEAP[$res];
      HEAP[$_py_tmp36] = $159;
      HEAP[$res] = 0;
      
      
      
      var $163 = HEAP[HEAP[$_py_tmp36]] - 1;
      
      var $165 = HEAP[$_py_tmp36];
      HEAP[$165] = $163;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp36]] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      
      
      
      
      var $174 = HEAP[HEAP[HEAP[$_py_tmp36] + 4] + 24];
      var $175 = HEAP[$_py_tmp36];
      FUNCTION_TABLE[$174]($175);
      __label__ = 37;
      break;
     case 37:
      
      
      var $178 = HEAP[$written] + HEAP[$n];
      HEAP[$written] = $178;
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      var $183 = HEAP[$limit_addr] - HEAP[$n];
      HEAP[$limit_addr] = $183;
      __label__ = 39;
      break;
     case 39:
      var $184 = HEAP[$self_addr];
      __bufferedreader_reset_buf($184);
      var $185 = HEAP[$self_addr];
      var $186 = __bufferedreader_fill_buffer($185);
      HEAP[$n] = $186;
      
      var $188 = HEAP[$n] == -1;
      if ($188) {
        __label__ = 73;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 40:
      
      
      if (HEAP[$n] <= 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 41:
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 42:
      
      
      
      if (HEAP[$n] > HEAP[$limit_addr]) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      var $196 = HEAP[$limit_addr];
      HEAP[$n] = $196;
      __label__ = 44;
      break;
     case 44:
      
      
      var $199 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$start] = $199;
      
      
      var $202 = HEAP[$start] + HEAP[$n];
      HEAP[$end] = $202;
      var $203 = HEAP[$start];
      HEAP[$s] = $203;
      __label__ = 48;
      break;
     case 45:
      
      
      
      var $207 = HEAP[HEAP[$s]] == 10;
      
      var $209 = HEAP[$s] + 1;
      HEAP[$s] = $209;
      
      if ($207 != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      
      
      var $214 = HEAP[$s] - HEAP[$start];
      var $215 = HEAP[$start];
      var $216 = _PyString_FromStringAndSize($215, $214);
      HEAP[$res] = $216;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      
      
      
      var $224 = HEAP[$s] - HEAP[$start];
      
      var $226 = HEAP[$self_addr] + 44;
      HEAP[$226] = $224;
      __label__ = 63;
      break;
     case 48:
      
      
      
      if (HEAP[$s] < HEAP[$end]) {
        __label__ = 45;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      var $230 = HEAP[$start];
      var $231 = HEAP[$n];
      var $232 = _PyString_FromStringAndSize($230, $231);
      HEAP[$res] = $232;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      if (HEAP[$n] == HEAP[$limit_addr]) {
        __label__ = 51;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 51:
      
      var $239 = HEAP[$n];
      
      var $241 = HEAP[$self_addr] + 44;
      HEAP[$241] = $239;
      __label__ = 63;
      break;
     case 52:
      var $242 = HEAP[$chunks];
      var $243 = HEAP[$res];
      var $244 = _PyList_Append($242, $243);
      
      if ($244 < 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 53:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 54:
      var $248 = HEAP[$res];
      HEAP[$_py_tmp57] = $248;
      HEAP[$res] = 0;
      
      
      
      var $252 = HEAP[HEAP[$_py_tmp57]] - 1;
      
      var $254 = HEAP[$_py_tmp57];
      HEAP[$254] = $252;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp57]] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $263 = HEAP[HEAP[HEAP[$_py_tmp57] + 4] + 24];
      var $264 = HEAP[$_py_tmp57];
      FUNCTION_TABLE[$263]($264);
      __label__ = 56;
      break;
     case 56:
      __label__ = 73;
      break;
     case 57:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 58:
      var $267 = HEAP[$res];
      HEAP[$_py_tmp62] = $267;
      HEAP[$res] = 0;
      
      
      
      var $271 = HEAP[HEAP[$_py_tmp62]] - 1;
      
      var $273 = HEAP[$_py_tmp62];
      HEAP[$273] = $271;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp62]] == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      
      
      
      
      var $282 = HEAP[HEAP[HEAP[$_py_tmp62] + 4] + 24];
      var $283 = HEAP[$_py_tmp62];
      FUNCTION_TABLE[$282]($283);
      __label__ = 60;
      break;
     case 60:
      
      
      var $286 = HEAP[$written] + HEAP[$n];
      HEAP[$written] = $286;
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 61:
      
      
      var $291 = HEAP[$limit_addr] - HEAP[$n];
      HEAP[$limit_addr] = $291;
      __label__ = 62;
      break;
     case 62:
      __label__ = 39;
      break;
     case 63:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 64:
      var $294 = HEAP[$chunks];
      var $295 = HEAP[$res];
      var $296 = _PyList_Append($294, $295);
      
      if ($296 < 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 65:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 66:
      var $300 = HEAP[$res];
      HEAP[$_py_tmp70] = $300;
      HEAP[$res] = 0;
      
      
      
      var $304 = HEAP[HEAP[$_py_tmp70]] - 1;
      
      var $306 = HEAP[$_py_tmp70];
      HEAP[$306] = $304;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp70]] == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      
      
      
      
      var $315 = HEAP[HEAP[HEAP[$_py_tmp70] + 4] + 24];
      var $316 = HEAP[$_py_tmp70];
      FUNCTION_TABLE[$315]($316);
      __label__ = 68;
      break;
     case 68:
      __label__ = 73;
      break;
     case 69:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 70:
      var $319 = HEAP[$res];
      HEAP[$_py_tmp75] = $319;
      HEAP[$res] = 0;
      
      
      
      var $323 = HEAP[HEAP[$_py_tmp75]] - 1;
      
      var $325 = HEAP[$_py_tmp75];
      HEAP[$325] = $323;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp75]] == 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      
      
      
      
      var $334 = HEAP[HEAP[HEAP[$_py_tmp75] + 4] + 24];
      var $335 = HEAP[$_py_tmp75];
      FUNCTION_TABLE[$334]($335);
      __label__ = 72;
      break;
     case 72:
      var $336 = HEAP[__PyIO_empty_bytes];
      var $337 = HEAP[$chunks];
      var $338 = __PyString_Join($336, $337);
      HEAP[$res] = $338;
      __label__ = 73;
      break;
     case 73:
      __label__ = 74;
      break;
     case 74:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 75:
      
      
      
      var $344 = HEAP[HEAP[$chunks]] - 1;
      
      var $346 = HEAP[$chunks];
      HEAP[$346] = $344;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      
      
      
      
      var $355 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $356 = HEAP[$chunks];
      FUNCTION_TABLE[$355]($356);
      __label__ = 77;
      break;
     case 77:
      var $357 = HEAP[$res];
      HEAP[$0] = $357;
      __label__ = 78;
      break;
     case 78:
      var $358 = HEAP[$0];
      HEAP[$retval] = $358;
      __label__ = 79;
      break;
     case 79:
      var $retval83 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval83;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $limit = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$limit] = -1;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 8;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str27, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $limit, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 8;
      break;
     case 7:
      var $14 = HEAP[$limit];
      var $15 = HEAP[$self_addr];
      var $16 = __buffered_readline($15, $14);
      HEAP[$0] = $16;
      __label__ = 8;
      break;
     case 8:
      var $17 = HEAP[$0];
      HEAP[$retval] = $17;
      __label__ = 9;
      break;
     case 9:
      var $retval8 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_tell($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_133 = __stackBase__ + 12;
      var $0 = __stackBase__ + 20;
      var $pos = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 15;
      break;
     case 5:
      var $11 = HEAP[$self_addr];
      var $12 = __buffered_raw_tell($11);
      HEAP[$pos] = $12;
      
      var $14 = HEAP[$pos] == -1;
      if ($14) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 15;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      var $22 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($22) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      var $30 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($30) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      
      
      
      
      
      
      var $41 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_133] = $41;
      __label__ = 14;
      break;
     case 13:
      HEAP[$iftmp_133] = 0;
      __label__ = 14;
      break;
     case 14:
      
      
      var $44 = HEAP[$pos] - HEAP[$iftmp_133];
      HEAP[$pos] = $44;
      var $45 = HEAP[$pos];
      var $46 = _PyLong_FromLongLong($45);
      HEAP[$0] = $46;
      __label__ = 15;
      break;
     case 15:
      var $47 = HEAP[$0];
      HEAP[$retval] = $47;
      __label__ = 16;
      break;
     case 16:
      var $retval15 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 105;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 105);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_150 = __stackBase__ + 12;
      var $iftmp_148 = __stackBase__ + 20;
      var $iftmp_146 = __stackBase__ + 28;
      var $iftmp_145 = __stackBase__ + 36;
      var $iftmp_140 = __stackBase__ + 44;
      var $0 = __stackBase__ + 45;
      var $target = __stackBase__ + 49;
      var $n = __stackBase__ + 57;
      var $whence = __stackBase__ + 65;
      var $targetobj = __stackBase__ + 69;
      var $res = __stackBase__ + 73;
      var $current = __stackBase__ + 77;
      var $avail = __stackBase__ + 85;
      var $offset = __stackBase__ + 93;
      var $_py_tmp = __stackBase__ + 101;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$whence] = 0;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 62;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str28, allocate([ $targetobj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 62;
      break;
     case 7:
      
      
      if (HEAP[$whence] < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      if (HEAP[$whence] > 2) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $18 = HEAP[$whence];
      var $19 = HEAP[_PyExc_ValueError];
      var $20 = _PyErr_Format($19, __str29, allocate([ $18, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 62;
      break;
     case 10:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      var $27 = HEAP[HEAP[$self_addr] + 8];
      var $28 = __PyFileIO_closed($27);
      
      var $30 = $28 != 0;
      HEAP[$iftmp_140] = $30;
      __label__ = 13;
      break;
     case 12:
      var $31 = HEAP[$self_addr];
      var $32 = _buffered_closed($31);
      
      var $34 = $32 != 0;
      HEAP[$iftmp_140] = $34;
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$iftmp_140] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $36 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($36, __str30);
      HEAP[$0] = 0;
      __label__ = 62;
      break;
     case 15:
      var $37 = HEAP[_PyExc_ValueError];
      var $38 = HEAP[$targetobj];
      var $39 = _PyNumber_AsOff_t($38, $37);
      HEAP[$target] = $39;
      
      var $41 = HEAP[$target] == -1;
      if ($41) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      var $42 = _PyErr_Occurred();
      
      if ($42 != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      HEAP[$0] = 0;
      __label__ = 62;
      break;
     case 18:
      
      
      if (HEAP[$whence] != 2) {
        __label__ = 19;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 19:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 20:
      
      
      
      var $53 = HEAP[HEAP[$self_addr] + 32] != -1;
      if ($53) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      var $56 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$iftmp_145] = $56;
      __label__ = 23;
      break;
     case 22:
      var $57 = HEAP[$self_addr];
      var $58 = __buffered_raw_tell($57);
      HEAP[$iftmp_145] = $58;
      __label__ = 23;
      break;
     case 23:
      var $59 = HEAP[$iftmp_145];
      HEAP[$current] = $59;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      
      var $71 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($71) {
        __label__ = 27;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      
      
      
      
      
      var $78 = HEAP[HEAP[$self_addr] + 60] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_146] = $78;
      __label__ = 28;
      break;
     case 27:
      HEAP[$iftmp_146] = 0;
      __label__ = 28;
      break;
     case 28:
      var $79 = HEAP[$iftmp_146];
      HEAP[$avail] = $79;
      
      
      if (HEAP[$avail] > 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 29:
      
      
      if (HEAP[$whence] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      
      var $91 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($91) {
        __label__ = 34;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 33:
      
      
      
      var $99 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($99) {
        __label__ = 34;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 34:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 35:
      
      
      
      
      
      
      var $110 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_148] = $110;
      __label__ = 37;
      break;
     case 36:
      HEAP[$iftmp_148] = 0;
      __label__ = 37;
      break;
     case 37:
      
      
      
      
      var $115 = HEAP[$target] - (HEAP[$current] - HEAP[$iftmp_148]);
      HEAP[$offset] = $115;
      __label__ = 39;
      break;
     case 38:
      var $116 = HEAP[$target];
      HEAP[$offset] = $116;
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      
      
      if (0 - HEAP[HEAP[$self_addr] + 44] <= HEAP[$offset]) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      
      
      if (HEAP[$offset] <= HEAP[$avail]) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $130 = HEAP[HEAP[$self_addr] + 44] + HEAP[$offset];
      
      var $132 = HEAP[$self_addr] + 44;
      HEAP[$132] = $130;
      
      
      
      
      var $137 = HEAP[$current] - HEAP[$avail] + HEAP[$offset];
      var $138 = _PyLong_FromLongLong($137);
      HEAP[$0] = $138;
      __label__ = 62;
      break;
     case 42:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 43:
      var $143 = HEAP[$self_addr];
      var $144 = __bufferedwriter_flush_unlocked($143, 0);
      HEAP[$res] = $144;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 45:
      var $149 = HEAP[$res];
      HEAP[$_py_tmp] = $149;
      HEAP[$res] = 0;
      
      
      
      var $153 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $155 = HEAP[$_py_tmp];
      HEAP[$155] = $153;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      
      
      
      
      var $164 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $165 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$164]($165);
      __label__ = 47;
      break;
     case 47:
      var $166 = HEAP[$self_addr];
      __bufferedwriter_reset_buf($166);
      __label__ = 48;
      break;
     case 48:
      
      
      if (HEAP[$whence] == 1) {
        __label__ = 49;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 49:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      var $176 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($176) {
        __label__ = 53;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 51:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      
      
      var $184 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($184) {
        __label__ = 53;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 53:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 54:
      
      
      
      
      
      
      var $195 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_150] = $195;
      __label__ = 56;
      break;
     case 55:
      HEAP[$iftmp_150] = 0;
      __label__ = 56;
      break;
     case 56:
      
      
      var $198 = HEAP[$target] - HEAP[$iftmp_150];
      HEAP[$target] = $198;
      __label__ = 57;
      break;
     case 57:
      var $199 = HEAP[$whence];
      var $200 = HEAP[$self_addr];
      var $201 = HEAP[$target];
      var $202 = __buffered_raw_seek($200, $201, $199);
      HEAP[$n] = $202;
      
      var $204 = HEAP[$n] == -1;
      if ($204) {
        __label__ = 61;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      var $206 = HEAP[$self_addr] + 52;
      HEAP[$206] = -1;
      var $207 = HEAP[$n];
      var $208 = _PyLong_FromLongLong($207);
      HEAP[$res] = $208;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 59:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      var $215 = HEAP[$self_addr];
      __bufferedreader_reset_buf($215);
      __label__ = 61;
      break;
     case 61:
      var $216 = HEAP[$res];
      HEAP[$0] = $216;
      __label__ = 62;
      break;
     case 62:
      var $217 = HEAP[$0];
      HEAP[$retval] = $217;
      __label__ = 63;
      break;
     case 63:
      var $retval61 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval61;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_155 = __stackBase__ + 12;
      var $0 = __stackBase__ + 20;
      var $pos = __stackBase__ + 24;
      var $res = __stackBase__ + 28;
      var $_py_tmp = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$pos] = __Py_NoneStruct;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str31, allocate([ $pos, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      var $18 = HEAP[$self_addr];
      var $19 = __bufferedwriter_flush_unlocked($18, 0);
      HEAP[$res] = $19;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      var $24 = HEAP[$res];
      HEAP[$_py_tmp] = $24;
      HEAP[$res] = 0;
      
      
      
      var $28 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $30 = HEAP[$_py_tmp];
      HEAP[$30] = $28;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $39 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $40 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$39]($40);
      __label__ = 12;
      break;
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 13:
      
      
      if (HEAP[$pos] == __Py_NoneStruct) {
        __label__ = 14;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $54 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($54) {
        __label__ = 18;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      var $62 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($62) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      
      
      var $73 = HEAP[HEAP[$self_addr] + 44] - HEAP[HEAP[$self_addr] + 52];
      HEAP[$iftmp_155] = $73;
      __label__ = 21;
      break;
     case 20:
      HEAP[$iftmp_155] = 0;
      __label__ = 21;
      break;
     case 21:
      var $74 = HEAP[$self_addr];
      var $75 = HEAP[$iftmp_155];
      var $76 = __buffered_raw_seek($74, $75, 1);
      var $77 = $76 == -1;
      if ($77) {
        __label__ = 26;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      var $78 = HEAP[$self_addr];
      __bufferedreader_reset_buf($78);
      __label__ = 23;
      break;
     case 23:
      var $79 = HEAP[$pos];
      var $80 = HEAP[__PyIO_str_truncate];
      
      
      var $83 = HEAP[HEAP[$self_addr] + 8];
      var $84 = _PyObject_CallMethodObjArgs($83, $80, allocate([ $79, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $84;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      var $87 = HEAP[$self_addr];
      var $88 = __buffered_raw_tell($87);
      var $89 = $88 == -1;
      if ($89) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      _PyErr_Clear();
      __label__ = 26;
      break;
     case 26:
      var $90 = HEAP[$res];
      HEAP[$0] = $90;
      __label__ = 27;
      break;
     case 27:
      var $91 = HEAP[$0];
      HEAP[$retval] = $91;
      __label__ = 28;
      break;
     case 28:
      var $retval26 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval26;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $line = __stackBase__ + 12;
      var $tp = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 20;
      break;
     case 5:
      
      
      
      var $14 = HEAP[HEAP[$self_addr] + 4];
      HEAP[$tp] = $14;
      
      
      if (HEAP[$tp] == _PyBufferedReader_Type) {
        __label__ = 7;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      if (HEAP[$tp] == _PyBufferedRandom_Type) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      var $19 = HEAP[$self_addr];
      var $20 = __buffered_readline($19, -1);
      HEAP[$line] = $20;
      __label__ = 13;
      break;
     case 8:
      var $21 = HEAP[__PyIO_str_readline];
      
      var $23 = HEAP[$self_addr];
      var $24 = _PyObject_CallMethodObjArgs($23, $21, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$line] = $24;
      
      
      if (HEAP[$line] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 9:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$line] + 4] + 84] & 134217728) == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 10:
      
      
      
      
      var $38 = HEAP[HEAP[HEAP[$line] + 4] + 12];
      var $39 = HEAP[_PyExc_IOError];
      var $40 = _PyErr_Format($39, __str32, allocate([ $38, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $44 = HEAP[HEAP[$line]] - 1;
      
      var $46 = HEAP[$line];
      HEAP[$46] = $44;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $55 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $56 = HEAP[$line];
      FUNCTION_TABLE[$55]($56);
      __label__ = 12;
      break;
     case 12:
      HEAP[$0] = 0;
      __label__ = 20;
      break;
     case 13:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      HEAP[$0] = 0;
      __label__ = 20;
      break;
     case 15:
      
      
      
      
      
      if (HEAP[HEAP[$line] + 8] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 16:
      
      
      
      var $67 = HEAP[HEAP[$line]] - 1;
      
      var $69 = HEAP[$line];
      HEAP[$69] = $67;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $78 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $79 = HEAP[$line];
      FUNCTION_TABLE[$78]($79);
      __label__ = 18;
      break;
     case 18:
      HEAP[$0] = 0;
      __label__ = 20;
      break;
     case 19:
      var $80 = HEAP[$line];
      HEAP[$0] = $80;
      __label__ = 20;
      break;
     case 20:
      var $81 = HEAP[$0];
      HEAP[$retval] = $81;
      __label__ = 21;
      break;
     case 21:
      var $retval20 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval20;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _buffered_repr($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $nameobj = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $repr = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      var $2 = HEAP[$self_addr];
      var $3 = _PyObject_GetAttrString($2, __str13);
      HEAP[$nameobj] = $3;
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      var $6 = HEAP[_PyExc_AttributeError];
      var $7 = _PyErr_ExceptionMatches($6);
      
      if ($7 != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      _PyErr_Clear();
      
      
      
      
      
      var $14 = HEAP[HEAP[HEAP[$self_addr] + 4] + 12];
      var $15 = _PyString_FromFormat(__str33, allocate([ $14, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $15;
      __label__ = 10;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 4:
      var $16 = HEAP[$nameobj];
      var $17 = _PyObject_Repr($16);
      HEAP[$repr] = $17;
      
      
      
      var $21 = HEAP[HEAP[$nameobj]] - 1;
      
      var $23 = HEAP[$nameobj];
      HEAP[$23] = $21;
      
      
      
      
      if (HEAP[HEAP[$nameobj]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $32 = HEAP[HEAP[HEAP[$nameobj] + 4] + 24];
      var $33 = HEAP[$nameobj];
      FUNCTION_TABLE[$32]($33);
      __label__ = 6;
      break;
     case 6:
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 8:
      
      
      
      var $39 = HEAP[$repr] + 20;
      
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$self_addr] + 4] + 12];
      var $46 = _PyString_FromFormat(__str34, allocate([ $45, 0, 0, 0, $39, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $46;
      
      
      
      var $50 = HEAP[HEAP[$repr]] - 1;
      
      var $52 = HEAP[$repr];
      HEAP[$52] = $50;
      
      
      
      
      if (HEAP[HEAP[$repr]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $61 = HEAP[HEAP[HEAP[$repr] + 4] + 24];
      var $62 = HEAP[$repr];
      FUNCTION_TABLE[$61]($62);
      __label__ = 10;
      break;
     case 10:
      var $63 = HEAP[$res];
      HEAP[$0] = $63;
      __label__ = 11;
      break;
     case 11:
      var $64 = HEAP[$0];
      HEAP[$retval] = $64;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_reset_buf($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      
      HEAP[__stackBase__] = $self;
      
      var $1 = HEAP[__stackBase__] + 60;
      HEAP[$1] = -1;
      __label__ = 1;
      break;
     case 1:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedreader_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 48;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 48);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_176 = __stackBase__ + 16;
      var $0 = __stackBase__ + 20;
      var $kwlist = __stackBase__ + 24;
      var $buffer_size = __stackBase__ + 36;
      var $raw = __stackBase__ + 40;
      var $_py_tmp = __stackBase__ + 44;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_170_9977];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_170_9977 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_170_9977 + 8];
      HEAP[$kwlist + 8] = $6;
      HEAP[$buffer_size] = 8192;
      
      var $8 = HEAP[$self_addr] + 12;
      HEAP[$8] = 0;
      
      var $10 = HEAP[$self_addr] + 16;
      HEAP[$10] = 0;
      var $11 = HEAP[$args_addr];
      var $12 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $13 = __PyArg_ParseTupleAndKeywords_SizeT($11, $12, __str37, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($13 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 14;
      break;
     case 2:
      var $15 = HEAP[$raw];
      var $16 = __PyIOBase_check_readable($15, __Py_TrueStruct);
      
      if ($16 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = -1;
      __label__ = 14;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      var $24 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $24;
      
      var $26 = HEAP[$self_addr] + 8;
      HEAP[$26] = 0;
      
      
      
      var $30 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $32 = HEAP[$_py_tmp];
      HEAP[$32] = $30;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $41 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $42 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$41]($42);
      __label__ = 7;
      break;
     case 7:
      
      
      
      var $46 = HEAP[HEAP[$raw]] + 1;
      var $47 = HEAP[$raw];
      HEAP[$47] = $46;
      var $48 = HEAP[$raw];
      
      var $50 = HEAP[$self_addr] + 8;
      HEAP[$50] = $48;
      var $51 = HEAP[$buffer_size];
      
      var $53 = HEAP[$self_addr] + 84;
      HEAP[$53] = $51;
      
      var $55 = HEAP[$self_addr] + 20;
      HEAP[$55] = 1;
      
      var $57 = HEAP[$self_addr] + 24;
      HEAP[$57] = 0;
      var $58 = HEAP[$self_addr];
      var $59 = __buffered_init($58);
      
      if ($59 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = -1;
      __label__ = 14;
      break;
     case 9:
      var $61 = HEAP[$self_addr];
      __bufferedreader_reset_buf($61);
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] != _PyBufferedReader_Type) {
        __label__ = 12;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 12;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      HEAP[$iftmp_176] = 1;
      __label__ = 13;
      break;
     case 12:
      HEAP[$iftmp_176] = 0;
      __label__ = 13;
      break;
     case 13:
      
      var $72 = HEAP[$self_addr] + 28;
      var $73 = HEAP[$iftmp_176];
      HEAP[$72] = $73;
      
      var $75 = HEAP[$self_addr] + 12;
      HEAP[$75] = 1;
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 14:
      var $76 = HEAP[$0];
      HEAP[$retval] = $76;
      __label__ = 15;
      break;
     case 15:
      var $retval15 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_raw_read($self, $start, $len) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 84;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 84);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $start_addr = __stackBase__ + 4;
      var $len_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $buf = __stackBase__ + 20;
      var $memobj = __stackBase__ + 72;
      var $res = __stackBase__ + 76;
      var $n = __stackBase__ + 80;
      
      HEAP[$self_addr] = $self;
      HEAP[$start_addr] = $start;
      HEAP[$len_addr] = $len;
      var $1 = HEAP[$start_addr];
      var $2 = HEAP[$len_addr];
      var $3 = _PyBuffer_FillInfo($buf, 0, $1, $2, 0, 9);
      var $4 = $3 == -1;
      if ($4) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 23;
      break;
     case 2:
      var $5 = _PyMemoryView_FromBuffer($buf);
      HEAP[$memobj] = $5;
      
      
      if (HEAP[$memobj] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = -1;
      __label__ = 23;
      break;
     case 4:
      var $8 = HEAP[__PyIO_str_readinto];
      
      
      var $11 = HEAP[HEAP[$self_addr] + 8];
      var $12 = HEAP[$memobj];
      var $13 = _PyObject_CallMethodObjArgs($11, $8, allocate([ $12, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $13;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $16 = __trap_eintr();
      
      if ($16 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $21 = HEAP[HEAP[$memobj]] - 1;
      
      var $23 = HEAP[$memobj];
      HEAP[$23] = $21;
      
      
      
      
      if (HEAP[HEAP[$memobj]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $32 = HEAP[HEAP[HEAP[$memobj] + 4] + 24];
      var $33 = HEAP[$memobj];
      FUNCTION_TABLE[$32]($33);
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = -1;
      __label__ = 23;
      break;
     case 10:
      
      
      if (HEAP[$res] == __Py_NoneStruct) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      
      
      
      var $41 = HEAP[HEAP[$res]] - 1;
      
      var $43 = HEAP[$res];
      HEAP[$43] = $41;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $52 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $53 = HEAP[$res];
      FUNCTION_TABLE[$52]($53);
      __label__ = 13;
      break;
     case 13:
      HEAP[$0] = -2;
      __label__ = 23;
      break;
     case 14:
      var $54 = HEAP[_PyExc_ValueError];
      var $55 = HEAP[$res];
      var $56 = _PyNumber_AsSsize_t($55, $54);
      HEAP[$n] = $56;
      
      
      
      var $60 = HEAP[HEAP[$res]] - 1;
      
      var $62 = HEAP[$res];
      HEAP[$62] = $60;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $71 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $72 = HEAP[$res];
      FUNCTION_TABLE[$71]($72);
      __label__ = 16;
      break;
     case 16:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      if (HEAP[$n] > HEAP[$len_addr]) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      var $78 = HEAP[_PyExc_IOError];
      var $79 = HEAP[$n];
      var $80 = HEAP[$len_addr];
      var $81 = _PyErr_Format($78, __str38, allocate([ $79, 0, 0, 0, $80, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = -1;
      __label__ = 23;
      break;
     case 19:
      
      
      if (HEAP[$n] > 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      
      
      
      var $87 = HEAP[HEAP[$self_addr] + 32] != -1;
      if ($87) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      
      var $93 = HEAP[HEAP[$self_addr] + 32] + HEAP[$n];
      
      var $95 = HEAP[$self_addr] + 32;
      HEAP[$95] = $93;
      __label__ = 22;
      break;
     case 22:
      var $96 = HEAP[$n];
      HEAP[$0] = $96;
      __label__ = 23;
      break;
     case 23:
      var $97 = HEAP[$0];
      HEAP[$retval] = $97;
      __label__ = 24;
      break;
     case 24:
      var $retval23 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_fill_buffer($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $start = __stackBase__ + 12;
      var $len = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      var $8 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($8) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 60] & 4294967295;
      HEAP[$start] = $12;
      __label__ = 4;
      break;
     case 3:
      HEAP[$start] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      var $17 = HEAP[HEAP[$self_addr] + 84] - HEAP[$start];
      HEAP[$len] = $17;
      
      
      
      
      var $22 = HEAP[HEAP[$self_addr] + 40] + HEAP[$start];
      var $23 = HEAP[$self_addr];
      var $24 = HEAP[$len];
      var $25 = __bufferedreader_raw_read($23, $22, $24);
      HEAP[$n] = $25;
      
      
      if (HEAP[$n] <= 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $28 = HEAP[$n];
      HEAP[$0] = $28;
      __label__ = 7;
      break;
     case 6:
      
      
      
      var $32 = HEAP[$start] + HEAP[$n];
      
      var $34 = HEAP[$self_addr] + 60;
      HEAP[$34] = $32;
      
      
      
      var $38 = HEAP[$start] + HEAP[$n];
      
      var $40 = HEAP[$self_addr] + 52;
      HEAP[$40] = $38;
      var $41 = HEAP[$n];
      HEAP[$0] = $41;
      __label__ = 7;
      break;
     case 7:
      var $42 = HEAP[$0];
      HEAP[$retval] = $42;
      __label__ = 8;
      break;
     case 8:
      var $retval7 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_all($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $iftmp_182 = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $current_size = __stackBase__ + 16;
      var $res = __stackBase__ + 20;
      var $data = __stackBase__ + 24;
      var $chunks = __stackBase__ + 28;
      var $_py_tmp = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$data] = 0;
      var $1 = _PyList_New(0);
      HEAP[$chunks] = $1;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $15 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($15) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      
      
      
      
      var $24 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_182] = $24;
      __label__ = 7;
      break;
     case 6:
      HEAP[$iftmp_182] = 0;
      __label__ = 7;
      break;
     case 7:
      var $25 = HEAP[$iftmp_182];
      HEAP[$current_size] = $25;
      
      
      if (HEAP[$current_size] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      var $35 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      var $36 = HEAP[$current_size];
      var $37 = _PyString_FromStringAndSize($35, $36);
      HEAP[$data] = $37;
      
      
      if (HEAP[$data] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 9:
      
      
      
      var $43 = HEAP[HEAP[$chunks]] - 1;
      
      var $45 = HEAP[$chunks];
      HEAP[$45] = $43;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $55 = HEAP[$chunks];
      FUNCTION_TABLE[$54]($55);
      __label__ = 11;
      break;
     case 11:
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 12:
      var $56 = HEAP[$self_addr];
      __bufferedreader_reset_buf($56);
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 13:
      var $61 = HEAP[$self_addr];
      var $62 = __bufferedwriter_flush_unlocked($61, 1);
      HEAP[$res] = $62;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      var $68 = HEAP[HEAP[$chunks]] - 1;
      
      var $70 = HEAP[$chunks];
      HEAP[$70] = $68;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $79 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $80 = HEAP[$chunks];
      FUNCTION_TABLE[$79]($80);
      __label__ = 16;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 17:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      var $83 = HEAP[$res];
      HEAP[$_py_tmp] = $83;
      HEAP[$res] = 0;
      
      
      
      var $87 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $89 = HEAP[$_py_tmp];
      HEAP[$89] = $87;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $98 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $99 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$98]($99);
      __label__ = 20;
      break;
     case 20:
      
      
      if (HEAP[$data] != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 21:
      var $102 = HEAP[$chunks];
      var $103 = HEAP[$data];
      var $104 = _PyList_Append($102, $103);
      
      if ($104 < 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 22:
      
      
      
      var $109 = HEAP[HEAP[$data]] - 1;
      
      var $111 = HEAP[$data];
      HEAP[$111] = $109;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $120 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $121 = HEAP[$data];
      FUNCTION_TABLE[$120]($121);
      __label__ = 24;
      break;
     case 24:
      
      
      
      var $125 = HEAP[HEAP[$chunks]] - 1;
      
      var $127 = HEAP[$chunks];
      HEAP[$127] = $125;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $136 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $137 = HEAP[$chunks];
      FUNCTION_TABLE[$136]($137);
      __label__ = 26;
      break;
     case 26:
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 27:
      
      
      
      var $141 = HEAP[HEAP[$data]] - 1;
      
      var $143 = HEAP[$data];
      HEAP[$143] = $141;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      
      var $152 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $153 = HEAP[$data];
      FUNCTION_TABLE[$152]($153);
      __label__ = 29;
      break;
     case 29:
      var $154 = HEAP[__PyIO_str_read];
      
      
      var $157 = HEAP[HEAP[$self_addr] + 8];
      var $158 = _PyObject_CallMethodObjArgs($157, $154, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$data] = $158;
      
      
      if (HEAP[$data] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 30:
      
      
      
      var $164 = HEAP[HEAP[$chunks]] - 1;
      
      var $166 = HEAP[$chunks];
      HEAP[$166] = $164;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $175 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $176 = HEAP[$chunks];
      FUNCTION_TABLE[$175]($176);
      __label__ = 32;
      break;
     case 32:
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 33:
      
      
      if (HEAP[$data] != __Py_NoneStruct) {
        __label__ = 34;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 34:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$data] + 4] + 84] & 134217728) == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 35:
      
      
      
      var $189 = HEAP[HEAP[$data]] - 1;
      
      var $191 = HEAP[$data];
      HEAP[$191] = $189;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      
      
      
      
      var $200 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $201 = HEAP[$data];
      FUNCTION_TABLE[$200]($201);
      __label__ = 37;
      break;
     case 37:
      
      
      
      var $205 = HEAP[HEAP[$chunks]] - 1;
      
      var $207 = HEAP[$chunks];
      HEAP[$207] = $205;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $216 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $217 = HEAP[$chunks];
      FUNCTION_TABLE[$216]($217);
      __label__ = 39;
      break;
     case 39:
      var $218 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($218, __str3);
      HEAP[$0] = 0;
      __label__ = 54;
      break;
     case 40:
      
      
      if (HEAP[$data] == __Py_NoneStruct) {
        __label__ = 42;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 41:
      
      
      
      
      
      if (HEAP[HEAP[$data] + 8] == 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 42:
      
      
      if (HEAP[$current_size] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 43:
      
      
      
      var $231 = HEAP[HEAP[$chunks]] - 1;
      
      var $233 = HEAP[$chunks];
      HEAP[$233] = $231;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $242 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $243 = HEAP[$chunks];
      FUNCTION_TABLE[$242]($243);
      __label__ = 45;
      break;
     case 45:
      var $244 = HEAP[$data];
      HEAP[$0] = $244;
      __label__ = 54;
      break;
     case 46:
      var $245 = HEAP[__PyIO_empty_bytes];
      var $246 = HEAP[$chunks];
      var $247 = __PyString_Join($245, $246);
      HEAP[$res] = $247;
      
      
      
      var $251 = HEAP[HEAP[$data]] - 1;
      
      var $253 = HEAP[$data];
      HEAP[$253] = $251;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      
      
      
      
      var $262 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $263 = HEAP[$data];
      FUNCTION_TABLE[$262]($263);
      __label__ = 48;
      break;
     case 48:
      
      
      
      var $267 = HEAP[HEAP[$chunks]] - 1;
      
      var $269 = HEAP[$chunks];
      HEAP[$269] = $267;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      
      
      
      var $278 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $279 = HEAP[$chunks];
      FUNCTION_TABLE[$278]($279);
      __label__ = 50;
      break;
     case 50:
      var $280 = HEAP[$res];
      HEAP[$0] = $280;
      __label__ = 54;
      break;
     case 51:
      
      
      
      
      
      var $286 = HEAP[HEAP[$data] + 8] + HEAP[$current_size];
      HEAP[$current_size] = $286;
      
      
      
      var $290 = HEAP[HEAP[$self_addr] + 32] != -1;
      if ($290) {
        __label__ = 52;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 52:
      
      
      
      
      
      
      
      
      var $299 = HEAP[HEAP[$self_addr] + 32] + HEAP[HEAP[$data] + 8];
      
      var $301 = HEAP[$self_addr] + 32;
      HEAP[$301] = $299;
      __label__ = 53;
      break;
     case 53:
      __label__ = 20;
      break;
     case 54:
      var $302 = HEAP[$0];
      HEAP[$retval] = $302;
      __label__ = 55;
      break;
     case 55:
      var $retval54 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval54;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_fast($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $n_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $iftmp_189 = __stackBase__ + 16;
      var $current_size = __stackBase__ + 20;
      var $res = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$n_addr] = $n;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($12) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      var $21 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_189] = $21;
      __label__ = 5;
      break;
     case 4:
      HEAP[$iftmp_189] = 0;
      __label__ = 5;
      break;
     case 5:
      var $22 = HEAP[$iftmp_189];
      HEAP[$current_size] = $22;
      
      
      
      if (HEAP[$n_addr] <= HEAP[$current_size]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      
      
      
      
      var $33 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      var $34 = HEAP[$n_addr];
      var $35 = _PyString_FromStringAndSize($33, $34);
      HEAP[$res] = $35;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $43 = HEAP[HEAP[$self_addr] + 44] + HEAP[$n_addr];
      
      var $45 = HEAP[$self_addr] + 44;
      HEAP[$45] = $43;
      __label__ = 8;
      break;
     case 8:
      var $46 = HEAP[$res];
      HEAP[$0] = $46;
      __label__ = 10;
      break;
     case 9:
      
      var $48 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $48;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 10;
      break;
     case 10:
      var $49 = HEAP[$0];
      HEAP[$retval] = $49;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_read_generic($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $n_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_195 = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $iftmp_190 = __stackBase__ + 20;
      var $res = __stackBase__ + 24;
      var $current_size = __stackBase__ + 28;
      var $remaining = __stackBase__ + 32;
      var $written = __stackBase__ + 36;
      var $out = __stackBase__ + 40;
      var $r = __stackBase__ + 44;
      var $r31 = __stackBase__ + 48;
      
      HEAP[$self_addr] = $self;
      HEAP[$n_addr] = $n;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($12) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      var $21 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_190] = $21;
      __label__ = 5;
      break;
     case 4:
      HEAP[$iftmp_190] = 0;
      __label__ = 5;
      break;
     case 5:
      var $22 = HEAP[$iftmp_190];
      HEAP[$current_size] = $22;
      
      
      
      if (HEAP[$n_addr] <= HEAP[$current_size]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $26 = HEAP[$self_addr];
      var $27 = HEAP[$n_addr];
      var $28 = __bufferedreader_read_fast($26, $27);
      HEAP[$0] = $28;
      __label__ = 52;
      break;
     case 7:
      var $29 = HEAP[$n_addr];
      var $30 = _PyString_FromStringAndSize(0, $29);
      HEAP[$res] = $30;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      var $36 = HEAP[$res] + 20;
      HEAP[$out] = $36;
      var $37 = HEAP[$n_addr];
      HEAP[$remaining] = $37;
      HEAP[$written] = 0;
      
      
      if (HEAP[$current_size] > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $40 = HEAP[$current_size];
      
      
      
      
      
      
      
      var $48 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      var $49 = HEAP[$out];
      _llvm_memcpy_p0i8_p0i8_i32($49, $48, $40, 1, 0);
      
      
      var $52 = HEAP[$remaining] - HEAP[$current_size];
      HEAP[$remaining] = $52;
      
      
      var $55 = HEAP[$written] + HEAP[$current_size];
      HEAP[$written] = $55;
      __label__ = 10;
      break;
     case 10:
      var $56 = HEAP[$self_addr];
      __bufferedreader_reset_buf($56);
      __label__ = 26;
      break;
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 88] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      var $not = HEAP[HEAP[$self_addr] + 88] ^ -1;
      
      var $65 = $not & HEAP[$remaining];
      HEAP[$iftmp_195] = $65;
      __label__ = 14;
      break;
     case 13:
      
      
      
      
      
      
      
      
      var $74 = HEAP[HEAP[$self_addr] + 84] * (HEAP[$remaining] / HEAP[HEAP[$self_addr] + 84] | 0);
      HEAP[$iftmp_195] = $74;
      __label__ = 14;
      break;
     case 14:
      var $75 = HEAP[$iftmp_195];
      HEAP[$r] = $75;
      
      
      if (HEAP[$r] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      var $80 = HEAP[$out] + HEAP[$written];
      var $81 = HEAP[$self_addr];
      var $82 = HEAP[$r];
      var $83 = __bufferedreader_raw_read($81, $80, $82);
      HEAP[$r] = $83;
      
      var $85 = HEAP[$r] == -1;
      if ($85) {
        __label__ = 48;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      if (HEAP[$r] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      var $89 = HEAP[$r] == -2;
      if ($89) {
        __label__ = 18;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 18:
      
      
      if (HEAP[$r] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      if (HEAP[$written] > 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      var $94 = HEAP[$written];
      var $95 = __PyString_Resize($res, $94);
      
      if ($95 != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      var $97 = HEAP[$res];
      HEAP[$0] = $97;
      __label__ = 52;
      break;
     case 22:
      var $98 = HEAP[$res];
      
      
      var $101 = HEAP[$98] - 1;
      var $102 = $98;
      HEAP[$102] = $101;
      
      
      
      if (HEAP[$98] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $110 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $111 = HEAP[$res];
      FUNCTION_TABLE[$110]($111);
      __label__ = 24;
      break;
     case 24:
      
      var $113 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $113;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 52;
      break;
     case 25:
      
      
      var $116 = HEAP[$remaining] - HEAP[$r];
      HEAP[$remaining] = $116;
      
      
      var $119 = HEAP[$written] + HEAP[$r];
      HEAP[$written] = $119;
      __label__ = 26;
      break;
     case 26:
      
      
      if (HEAP[$remaining] > 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] < HEAP[$remaining]) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      ___assert_fail(__str39, __str10, 1462, ___PRETTY_FUNCTION___10317);
      throw "Reached an unreachable!";
     case 29:
      
      var $128 = HEAP[$self_addr] + 44;
      HEAP[$128] = 0;
      
      var $130 = HEAP[$self_addr] + 52;
      HEAP[$130] = 0;
      
      var $132 = HEAP[$self_addr] + 60;
      HEAP[$132] = 0;
      __label__ = 45;
      break;
     case 30:
      var $133 = HEAP[$self_addr];
      var $134 = __bufferedreader_fill_buffer($133);
      HEAP[$r31] = $134;
      
      var $136 = HEAP[$r31] == -1;
      if ($136) {
        __label__ = 48;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      if (HEAP[$r31] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 32:
      
      var $140 = HEAP[$r31] == -2;
      if ($140) {
        __label__ = 33;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 33:
      
      
      if (HEAP[$r31] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      
      if (HEAP[$written] > 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 35:
      var $145 = HEAP[$written];
      var $146 = __PyString_Resize($res, $145);
      
      if ($146 != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 36:
      var $148 = HEAP[$res];
      HEAP[$0] = $148;
      __label__ = 52;
      break;
     case 37:
      var $149 = HEAP[$res];
      
      
      var $152 = HEAP[$149] - 1;
      var $153 = $149;
      HEAP[$153] = $152;
      
      
      
      if (HEAP[$149] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $161 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $162 = HEAP[$res];
      FUNCTION_TABLE[$161]($162);
      __label__ = 39;
      break;
     case 39:
      
      var $164 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $164;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 52;
      break;
     case 40:
      
      
      
      if (HEAP[$remaining] > HEAP[$r31]) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      var $168 = HEAP[$r31];
      
      
      
      
      
      
      
      var $176 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      
      
      var $179 = HEAP[$out] + HEAP[$written];
      _llvm_memcpy_p0i8_p0i8_i32($179, $176, $168, 1, 0);
      
      
      var $182 = HEAP[$written] + HEAP[$r31];
      HEAP[$written] = $182;
      
      
      
      
      
      var $188 = HEAP[HEAP[$self_addr] + 44] + HEAP[$r31];
      
      var $190 = HEAP[$self_addr] + 44;
      HEAP[$190] = $188;
      
      
      var $193 = HEAP[$remaining] - HEAP[$r31];
      HEAP[$remaining] = $193;
      __label__ = 44;
      break;
     case 42:
      
      
      if (HEAP[$remaining] > 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      var $196 = HEAP[$remaining];
      
      
      
      
      
      
      
      var $204 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      
      
      var $207 = HEAP[$out] + HEAP[$written];
      _llvm_memcpy_p0i8_p0i8_i32($207, $204, $196, 1, 0);
      
      
      var $210 = HEAP[$written] + HEAP[$remaining];
      HEAP[$written] = $210;
      
      
      
      
      
      var $216 = HEAP[HEAP[$self_addr] + 44] + HEAP[$remaining];
      
      var $218 = HEAP[$self_addr] + 44;
      HEAP[$218] = $216;
      HEAP[$remaining] = 0;
      __label__ = 44;
      break;
     case 44:
      
      
      if (HEAP[$remaining] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      if (HEAP[$remaining] <= 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] < HEAP[HEAP[$self_addr] + 84]) {
        __label__ = 30;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      var $231 = HEAP[$res];
      HEAP[$0] = $231;
      __label__ = 52;
      break;
     case 48:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 49:
      var $234 = HEAP[$res];
      
      
      var $237 = HEAP[$234] - 1;
      var $238 = $234;
      HEAP[$238] = $237;
      
      
      
      if (HEAP[$234] == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      
      
      
      var $246 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $247 = HEAP[$res];
      FUNCTION_TABLE[$246]($247);
      __label__ = 51;
      break;
     case 51:
      HEAP[$0] = 0;
      __label__ = 52;
      break;
     case 52:
      var $248 = HEAP[$0];
      HEAP[$retval] = $248;
      __label__ = 53;
      break;
     case 53:
      var $retval53 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval53;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedreader_peek_unlocked($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $n_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $iftmp_208 = __stackBase__ + 16;
      var $have = __stackBase__ + 20;
      var $r = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$n_addr] = $n;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($12) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      var $21 = (HEAP[HEAP[$self_addr] + 60] & 4294967295) - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$iftmp_208] = $21;
      __label__ = 5;
      break;
     case 4:
      HEAP[$iftmp_208] = 0;
      __label__ = 5;
      break;
     case 5:
      var $22 = HEAP[$iftmp_208];
      HEAP[$have] = $22;
      
      
      if (HEAP[$have] > 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      
      
      
      var $32 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      var $33 = HEAP[$have];
      var $34 = _PyString_FromStringAndSize($32, $33);
      HEAP[$0] = $34;
      __label__ = 12;
      break;
     case 7:
      var $35 = HEAP[$self_addr];
      __bufferedreader_reset_buf($35);
      var $36 = HEAP[$self_addr];
      var $37 = __bufferedreader_fill_buffer($36);
      HEAP[$r] = $37;
      
      var $39 = HEAP[$r] == -1;
      if ($39) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 9:
      
      var $41 = HEAP[$r] == -2;
      if ($41) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$r] = 0;
      __label__ = 11;
      break;
     case 11:
      
      var $43 = HEAP[$self_addr] + 44;
      HEAP[$43] = 0;
      
      
      var $46 = HEAP[HEAP[$self_addr] + 40];
      var $47 = HEAP[$r];
      var $48 = _PyString_FromStringAndSize($46, $47);
      HEAP[$0] = $48;
      __label__ = 12;
      break;
     case 12:
      var $49 = HEAP[$0];
      HEAP[$retval] = $49;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _complain_about_max_buffer_size() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval = __stackBase__;
      var $0 = __stackBase__ + 4;
      
      var $1 = HEAP[_PyExc_DeprecationWarning];
      var $2 = _PyErr_WarnEx($1, __str54, 1);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      HEAP[$0] = 1;
      __label__ = 3;
      break;
     case 3:
      var $4 = HEAP[$0];
      HEAP[$retval] = $4;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_reset_buf($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 4;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 4);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      
      HEAP[$self_addr] = $self;
      
      var $1 = HEAP[$self_addr] + 68;
      HEAP[$1] = 0;
      
      var $3 = HEAP[$self_addr] + 76;
      HEAP[$3] = -1;
      __label__ = 1;
      break;
     case 1:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedwriter_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 56;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 56);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_217 = __stackBase__ + 16;
      var $0 = __stackBase__ + 20;
      var $kwlist = __stackBase__ + 24;
      var $buffer_size = __stackBase__ + 40;
      var $max_buffer_size = __stackBase__ + 44;
      var $raw = __stackBase__ + 48;
      var $_py_tmp = __stackBase__ + 52;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_210_10512];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_210_10512 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_210_10512 + 8];
      HEAP[$kwlist + 8] = $6;
      
      var $8 = HEAP[_C_210_10512 + 12];
      HEAP[$kwlist + 12] = $8;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      
      var $10 = HEAP[$self_addr] + 12;
      HEAP[$10] = 0;
      
      var $12 = HEAP[$self_addr] + 16;
      HEAP[$12] = 0;
      var $13 = HEAP[$args_addr];
      var $14 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $15 = __PyArg_ParseTupleAndKeywords_SizeT($13, $14, __str56, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 2:
      
      var $18 = HEAP[$max_buffer_size] != -234;
      if ($18) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $19 = _complain_about_max_buffer_size();
      
      if ($19 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 5:
      var $21 = HEAP[$raw];
      var $22 = __PyIOBase_check_writable($21, __Py_TrueStruct);
      
      if ($22 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      var $30 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $30;
      
      var $32 = HEAP[$self_addr] + 8;
      HEAP[$32] = 0;
      
      
      
      var $36 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $38 = HEAP[$_py_tmp];
      HEAP[$38] = $36;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $48 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$47]($48);
      __label__ = 10;
      break;
     case 10:
      
      
      
      var $52 = HEAP[HEAP[$raw]] + 1;
      var $53 = HEAP[$raw];
      HEAP[$53] = $52;
      var $54 = HEAP[$raw];
      
      var $56 = HEAP[$self_addr] + 8;
      HEAP[$56] = $54;
      
      var $58 = HEAP[$self_addr] + 20;
      HEAP[$58] = 0;
      
      var $60 = HEAP[$self_addr] + 24;
      HEAP[$60] = 1;
      var $61 = HEAP[$buffer_size];
      
      var $63 = HEAP[$self_addr] + 84;
      HEAP[$63] = $61;
      var $64 = HEAP[$self_addr];
      var $65 = __buffered_init($64);
      
      if ($65 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 12:
      var $67 = HEAP[$self_addr];
      __bufferedwriter_reset_buf($67);
      
      var $69 = HEAP[$self_addr] + 44;
      HEAP[$69] = 0;
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] != _PyBufferedWriter_Type) {
        __label__ = 15;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 15;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      HEAP[$iftmp_217] = 1;
      __label__ = 16;
      break;
     case 15:
      HEAP[$iftmp_217] = 0;
      __label__ = 16;
      break;
     case 16:
      
      var $80 = HEAP[$self_addr] + 28;
      var $81 = HEAP[$iftmp_217];
      HEAP[$80] = $81;
      
      var $83 = HEAP[$self_addr] + 12;
      HEAP[$83] = 1;
      HEAP[$0] = 0;
      __label__ = 17;
      break;
     case 17:
      var $84 = HEAP[$0];
      HEAP[$retval] = $84;
      __label__ = 18;
      break;
     case 18:
      var $retval18 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_raw_write($self, $start, $len) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 84;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 84);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $start_addr = __stackBase__ + 4;
      var $len_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $buf = __stackBase__ + 20;
      var $memobj = __stackBase__ + 72;
      var $res = __stackBase__ + 76;
      var $n = __stackBase__ + 80;
      
      HEAP[$self_addr] = $self;
      HEAP[$start_addr] = $start;
      HEAP[$len_addr] = $len;
      var $1 = HEAP[$start_addr];
      var $2 = HEAP[$len_addr];
      var $3 = _PyBuffer_FillInfo($buf, 0, $1, $2, 1, 8);
      var $4 = $3 == -1;
      if ($4) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 2:
      var $5 = _PyMemoryView_FromBuffer($buf);
      HEAP[$memobj] = $5;
      
      
      if (HEAP[$memobj] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 4:
      var $8 = HEAP[__PyIO_str_write];
      
      
      var $11 = HEAP[HEAP[$self_addr] + 8];
      var $12 = HEAP[$memobj];
      var $13 = _PyObject_CallMethodObjArgs($11, $8, allocate([ $12, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $13;
      
      
      if (HEAP[$res] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $16 = __trap_eintr();
      
      if ($16 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $21 = HEAP[HEAP[$memobj]] - 1;
      
      var $23 = HEAP[$memobj];
      HEAP[$23] = $21;
      
      
      
      
      if (HEAP[HEAP[$memobj]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $32 = HEAP[HEAP[HEAP[$memobj] + 4] + 24];
      var $33 = HEAP[$memobj];
      FUNCTION_TABLE[$32]($33);
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 10:
      var $36 = HEAP[_PyExc_ValueError];
      var $37 = HEAP[$res];
      var $38 = _PyNumber_AsSsize_t($37, $36);
      HEAP[$n] = $38;
      
      
      
      var $42 = HEAP[HEAP[$res]] - 1;
      
      var $44 = HEAP[$res];
      HEAP[$44] = $42;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $53 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $54 = HEAP[$res];
      FUNCTION_TABLE[$53]($54);
      __label__ = 12;
      break;
     case 12:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      if (HEAP[$n] > HEAP[$len_addr]) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $60 = HEAP[_PyExc_IOError];
      var $61 = HEAP[$n];
      var $62 = HEAP[$len_addr];
      var $63 = _PyErr_Format($60, __str57, allocate([ $61, 0, 0, 0, $62, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = -1;
      __label__ = 19;
      break;
     case 15:
      
      
      if (HEAP[$n] > 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      
      var $69 = HEAP[HEAP[$self_addr] + 32] != -1;
      if ($69) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      
      var $75 = HEAP[HEAP[$self_addr] + 32] + HEAP[$n];
      
      var $77 = HEAP[$self_addr] + 32;
      HEAP[$77] = $75;
      __label__ = 18;
      break;
     case 18:
      var $78 = HEAP[$n];
      HEAP[$0] = $78;
      __label__ = 19;
      break;
     case 19:
      var $79 = HEAP[$0];
      HEAP[$retval] = $79;
      __label__ = 20;
      break;
     case 20:
      var $retval19 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __bufferedwriter_flush_unlocked($self, $restore_pos) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 56;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 56);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $restore_pos_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $iftmp_223 = __stackBase__ + 16;
      var $written = __stackBase__ + 24;
      var $n = __stackBase__ + 28;
      var $rewind = __stackBase__ + 36;
      var $w = __stackBase__ + 44;
      var $forward = __stackBase__ + 48;
      
      HEAP[$self_addr] = $self;
      HEAP[$restore_pos_addr] = $restore_pos;
      HEAP[$written] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      var $8 = HEAP[HEAP[$self_addr] + 76] == -1;
      if ($8) {
        __label__ = 24;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] == HEAP[HEAP[$self_addr] + 76]) {
        __label__ = 24;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $23 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($23) {
        __label__ = 7;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      var $31 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($31) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      
      
      
      var $42 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_223] = $42;
      __label__ = 10;
      break;
     case 9:
      HEAP[$iftmp_223] = 0;
      __label__ = 10;
      break;
     case 10:
      
      
      
      
      
      
      
      
      var $51 = HEAP[$iftmp_223] + (HEAP[HEAP[$self_addr] + 44] - HEAP[HEAP[$self_addr] + 68]);
      HEAP[$rewind] = $51;
      
      
      if (HEAP[$rewind] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      var $55 = 0 - HEAP[$rewind];
      var $56 = HEAP[$self_addr];
      var $57 = __buffered_raw_seek($56, $55, 1);
      HEAP[$n] = $57;
      
      
      if (HEAP[$n] < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      
      
      
      
      var $64 = HEAP[HEAP[$self_addr] + 52] - HEAP[$rewind];
      
      var $66 = HEAP[$self_addr] + 52;
      HEAP[$66] = $64;
      __label__ = 13;
      break;
     case 13:
      __label__ = 18;
      break;
     case 14:
      
      
      
      
      
      
      
      
      var $75 = (HEAP[HEAP[$self_addr] + 76] & 4294967295) - (HEAP[HEAP[$self_addr] + 68] & 4294967295);
      
      
      
      
      
      
      
      var $83 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 68] & 4294967295);
      var $84 = HEAP[$self_addr];
      var $85 = __bufferedwriter_raw_write($84, $83, $75);
      var $86 = $85;
      HEAP[$n] = $86;
      
      var $88 = HEAP[$n] == -1;
      if ($88) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      var $89 = __buffered_check_blocking_error();
      HEAP[$w] = $89;
      
      
      if (HEAP[$w] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      
      
      
      var $98 = HEAP[HEAP[$self_addr] + 68] + HEAP[HEAP[$w]];
      
      var $100 = HEAP[$self_addr] + 68;
      HEAP[$100] = $98;
      
      
      var $103 = HEAP[HEAP[$self_addr] + 68];
      
      var $105 = HEAP[$self_addr] + 52;
      HEAP[$105] = $103;
      
      
      
      var $109 = HEAP[HEAP[$w]] + HEAP[$written];
      HEAP[$written] = $109;
      var $110 = HEAP[$w];
      var $111 = HEAP[$written];
      HEAP[$110] = $111;
      __label__ = 25;
      break;
     case 17:
      
      
      
      
      var $116 = HEAP[HEAP[$self_addr] + 68] + HEAP[$n];
      
      var $118 = HEAP[$self_addr] + 68;
      HEAP[$118] = $116;
      
      
      var $121 = HEAP[HEAP[$self_addr] + 68];
      
      var $123 = HEAP[$self_addr] + 52;
      HEAP[$123] = $121;
      
      
      
      var $127 = (HEAP[$n] & 4294967295) + HEAP[$written];
      HEAP[$written] = $127;
      var $128 = _PyErr_CheckSignals();
      
      if ($128 < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] < HEAP[HEAP[$self_addr] + 76]) {
        __label__ = 14;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      if (HEAP[$restore_pos_addr] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 20:
      
      
      
      var $142 = HEAP[$rewind] - HEAP[$written];
      HEAP[$forward] = $142;
      
      
      if (HEAP[$forward] != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 21:
      var $145 = HEAP[$self_addr];
      var $146 = HEAP[$forward];
      var $147 = __buffered_raw_seek($145, $146, 1);
      HEAP[$n] = $147;
      
      
      if (HEAP[$n] < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      
      
      
      var $154 = HEAP[HEAP[$self_addr] + 52] + HEAP[$forward];
      
      var $156 = HEAP[$self_addr] + 52;
      HEAP[$156] = $154;
      __label__ = 23;
      break;
     case 23:
      var $157 = HEAP[$self_addr];
      __bufferedwriter_reset_buf($157);
      __label__ = 24;
      break;
     case 24:
      
      var $159 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $159;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 26;
      break;
     case 25:
      HEAP[$0] = 0;
      __label__ = 26;
      break;
     case 26:
      var $160 = HEAP[$0];
      HEAP[$retval] = $160;
      __label__ = 27;
      break;
     case 27:
      var $retval24 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval24;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedwriter_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 117;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 117);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_229 = __stackBase__ + 12;
      var $iftmp_226 = __stackBase__ + 20;
      var $0 = __stackBase__ + 21;
      var $res = __stackBase__ + 25;
      var $buf = __stackBase__ + 29;
      var $written = __stackBase__ + 81;
      var $avail = __stackBase__ + 85;
      var $remaining = __stackBase__ + 89;
      var $offset = __stackBase__ + 93;
      var $w = __stackBase__ + 101;
      var $_py_tmp = __stackBase__ + 105;
      var $n = __stackBase__ + 109;
      var $w54 = __stackBase__ + 113;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$res] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str11);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str12);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 75;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str58, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 75;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      var $20 = HEAP[HEAP[$self_addr] + 8];
      var $21 = __PyFileIO_closed($20);
      
      var $23 = $21 != 0;
      HEAP[$iftmp_226] = $23;
      __label__ = 10;
      break;
     case 9:
      var $24 = HEAP[$self_addr];
      var $25 = _buffered_closed($24);
      
      var $27 = $25 != 0;
      HEAP[$iftmp_226] = $27;
      __label__ = 10;
      break;
     case 10:
      
      
      if (HEAP[$iftmp_226] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $29 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($29, __str59);
      _PyBuffer_Release($buf);
      HEAP[$0] = 0;
      __label__ = 75;
      break;
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      var $37 = HEAP[HEAP[$self_addr] + 60] == -1;
      if ($37) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      var $45 = HEAP[HEAP[$self_addr] + 76] == -1;
      if ($45) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      var $47 = HEAP[$self_addr] + 44;
      HEAP[$47] = 0;
      
      var $49 = HEAP[$self_addr] + 52;
      HEAP[$49] = 0;
      __label__ = 17;
      break;
     case 17:
      
      
      
      
      
      
      
      var $57 = HEAP[HEAP[$self_addr] + 84] - (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      HEAP[$avail] = $57;
      
      
      
      
      if (HEAP[$buf + 8] <= HEAP[$avail]) {
        __label__ = 18;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 18:
      
      var $63 = HEAP[$buf + 8];
      
      var $65 = HEAP[$buf];
      
      
      
      
      
      
      
      var $73 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 44] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($73, $65, $63, 1, 0);
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      var $81 = HEAP[HEAP[$self_addr] + 76] == -1;
      if ($81) {
        __label__ = 21;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 20:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] > HEAP[HEAP[$self_addr] + 44]) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      var $91 = HEAP[HEAP[$self_addr] + 44];
      
      var $93 = HEAP[$self_addr] + 68;
      HEAP[$93] = $91;
      __label__ = 22;
      break;
     case 22:
      
      
      
      
      
      
      var $100 = HEAP[HEAP[$self_addr] + 44] + HEAP[$buf + 8];
      
      var $102 = HEAP[$self_addr] + 44;
      HEAP[$102] = $100;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 23:
      
      
      
      var $110 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($110) {
        __label__ = 24;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 24:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] < HEAP[HEAP[$self_addr] + 44]) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      var $120 = HEAP[HEAP[$self_addr] + 44];
      
      var $122 = HEAP[$self_addr] + 60;
      HEAP[$122] = $120;
      __label__ = 26;
      break;
     case 26:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 44] > HEAP[HEAP[$self_addr] + 76]) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      var $132 = HEAP[HEAP[$self_addr] + 44];
      
      var $134 = HEAP[$self_addr] + 76;
      HEAP[$134] = $132;
      __label__ = 28;
      break;
     case 28:
      
      var $136 = HEAP[$buf + 8];
      HEAP[$written] = $136;
      __label__ = 73;
      break;
     case 29:
      var $137 = HEAP[$self_addr];
      var $138 = __bufferedwriter_flush_unlocked($137, 0);
      HEAP[$res] = $138;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 30:
      var $141 = __buffered_check_blocking_error();
      HEAP[$w] = $141;
      
      
      if (HEAP[$w] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      var $148 = HEAP[$self_addr];
      __bufferedreader_reset_buf($148);
      __label__ = 33;
      break;
     case 33:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 34:
      
      
      
      var $156 = HEAP[HEAP[$self_addr] + 76] == -1;
      if ($156) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      ___assert_fail(__str60, __str10, 1832, ___PRETTY_FUNCTION___10710);
      throw "Reached an unreachable!";
     case 36:
      
      
      
      
      
      
      
      
      var $165 = (HEAP[HEAP[$self_addr] + 76] & 4294967295) - (HEAP[HEAP[$self_addr] + 68] & 4294967295);
      
      
      
      
      
      
      
      var $173 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 68] & 4294967295);
      
      
      var $176 = HEAP[HEAP[$self_addr] + 40];
      _llvm_memmove_p0i8_p0i8_i32($176, $173, $165, 1, 0);
      
      
      
      
      
      
      var $183 = HEAP[HEAP[$self_addr] + 76] - HEAP[HEAP[$self_addr] + 68];
      
      var $185 = HEAP[$self_addr] + 76;
      HEAP[$185] = $183;
      
      
      
      
      
      
      var $192 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 68];
      
      var $194 = HEAP[$self_addr] + 52;
      HEAP[$194] = $192;
      
      
      
      
      
      
      var $201 = HEAP[HEAP[$self_addr] + 44] - HEAP[HEAP[$self_addr] + 68];
      
      var $203 = HEAP[$self_addr] + 44;
      HEAP[$203] = $201;
      
      var $205 = HEAP[$self_addr] + 68;
      HEAP[$205] = 0;
      
      
      
      
      
      
      
      var $213 = HEAP[HEAP[$self_addr] + 84] - (HEAP[HEAP[$self_addr] + 76] & 4294967295);
      HEAP[$avail] = $213;
      
      
      
      
      if (HEAP[$buf + 8] <= HEAP[$avail]) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      _PyErr_Clear();
      
      var $219 = HEAP[$buf + 8];
      
      var $221 = HEAP[$buf];
      
      
      
      
      
      
      
      var $229 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 76] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($229, $221, $219, 1, 0);
      
      
      
      
      
      
      var $236 = HEAP[HEAP[$self_addr] + 76] + HEAP[$buf + 8];
      
      var $238 = HEAP[$self_addr] + 76;
      HEAP[$238] = $236;
      
      var $240 = HEAP[$buf + 8];
      HEAP[$written] = $240;
      __label__ = 73;
      break;
     case 38:
      var $241 = HEAP[$avail];
      
      var $243 = HEAP[$buf];
      
      
      
      
      
      
      
      var $251 = HEAP[HEAP[$self_addr] + 40] + (HEAP[HEAP[$self_addr] + 76] & 4294967295);
      _llvm_memcpy_p0i8_p0i8_i32($251, $243, $241, 1, 0);
      
      
      
      
      
      var $257 = HEAP[HEAP[$self_addr] + 76] + HEAP[$avail];
      
      var $259 = HEAP[$self_addr] + 76;
      HEAP[$259] = $257;
      var $260 = HEAP[$w];
      var $261 = HEAP[$avail];
      HEAP[$260] = $261;
      __label__ = 74;
      break;
     case 39:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      var $264 = HEAP[$res];
      HEAP[$_py_tmp] = $264;
      HEAP[$res] = 0;
      
      
      
      var $268 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $270 = HEAP[$_py_tmp];
      HEAP[$270] = $268;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $279 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $280 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$279]($280);
      __label__ = 42;
      break;
     case 42:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      var $288 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($288) {
        __label__ = 46;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      
      var $296 = HEAP[HEAP[$self_addr] + 76] != -1;
      if ($296) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] < 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      
      
      
      
      var $307 = HEAP[HEAP[$self_addr] + 52] - HEAP[HEAP[$self_addr] + 44];
      HEAP[$iftmp_229] = $307;
      __label__ = 49;
      break;
     case 48:
      HEAP[$iftmp_229] = 0;
      __label__ = 49;
      break;
     case 49:
      var $308 = HEAP[$iftmp_229];
      HEAP[$offset] = $308;
      
      
      if (HEAP[$offset] != 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 50:
      
      var $312 = 0 - HEAP[$offset];
      var $313 = HEAP[$self_addr];
      var $314 = __buffered_raw_seek($313, $312, 1);
      
      if ($314 < 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 51:
      
      
      
      
      var $320 = HEAP[HEAP[$self_addr] + 52] - HEAP[$offset];
      
      var $322 = HEAP[$self_addr] + 52;
      HEAP[$322] = $320;
      __label__ = 52;
      break;
     case 52:
      
      var $324 = HEAP[$buf + 8];
      HEAP[$remaining] = $324;
      HEAP[$written] = 0;
      __label__ = 63;
      break;
     case 53:
      
      
      
      var $328 = HEAP[$buf + 8] - HEAP[$written];
      
      
      
      var $332 = HEAP[$buf] + HEAP[$written];
      var $333 = HEAP[$self_addr];
      var $334 = __bufferedwriter_raw_write($333, $332, $328);
      HEAP[$n] = $334;
      
      var $336 = HEAP[$n] == -1;
      if ($336) {
        __label__ = 54;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 54:
      var $337 = __buffered_check_blocking_error();
      HEAP[$w54] = $337;
      
      
      if (HEAP[$w54] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 55:
      
      
      
      var $343 = HEAP[HEAP[$w54]] + HEAP[$written];
      HEAP[$written] = $343;
      
      
      
      var $347 = HEAP[$remaining] - HEAP[HEAP[$w54]];
      HEAP[$remaining] = $347;
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] < HEAP[$remaining]) {
        __label__ = 56;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 56:
      
      
      var $355 = HEAP[HEAP[$self_addr] + 84];
      
      
      
      var $359 = HEAP[$buf] + HEAP[$written];
      
      
      var $362 = HEAP[HEAP[$self_addr] + 40];
      _llvm_memcpy_p0i8_p0i8_i32($362, $359, $355, 1, 0);
      
      var $364 = HEAP[$self_addr] + 52;
      HEAP[$364] = 0;
      
      
      
      var $368 = HEAP[HEAP[$self_addr] + 84];
      
      var $370 = HEAP[$self_addr] + 44;
      HEAP[$370] = $368;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 57:
      
      
      
      var $378 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($378) {
        __label__ = 58;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 58:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] < HEAP[HEAP[$self_addr] + 44]) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      
      
      var $388 = HEAP[HEAP[$self_addr] + 44];
      
      var $390 = HEAP[$self_addr] + 60;
      HEAP[$390] = $388;
      __label__ = 60;
      break;
     case 60:
      
      
      
      var $394 = HEAP[HEAP[$self_addr] + 84];
      
      var $396 = HEAP[$self_addr] + 76;
      HEAP[$396] = $394;
      
      
      
      
      var $401 = HEAP[HEAP[$self_addr] + 84] + HEAP[$written];
      var $402 = HEAP[$w54];
      HEAP[$402] = $401;
      __label__ = 74;
      break;
     case 61:
      _PyErr_Clear();
      __label__ = 64;
      break;
     case 62:
      
      
      var $405 = HEAP[$written] + HEAP[$n];
      HEAP[$written] = $405;
      
      
      var $408 = HEAP[$remaining] - HEAP[$n];
      HEAP[$remaining] = $408;
      var $409 = _PyErr_CheckSignals();
      
      if ($409 < 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] < HEAP[$remaining]) {
        __label__ = 53;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      var $420 = HEAP[$self_addr];
      __bufferedreader_reset_buf($420);
      __label__ = 66;
      break;
     case 66:
      
      
      if (HEAP[$remaining] > 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      var $423 = HEAP[$remaining];
      
      
      
      var $427 = HEAP[$buf] + HEAP[$written];
      
      
      var $430 = HEAP[HEAP[$self_addr] + 40];
      _llvm_memcpy_p0i8_p0i8_i32($430, $427, $423, 1, 0);
      
      
      var $433 = HEAP[$written] + HEAP[$remaining];
      HEAP[$written] = $433;
      __label__ = 68;
      break;
     case 68:
      
      var $435 = HEAP[$self_addr] + 68;
      HEAP[$435] = 0;
      
      var $437 = HEAP[$remaining];
      
      var $439 = HEAP[$self_addr] + 76;
      HEAP[$439] = $437;
      
      var $441 = HEAP[$remaining];
      
      var $443 = HEAP[$self_addr] + 44;
      HEAP[$443] = $441;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 69:
      
      
      
      var $451 = HEAP[HEAP[$self_addr] + 60] != -1;
      if ($451) {
        __label__ = 70;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 70:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] < HEAP[HEAP[$self_addr] + 44]) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      
      
      var $461 = HEAP[HEAP[$self_addr] + 44];
      
      var $463 = HEAP[$self_addr] + 60;
      HEAP[$463] = $461;
      __label__ = 72;
      break;
     case 72:
      
      var $465 = HEAP[$self_addr] + 52;
      HEAP[$465] = 0;
      __label__ = 73;
      break;
     case 73:
      var $466 = HEAP[$written];
      var $467 = _PyLong_FromSsize_t($466);
      HEAP[$res] = $467;
      __label__ = 74;
      break;
     case 74:
      _PyBuffer_Release($buf);
      var $468 = HEAP[$res];
      HEAP[$0] = $468;
      __label__ = 75;
      break;
     case 75:
      var $469 = HEAP[$0];
      HEAP[$retval] = $469;
      __label__ = 76;
      break;
     case 76:
      var $retval74 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval74;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $reader = __stackBase__ + 20;
      var $writer = __stackBase__ + 24;
      var $buffer_size = __stackBase__ + 28;
      var $max_buffer_size = __stackBase__ + 32;
      var $_py_tmp = __stackBase__ + 36;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str62, allocate([ $reader, 0, 0, 0, $writer, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 2:
      
      var $5 = HEAP[$max_buffer_size] != -234;
      if ($5) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $6 = _complain_about_max_buffer_size();
      
      if ($6 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 5:
      var $8 = HEAP[$reader];
      var $9 = __PyIOBase_check_readable($8, __Py_TrueStruct);
      
      if ($9 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 7:
      var $11 = HEAP[$writer];
      var $12 = __PyIOBase_check_writable($11, __Py_TrueStruct);
      
      if ($12 == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 9:
      var $14 = HEAP[$buffer_size];
      var $15 = HEAP[$reader];
      var $16 = __PyObject_CallFunction_SizeT(_PyBufferedReader_Type, __str63, allocate([ $15, 0, 0, 0, $14, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      var $17 = $16;
      
      var $19 = HEAP[$self_addr] + 8;
      HEAP[$19] = $17;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 11:
      var $24 = HEAP[$buffer_size];
      var $25 = HEAP[$writer];
      var $26 = __PyObject_CallFunction_SizeT(_PyBufferedWriter_Type, __str63, allocate([ $25, 0, 0, 0, $24, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      var $27 = $26;
      
      var $29 = HEAP[$self_addr] + 12;
      HEAP[$29] = $27;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      var $41 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $41;
      
      var $43 = HEAP[$self_addr] + 8;
      HEAP[$43] = 0;
      
      
      
      var $47 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $49 = HEAP[$_py_tmp];
      HEAP[$49] = $47;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $58 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $59 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$58]($59);
      __label__ = 15;
      break;
     case 15:
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 17;
      break;
     case 17:
      var $60 = HEAP[$0];
      HEAP[$retval] = $60;
      __label__ = 18;
      break;
     case 18:
      var $retval17 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 16];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 4;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 4:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      var $_py_tmp4 = __stackBase__ + 16;
      var $_py_tmp8 = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      
      var $8 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $8;
      
      var $10 = HEAP[$self_addr] + 8;
      HEAP[$10] = 0;
      
      
      
      var $14 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $16 = HEAP[$_py_tmp];
      HEAP[$16] = $14;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $26 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$25]($26);
      __label__ = 3;
      break;
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      
      var $34 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$_py_tmp4] = $34;
      
      var $36 = HEAP[$self_addr] + 12;
      HEAP[$36] = 0;
      
      
      
      var $40 = HEAP[HEAP[$_py_tmp4]] - 1;
      
      var $42 = HEAP[$_py_tmp4];
      HEAP[$42] = $40;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp4]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $51 = HEAP[HEAP[HEAP[$_py_tmp4] + 4] + 24];
      var $52 = HEAP[$_py_tmp4];
      FUNCTION_TABLE[$51]($52);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $59 = HEAP[HEAP[$self_addr] + 16];
      HEAP[$_py_tmp8] = $59;
      
      var $61 = HEAP[$self_addr] + 16;
      HEAP[$61] = 0;
      
      
      
      var $65 = HEAP[HEAP[$_py_tmp8]] - 1;
      
      var $67 = HEAP[$_py_tmp8];
      HEAP[$67] = $65;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp8]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $76 = HEAP[HEAP[HEAP[$_py_tmp8] + 4] + 24];
      var $77 = HEAP[$_py_tmp8];
      FUNCTION_TABLE[$76]($77);
      __label__ = 9;
      break;
     case 9:
      HEAP[$0] = 0;
      var $78 = HEAP[$0];
      HEAP[$retval] = $78;
      __label__ = 10;
      break;
     case 10:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      var $_py_tmp6 = __stackBase__ + 12;
      var $_py_tmp10 = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      var $2 = HEAP[$self_addr] + -12;
      HEAP[$g] = $2;
      
      
      
      
      var $7 = HEAP[HEAP[$g] + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str9, __str10, 2084, ___PRETTY_FUNCTION___11077);
      throw "Reached an unreachable!";
     case 2:
      
      
      var $10 = HEAP[$g] + 8;
      HEAP[$10] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[HEAP[$g]];
      
      var $20 = HEAP[HEAP[$g] + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[HEAP[$g] + 4];
      
      var $30 = HEAP[HEAP[$g]] + 4;
      HEAP[$30] = $28;
      
      
      var $33 = HEAP[$g];
      HEAP[$33] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      var $41 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $41;
      
      var $43 = HEAP[$self_addr] + 8;
      HEAP[$43] = 0;
      
      
      
      var $47 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $49 = HEAP[$_py_tmp];
      HEAP[$49] = $47;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $58 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $59 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$58]($59);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      var $67 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$_py_tmp6] = $67;
      
      var $69 = HEAP[$self_addr] + 12;
      HEAP[$69] = 0;
      
      
      
      var $73 = HEAP[HEAP[$_py_tmp6]] - 1;
      
      var $75 = HEAP[$_py_tmp6];
      HEAP[$75] = $73;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp6]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $84 = HEAP[HEAP[HEAP[$_py_tmp6] + 4] + 24];
      var $85 = HEAP[$_py_tmp6];
      FUNCTION_TABLE[$84]($85);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      var $92 = HEAP[HEAP[$self_addr] + 16];
      HEAP[$_py_tmp10] = $92;
      
      var $94 = HEAP[$self_addr] + 16;
      HEAP[$94] = 0;
      
      
      
      var $98 = HEAP[HEAP[$_py_tmp10]] - 1;
      
      var $100 = HEAP[$_py_tmp10];
      HEAP[$100] = $98;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp10]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $109 = HEAP[HEAP[HEAP[$_py_tmp10] + 4] + 24];
      var $110 = HEAP[$_py_tmp10];
      FUNCTION_TABLE[$109]($110);
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      
      var $116 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $118 = HEAP[$self_addr];
      FUNCTION_TABLE[$116]($118);
      __label__ = 12;
      break;
     case 12:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __forward_call($self, $name, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $name_addr = __stackBase__ + 4;
      var $args_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $func = __stackBase__ + 20;
      var $ret = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$name_addr] = $name;
      HEAP[$args_addr] = $args;
      
      var $2 = HEAP[$self_addr];
      var $3 = HEAP[$name_addr];
      var $4 = _PyObject_GetAttrString($2, $3);
      HEAP[$func] = $4;
      
      
      if (HEAP[$func] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $7 = HEAP[_PyExc_AttributeError];
      var $8 = HEAP[$name_addr];
      _PyErr_SetString($7, $8);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      var $9 = HEAP[$func];
      var $10 = HEAP[$args_addr];
      var $11 = _PyObject_CallObject($9, $10);
      HEAP[$ret] = $11;
      
      
      
      var $15 = HEAP[HEAP[$func]] - 1;
      
      var $17 = HEAP[$func];
      HEAP[$17] = $15;
      
      
      
      
      if (HEAP[HEAP[$func]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $26 = HEAP[HEAP[HEAP[$func] + 4] + 24];
      var $27 = HEAP[$func];
      FUNCTION_TABLE[$26]($27);
      __label__ = 4;
      break;
     case 4:
      var $28 = HEAP[$ret];
      HEAP[$0] = $28;
      __label__ = 5;
      break;
     case 5:
      var $29 = HEAP[$0];
      HEAP[$retval] = $29;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str1, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_peek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str47, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_read1($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str5, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str7, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 12];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str6, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_flush($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 12];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str40, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str43, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 12];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str44, $4);
      HEAP[$0] = $5;
      var $6 = HEAP[$0];
      HEAP[$retval] = $6;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_close($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $ret = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 12];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str41, $4);
      HEAP[$ret] = $5;
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      var $11 = HEAP[HEAP[$ret]] - 1;
      
      var $13 = HEAP[$ret];
      HEAP[$13] = $11;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $23 = HEAP[$ret];
      FUNCTION_TABLE[$22]($23);
      __label__ = 4;
      break;
     case 4:
      
      
      var $26 = HEAP[HEAP[$self_addr] + 8];
      var $27 = HEAP[$args_addr];
      var $28 = __forward_call($26, __str41, $27);
      HEAP[$0] = $28;
      __label__ = 5;
      break;
     case 5:
      var $29 = HEAP[$0];
      HEAP[$retval] = $29;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_isatty($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $ret = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 12];
      var $4 = HEAP[$args_addr];
      var $5 = __forward_call($3, __str46, $4);
      HEAP[$ret] = $5;
      
      
      if (HEAP[$ret] != __Py_ZeroStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $8 = HEAP[$ret];
      HEAP[$0] = $8;
      __label__ = 5;
      break;
     case 2:
      
      
      
      var $12 = HEAP[HEAP[$ret]] - 1;
      
      var $14 = HEAP[$ret];
      HEAP[$14] = $12;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $24 = HEAP[$ret];
      FUNCTION_TABLE[$23]($24);
      __label__ = 4;
      break;
     case 4:
      
      
      var $27 = HEAP[HEAP[$self_addr] + 8];
      var $28 = HEAP[$args_addr];
      var $29 = __forward_call($27, __str46, $28);
      HEAP[$0] = $29;
      __label__ = 5;
      break;
     case 5:
      var $30 = HEAP[$0];
      HEAP[$retval] = $30;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrwpair_closed_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      var $1 = HEAP[__PyIO_str_closed];
      
      
      
      var $5 = HEAP[HEAP[$self_addr] + 12];
      var $6 = _PyObject_GetAttr($5, $1);
      HEAP[$0] = $6;
      var $7 = HEAP[$0];
      HEAP[$retval] = $7;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bufferedrandom_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 56;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 56);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_259 = __stackBase__ + 16;
      var $0 = __stackBase__ + 20;
      var $kwlist = __stackBase__ + 24;
      var $buffer_size = __stackBase__ + 40;
      var $max_buffer_size = __stackBase__ + 44;
      var $raw = __stackBase__ + 48;
      var $_py_tmp = __stackBase__ + 52;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_248_11275];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_248_11275 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_248_11275 + 8];
      HEAP[$kwlist + 8] = $6;
      
      var $8 = HEAP[_C_248_11275 + 12];
      HEAP[$kwlist + 12] = $8;
      HEAP[$buffer_size] = 8192;
      HEAP[$max_buffer_size] = -234;
      
      var $10 = HEAP[$self_addr] + 12;
      HEAP[$10] = 0;
      
      var $12 = HEAP[$self_addr] + 16;
      HEAP[$12] = 0;
      var $13 = HEAP[$args_addr];
      var $14 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $15 = __PyArg_ParseTupleAndKeywords_SizeT($13, $14, __str56, $kwlist1, allocate([ $raw, 0, 0, 0, $buffer_size, 0, 0, 0, $max_buffer_size, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 2:
      
      var $18 = HEAP[$max_buffer_size] != -234;
      if ($18) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      var $19 = _complain_about_max_buffer_size();
      
      if ($19 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 5:
      var $21 = HEAP[$raw];
      var $22 = __PyIOBase_check_seekable($21, __Py_TrueStruct);
      
      if ($22 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 7:
      var $24 = HEAP[$raw];
      var $25 = __PyIOBase_check_readable($24, __Py_TrueStruct);
      
      if ($25 == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 9:
      var $27 = HEAP[$raw];
      var $28 = __PyIOBase_check_writable($27, __Py_TrueStruct);
      
      if ($28 == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 11:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 12:
      
      
      var $36 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $36;
      
      var $38 = HEAP[$self_addr] + 8;
      HEAP[$38] = 0;
      
      
      
      var $42 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $44 = HEAP[$_py_tmp];
      HEAP[$44] = $42;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $53 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $54 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$53]($54);
      __label__ = 14;
      break;
     case 14:
      
      
      
      var $58 = HEAP[HEAP[$raw]] + 1;
      var $59 = HEAP[$raw];
      HEAP[$59] = $58;
      var $60 = HEAP[$raw];
      
      var $62 = HEAP[$self_addr] + 8;
      HEAP[$62] = $60;
      var $63 = HEAP[$buffer_size];
      
      var $65 = HEAP[$self_addr] + 84;
      HEAP[$65] = $63;
      
      var $67 = HEAP[$self_addr] + 20;
      HEAP[$67] = 1;
      
      var $69 = HEAP[$self_addr] + 24;
      HEAP[$69] = 1;
      var $70 = HEAP[$self_addr];
      var $71 = __buffered_init($70);
      
      if ($71 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = -1;
      __label__ = 21;
      break;
     case 16:
      var $73 = HEAP[$self_addr];
      __bufferedreader_reset_buf($73);
      var $74 = HEAP[$self_addr];
      __bufferedwriter_reset_buf($74);
      
      var $76 = HEAP[$self_addr] + 44;
      HEAP[$76] = 0;
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] != _PyBufferedRandom_Type) {
        __label__ = 19;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] != _PyFileIO_Type) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      HEAP[$iftmp_259] = 1;
      __label__ = 20;
      break;
     case 19:
      HEAP[$iftmp_259] = 0;
      __label__ = 20;
      break;
     case 20:
      
      var $87 = HEAP[$self_addr] + 28;
      var $88 = HEAP[$iftmp_259];
      HEAP[$87] = $88;
      
      var $90 = HEAP[$self_addr] + 12;
      HEAP[$90] = 1;
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 21:
      var $91 = HEAP[$0];
      HEAP[$retval] = $91;
      __label__ = 22;
      break;
     case 22:
      var $retval22 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_line($self, $output) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $output_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      var $str_end = __stackBase__ + 20;
      var $len = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$output_addr] = $output;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 32, ___PRETTY_FUNCTION___8386);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      
      
      var $11 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 16];
      HEAP[$str_end] = $11;
      
      
      
      
      
      
      var $18 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12];
      HEAP[$n] = $18;
      __label__ = 4;
      break;
     case 3:
      
      var $20 = HEAP[$n] + 1;
      HEAP[$n] = $20;
      __label__ = 4;
      break;
     case 4:
      
      
      
      if (HEAP[$n] >= HEAP[$str_end]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      if (HEAP[HEAP[$n]] != 10) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      
      if (HEAP[$n] < HEAP[$str_end]) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $31 = HEAP[$n] + 1;
      HEAP[$n] = $31;
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      
      
      
      
      
      var $42 = HEAP[$n] - (HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12]);
      HEAP[$len] = $42;
      
      
      
      
      
      
      var $49 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12];
      var $50 = HEAP[$output_addr];
      HEAP[$50] = $49;
      
      
      if (HEAP[$len] < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      ___assert_fail(__str268, __str167, 48, ___PRETTY_FUNCTION___8386);
      throw "Reached an unreachable!";
     case 10:
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] >= 2147483647 - HEAP[$len]) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      ___assert_fail(__str369, __str167, 49, ___PRETTY_FUNCTION___8386);
      throw "Reached an unreachable!";
     case 12:
      
      
      
      
      var $63 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len];
      
      var $65 = HEAP[$self_addr] + 12;
      HEAP[$65] = $63;
      var $66 = HEAP[$len];
      HEAP[$0] = $66;
      var $67 = HEAP[$0];
      HEAP[$retval] = $67;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _resize_buffer($self, $size) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $size_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_2 = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $alloc = __stackBase__ + 20;
      var $new_buf = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$size_addr] = $size;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$alloc] = $3;
      HEAP[$new_buf] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 66, ___PRETTY_FUNCTION___8425);
      throw "Reached an unreachable!";
     case 2:
      
      
      if (HEAP[$size_addr] < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      var $10 = HEAP[$alloc];
      var $11 = Math.floor($10 / 2);
      
      
      if ($11 > HEAP[$size_addr]) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      var $15 = HEAP[$size_addr] + 1;
      HEAP[$alloc] = $15;
      __label__ = 13;
      break;
     case 5:
      
      
      
      if (HEAP[$size_addr] < HEAP[$alloc]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 17;
      break;
     case 7:
      
      
      
      
      
      
      if (HEAP[$size_addr] <= HEAP[$alloc] * 1.125) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      var $28 = (HEAP[$size_addr] >>> 3) + HEAP[$size_addr];
      
      
      if (HEAP[$size_addr] <= 8) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$iftmp_2] = 3;
      __label__ = 11;
      break;
     case 10:
      HEAP[$iftmp_2] = 6;
      __label__ = 11;
      break;
     case 11:
      
      var $32 = $28 + HEAP[$iftmp_2];
      HEAP[$alloc] = $32;
      __label__ = 13;
      break;
     case 12:
      
      var $34 = HEAP[$size_addr] + 1;
      HEAP[$alloc] = $34;
      __label__ = 13;
      break;
     case 13:
      
      
      var $37 = HEAP[HEAP[$self_addr] + 8];
      var $38 = HEAP[$alloc];
      var $39 = _PyMem_Realloc($37, $38);
      HEAP[$new_buf] = $39;
      
      
      if (HEAP[$new_buf] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $42 = _PyErr_NoMemory();
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 15:
      
      var $44 = HEAP[$self_addr] + 20;
      var $45 = HEAP[$alloc];
      HEAP[$44] = $45;
      
      var $47 = HEAP[$self_addr] + 8;
      var $48 = HEAP[$new_buf];
      HEAP[$47] = $48;
      HEAP[$0] = 0;
      __label__ = 17;
      break;
     case 16:
      var $49 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($49, __str470);
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 17:
      var $50 = HEAP[$0];
      HEAP[$retval] = $50;
      __label__ = 18;
      break;
     case 18:
      var $retval16 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _write_bytes($self, $bytes, $len) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $bytes_addr = __stackBase__ + 4;
      var $len_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$bytes_addr] = $bytes;
      HEAP[$len_addr] = $len;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str66, __str167, 113, ___PRETTY_FUNCTION___8462);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str571, __str167, 114, ___PRETTY_FUNCTION___8462);
      throw "Reached an unreachable!";
     case 4:
      
      
      if (HEAP[$len_addr] < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      ___assert_fail(__str268, __str167, 115, ___PRETTY_FUNCTION___8462);
      throw "Reached an unreachable!";
     case 6:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] + HEAP[$len_addr] > HEAP[HEAP[$self_addr] + 20]) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      
      var $24 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len_addr];
      var $25 = HEAP[$self_addr];
      var $26 = _resize_buffer($25, $24);
      
      if ($26 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = -1;
      __label__ = 14;
      break;
     case 9:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] > HEAP[HEAP[$self_addr] + 16]) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      
      
      var $41 = HEAP[HEAP[$self_addr] + 12] - HEAP[HEAP[$self_addr] + 16];
      
      
      
      
      
      
      var $48 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 16];
      _llvm_memset_p0i8_i32($48, 0, $41, 1, 0);
      __label__ = 11;
      break;
     case 11:
      var $49 = HEAP[$len_addr];
      
      
      
      
      
      
      var $56 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12];
      var $57 = HEAP[$bytes_addr];
      _llvm_memcpy_p0i8_p0i8_i32($56, $57, $49, 1, 0);
      
      
      
      
      var $62 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len_addr];
      
      var $64 = HEAP[$self_addr] + 12;
      HEAP[$64] = $62;
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] < HEAP[HEAP[$self_addr] + 12]) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      var $74 = HEAP[HEAP[$self_addr] + 12];
      
      var $76 = HEAP[$self_addr] + 16;
      HEAP[$76] = $74;
      __label__ = 13;
      break;
     case 13:
      var $77 = HEAP[$len_addr];
      HEAP[$0] = $77;
      __label__ = 14;
      break;
     case 14:
      var $78 = HEAP[$0];
      HEAP[$retval] = $78;
      __label__ = 15;
      break;
     case 15:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_get_closed($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      
      
      
      
      if (HEAP[HEAP[__stackBase__] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[__Py_TrueStruct] + 1;
      
      HEAP[__Py_TrueStruct] = $7;
      HEAP[$0] = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 2:
      
      
      var $11 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $11;
      HEAP[$0] = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      var $13 = HEAP[$0];
      HEAP[$retval] = $13;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _return_true($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      
      
      var $3 = HEAP[__Py_TrueStruct] + 1;
      
      HEAP[__Py_TrueStruct] = $3;
      HEAP[$0] = __Py_TrueStruct;
      var $5 = HEAP[$0];
      HEAP[$retval] = $5;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_flush($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      
      
      
      
      if (HEAP[HEAP[__stackBase__] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $7 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $7;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      var $8 = HEAP[$0];
      HEAP[$retval] = $8;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_getvalue($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[HEAP[$self_addr] + 16];
      
      
      var $11 = HEAP[HEAP[$self_addr] + 8];
      var $12 = _PyString_FromStringAndSize($11, $8);
      HEAP[$0] = $12;
      __label__ = 3;
      break;
     case 3:
      var $13 = HEAP[$0];
      HEAP[$retval] = $13;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_isatty($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      
      
      
      
      if (HEAP[HEAP[__stackBase__] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $8;
      HEAP[$0] = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_tell($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[HEAP[$self_addr] + 12];
      var $9 = _PyLong_FromSsize_t($8);
      HEAP[$0] = $9;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $output = __stackBase__ + 24;
      var $arg = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str773, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      HEAP[$size] = $14;
      
      var $16 = HEAP[$size] == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 8:
      __label__ = 12;
      break;
     case 9:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$size] = -1;
      __label__ = 12;
      break;
     case 11:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 12:
      
      
      
      
      
      
      var $34 = HEAP[HEAP[$self_addr] + 16] - HEAP[HEAP[$self_addr] + 12];
      HEAP[$n] = $34;
      
      
      if (HEAP[$size] < 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 13:
      
      
      
      if (HEAP[$size] > HEAP[$n]) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $40 = HEAP[$n];
      HEAP[$size] = $40;
      
      
      if (HEAP[$size] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$size] = 0;
      __label__ = 16;
      break;
     case 16:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      ___assert_fail(__str66, __str167, 252, ___PRETTY_FUNCTION___8590);
      throw "Reached an unreachable!";
     case 18:
      
      
      
      
      
      
      var $53 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12];
      HEAP[$output] = $53;
      
      
      
      
      var $58 = HEAP[HEAP[$self_addr] + 12] + HEAP[$size];
      
      var $60 = HEAP[$self_addr] + 12;
      HEAP[$60] = $58;
      var $61 = HEAP[$output];
      var $62 = HEAP[$size];
      var $63 = _PyString_FromStringAndSize($61, $62);
      HEAP[$0] = $63;
      __label__ = 19;
      break;
     case 19:
      var $64 = HEAP[$0];
      HEAP[$retval] = $64;
      __label__ = 20;
      break;
     case 20:
      var $retval19 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_read1($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $n_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $arg = __stackBase__ + 16;
      var $res = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$n_addr] = $n;
      var $1 = HEAP[$n_addr];
      var $2 = _PyTuple_Pack(1, allocate([ $1, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$arg] = $2;
      
      
      if (HEAP[$arg] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      var $5 = HEAP[$self_addr];
      var $6 = HEAP[$arg];
      var $7 = _bytesio_read($5, $6);
      HEAP[$res] = $7;
      
      
      
      var $11 = HEAP[HEAP[$arg]] - 1;
      
      var $13 = HEAP[$arg];
      HEAP[$13] = $11;
      
      
      
      
      if (HEAP[HEAP[$arg]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[HEAP[$arg] + 4] + 24];
      var $23 = HEAP[$arg];
      FUNCTION_TABLE[$22]($23);
      __label__ = 4;
      break;
     case 4:
      var $24 = HEAP[$res];
      HEAP[$0] = $24;
      __label__ = 5;
      break;
     case 5:
      var $25 = HEAP[$0];
      HEAP[$retval] = $25;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $output = __stackBase__ + 24;
      var $arg = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str975, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      HEAP[$size] = $14;
      
      var $16 = HEAP[$size] == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 8:
      __label__ = 12;
      break;
     case 9:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$size] = -1;
      __label__ = 12;
      break;
     case 11:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 12:
      var $28 = HEAP[$self_addr];
      var $29 = _get_line($28, $output);
      HEAP[$n] = $29;
      
      
      if (HEAP[$size] >= 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      
      if (HEAP[$size] < HEAP[$n]) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      var $37 = HEAP[$n] - HEAP[$size];
      HEAP[$size] = $37;
      
      
      var $40 = HEAP[$n] - HEAP[$size];
      HEAP[$n] = $40;
      
      
      
      
      var $45 = HEAP[HEAP[$self_addr] + 12] - HEAP[$size];
      
      var $47 = HEAP[$self_addr] + 12;
      HEAP[$47] = $45;
      __label__ = 15;
      break;
     case 15:
      var $48 = HEAP[$output];
      var $49 = HEAP[$n];
      var $50 = _PyString_FromStringAndSize($48, $49);
      HEAP[$0] = $50;
      __label__ = 16;
      break;
     case 16:
      var $51 = HEAP[$0];
      HEAP[$retval] = $51;
      __label__ = 17;
      break;
     case 17:
      var $retval16 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readlines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 44;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 44);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $maxsize = __stackBase__ + 16;
      var $size = __stackBase__ + 20;
      var $n = __stackBase__ + 24;
      var $result = __stackBase__ + 28;
      var $line = __stackBase__ + 32;
      var $output = __stackBase__ + 36;
      var $arg = __stackBase__ + 40;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str1076, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      HEAP[$maxsize] = $14;
      
      var $16 = HEAP[$maxsize] == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 8:
      __label__ = 12;
      break;
     case 9:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$maxsize] = -1;
      __label__ = 12;
      break;
     case 11:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str874, allocate([ $25, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 12:
      HEAP[$size] = 0;
      var $28 = _PyList_New(0);
      HEAP[$result] = $28;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 14:
      __label__ = 24;
      break;
     case 15:
      var $31 = HEAP[$output];
      var $32 = HEAP[$n];
      var $33 = _PyString_FromStringAndSize($31, $32);
      HEAP[$line] = $33;
      
      
      if (HEAP[$line] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      var $36 = HEAP[$result];
      var $37 = HEAP[$line];
      var $38 = _PyList_Append($36, $37);
      var $39 = $38 == -1;
      if ($39) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      
      var $43 = HEAP[HEAP[$line]] - 1;
      
      var $45 = HEAP[$line];
      HEAP[$45] = $43;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $55 = HEAP[$line];
      FUNCTION_TABLE[$54]($55);
      __label__ = 19;
      break;
     case 19:
      __label__ = 26;
      break;
     case 20:
      
      
      
      var $59 = HEAP[HEAP[$line]] - 1;
      
      var $61 = HEAP[$line];
      HEAP[$61] = $59;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $70 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $71 = HEAP[$line];
      FUNCTION_TABLE[$70]($71);
      __label__ = 22;
      break;
     case 22:
      
      
      var $74 = HEAP[$size] + HEAP[$n];
      HEAP[$size] = $74;
      
      
      if (HEAP[$maxsize] > 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      if (HEAP[$size] >= HEAP[$maxsize]) {
        __label__ = 25;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      var $80 = HEAP[$self_addr];
      var $81 = _get_line($80, $output);
      HEAP[$n] = $81;
      
      
      if (HEAP[$n] != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      var $84 = HEAP[$result];
      HEAP[$0] = $84;
      __label__ = 29;
      break;
     case 26:
      
      
      
      var $88 = HEAP[HEAP[$result]] - 1;
      
      var $90 = HEAP[$result];
      HEAP[$90] = $88;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $99 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $100 = HEAP[$result];
      FUNCTION_TABLE[$99]($100);
      __label__ = 28;
      break;
     case 28:
      HEAP[$0] = 0;
      __label__ = 29;
      break;
     case 29:
      var $101 = HEAP[$0];
      HEAP[$retval] = $101;
      __label__ = 30;
      break;
     case 30:
      var $retval28 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval28;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 76;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 76);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buf = __stackBase__ + 16;
      var $len = __stackBase__ + 68;
      var $n = __stackBase__ + 72;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str1177, allocate([ $buf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 4:
      
      var $10 = HEAP[$buf + 8];
      HEAP[$len] = $10;
      
      
      
      
      
      
      var $17 = HEAP[HEAP[$self_addr] + 16] - HEAP[HEAP[$self_addr] + 12];
      HEAP[$n] = $17;
      
      
      
      if (HEAP[$len] > HEAP[$n]) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      var $21 = HEAP[$n];
      HEAP[$len] = $21;
      
      
      if (HEAP[$len] < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$len] = 0;
      __label__ = 7;
      break;
     case 7:
      var $24 = HEAP[$len];
      
      
      
      
      
      
      var $31 = HEAP[HEAP[$self_addr] + 8] + HEAP[HEAP[$self_addr] + 12];
      
      var $33 = HEAP[$buf];
      _llvm_memcpy_p0i8_p0i8_i32($33, $31, $24, 1, 0);
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] + HEAP[$len] == 2147483647) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      ___assert_fail(__str1278, __str167, 411, ___PRETTY_FUNCTION___8792);
      throw "Reached an unreachable!";
     case 9:
      
      
      if (HEAP[$len] < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      ___assert_fail(__str268, __str167, 412, ___PRETTY_FUNCTION___8792);
      throw "Reached an unreachable!";
     case 11:
      
      
      
      
      var $46 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len];
      
      var $48 = HEAP[$self_addr] + 12;
      HEAP[$48] = $46;
      _PyBuffer_Release($buf);
      var $49 = HEAP[$len];
      var $50 = _PyLong_FromSsize_t($49);
      HEAP[$0] = $50;
      __label__ = 12;
      break;
     case 12:
      var $51 = HEAP[$0];
      HEAP[$retval] = $51;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      var $arg = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str1379, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 4:
      var $9 = HEAP[$arg];
      var $10 = _PyNumber_Check($9);
      
      if ($10 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $12 = HEAP[_PyExc_OverflowError];
      var $13 = HEAP[$arg];
      var $14 = _PyNumber_AsSsize_t($13, $12);
      HEAP[$size] = $14;
      
      var $16 = HEAP[$size] == -1;
      if ($16) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $17 = _PyErr_Occurred();
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 8:
      __label__ = 12;
      break;
     case 9:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      var $23 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$size] = $23;
      __label__ = 12;
      break;
     case 11:
      
      
      
      
      var $28 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $29 = HEAP[_PyExc_TypeError];
      var $30 = _PyErr_Format($29, __str874, allocate([ $28, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 12:
      
      
      if (HEAP[$size] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $33 = HEAP[_PyExc_ValueError];
      var $34 = HEAP[$size];
      var $35 = _PyErr_Format($33, __str1480, allocate([ $34, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 14:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] > HEAP[$size]) {
        __label__ = 15;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 15:
      
      var $42 = HEAP[$self_addr] + 16;
      var $43 = HEAP[$size];
      HEAP[$42] = $43;
      var $44 = HEAP[$size];
      var $45 = HEAP[$self_addr];
      var $46 = _resize_buffer($45, $44);
      
      if ($46 < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 17:
      var $48 = HEAP[$size];
      var $49 = _PyLong_FromSsize_t($48);
      HEAP[$0] = $49;
      __label__ = 18;
      break;
     case 18:
      var $50 = HEAP[$0];
      HEAP[$retval] = $50;
      __label__ = 19;
      break;
     case 19:
      var $retval18 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $next = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 2:
      var $6 = HEAP[$self_addr];
      var $7 = _get_line($6, $next);
      HEAP[$n] = $7;
      
      
      if (HEAP[$next] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      if (HEAP[$n] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $12 = HEAP[$next];
      var $13 = HEAP[$n];
      var $14 = _PyString_FromStringAndSize($12, $13);
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $posobj = __stackBase__ + 16;
      var $pos = __stackBase__ + 20;
      var $mode = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$mode] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = _PyArg_ParseTuple($6, __str1581, allocate([ $posobj, 0, 0, 0, $mode, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 4:
      var $9 = HEAP[_PyExc_OverflowError];
      var $10 = HEAP[$posobj];
      var $11 = _PyNumber_AsSsize_t($10, $9);
      HEAP[$pos] = $11;
      
      var $13 = HEAP[$pos] == -1;
      if ($13) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      var $14 = _PyErr_Occurred();
      
      if ($14 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 7:
      
      
      if (HEAP[$pos] < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      if (HEAP[$mode] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $20 = HEAP[_PyExc_ValueError];
      var $21 = HEAP[$pos];
      var $22 = _PyErr_Format($20, __str1682, allocate([ $21, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 10:
      
      
      if (HEAP[$mode] == 1) {
        __label__ = 11;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 11:
      
      
      
      
      
      
      if (2147483647 - HEAP[HEAP[$self_addr] + 12] < HEAP[$pos]) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      var $31 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($31, __str1783);
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 13:
      
      
      
      
      var $36 = HEAP[HEAP[$self_addr] + 12] + HEAP[$pos];
      HEAP[$pos] = $36;
      __label__ = 20;
      break;
     case 14:
      
      
      if (HEAP[$mode] == 2) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      
      
      
      
      
      
      if (2147483647 - HEAP[HEAP[$self_addr] + 16] < HEAP[$pos]) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      var $45 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($45, __str1783);
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 17:
      
      
      
      
      var $50 = HEAP[HEAP[$self_addr] + 16] + HEAP[$pos];
      HEAP[$pos] = $50;
      __label__ = 20;
      break;
     case 18:
      
      
      if (HEAP[$mode] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      var $53 = HEAP[$mode];
      var $54 = HEAP[_PyExc_ValueError];
      var $55 = _PyErr_Format($54, __str1884, allocate([ $53, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 20:
      
      
      if (HEAP[$pos] < 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      HEAP[$pos] = 0;
      __label__ = 22;
      break;
     case 22:
      
      var $59 = HEAP[$self_addr] + 12;
      var $60 = HEAP[$pos];
      HEAP[$59] = $60;
      
      
      var $63 = HEAP[HEAP[$self_addr] + 12];
      var $64 = _PyLong_FromSsize_t($63);
      HEAP[$0] = $64;
      __label__ = 23;
      break;
     case 23:
      var $65 = HEAP[$0];
      HEAP[$retval] = $65;
      __label__ = 24;
      break;
     case 24:
      var $retval23 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_write($self, $obj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 76;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 76);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $obj_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      var $buf = __stackBase__ + 20;
      var $result = __stackBase__ + 72;
      
      HEAP[$self_addr] = $self;
      HEAP[$obj_addr] = $obj;
      HEAP[$n] = 0;
      HEAP[$result] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 2:
      var $6 = HEAP[$obj_addr];
      var $7 = _PyObject_GetBuffer($6, $buf, 8);
      
      if ($7 < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 4:
      
      
      
      if (HEAP[$buf + 8] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $13 = HEAP[$buf + 8];
      
      var $15 = HEAP[$buf];
      var $16 = HEAP[$self_addr];
      var $17 = _write_bytes($16, $15, $13);
      HEAP[$n] = $17;
      __label__ = 6;
      break;
     case 6:
      
      
      if (HEAP[$n] >= 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      var $20 = HEAP[$n];
      var $21 = _PyLong_FromSsize_t($20);
      HEAP[$result] = $21;
      __label__ = 8;
      break;
     case 8:
      _PyBuffer_Release($buf);
      var $22 = HEAP[$result];
      HEAP[$0] = $22;
      __label__ = 9;
      break;
     case 9:
      var $23 = HEAP[$0];
      HEAP[$retval] = $23;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_writelines($self, $v) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $v_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $it = __stackBase__ + 16;
      var $item = __stackBase__ + 20;
      var $ret = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$v_addr] = $v;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str672);
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 2:
      var $6 = HEAP[$v_addr];
      var $7 = _PyObject_GetIter($6);
      HEAP[$it] = $7;
      
      
      if (HEAP[$it] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 4:
      __label__ = 13;
      break;
     case 5:
      var $10 = HEAP[$self_addr];
      var $11 = HEAP[$item];
      var $12 = _bytesio_write($10, $11);
      HEAP[$ret] = $12;
      
      
      
      var $16 = HEAP[HEAP[$item]] - 1;
      
      var $18 = HEAP[$item];
      HEAP[$18] = $16;
      
      
      
      
      if (HEAP[HEAP[$item]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $27 = HEAP[HEAP[HEAP[$item] + 4] + 24];
      var $28 = HEAP[$item];
      FUNCTION_TABLE[$27]($28);
      __label__ = 7;
      break;
     case 7:
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $34 = HEAP[HEAP[$it]] - 1;
      
      var $36 = HEAP[$it];
      HEAP[$36] = $34;
      
      
      
      
      if (HEAP[HEAP[$it]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$it] + 4] + 24];
      var $46 = HEAP[$it];
      FUNCTION_TABLE[$45]($46);
      __label__ = 10;
      break;
     case 10:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 11:
      
      
      
      var $50 = HEAP[HEAP[$ret]] - 1;
      
      var $52 = HEAP[$ret];
      HEAP[$52] = $50;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $61 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $62 = HEAP[$ret];
      FUNCTION_TABLE[$61]($62);
      __label__ = 13;
      break;
     case 13:
      var $63 = HEAP[$it];
      var $64 = _PyIter_Next($63);
      HEAP[$item] = $64;
      
      
      if (HEAP[$item] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      
      var $70 = HEAP[HEAP[$it]] - 1;
      
      var $72 = HEAP[$it];
      HEAP[$72] = $70;
      
      
      
      
      if (HEAP[HEAP[$it]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $81 = HEAP[HEAP[HEAP[$it] + 4] + 24];
      var $82 = HEAP[$it];
      FUNCTION_TABLE[$81]($82);
      __label__ = 16;
      break;
     case 16:
      var $83 = _PyErr_Occurred();
      
      if ($83 != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 18:
      
      var $86 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $86;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 19;
      break;
     case 19:
      var $87 = HEAP[$0];
      HEAP[$retval] = $87;
      __label__ = 20;
      break;
     case 20:
      var $retval19 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_close($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      _PyMem_Free($7);
      
      var $9 = HEAP[$self_addr] + 8;
      HEAP[$9] = 0;
      __label__ = 2;
      break;
     case 2:
      
      var $11 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $11;
      HEAP[$0] = __Py_NoneStruct;
      var $12 = HEAP[$0];
      HEAP[$retval] = $12;
      __label__ = 3;
      break;
     case 3:
      var $retval2 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval2;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_getstate($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $initvalue = __stackBase__ + 12;
      var $dict = __stackBase__ + 16;
      var $state = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      var $1 = HEAP[$self_addr];
      var $2 = _bytesio_getvalue($1);
      HEAP[$initvalue] = $2;
      
      
      if (HEAP[$initvalue] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      var $10 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $10;
      HEAP[$dict] = __Py_NoneStruct;
      __label__ = 6;
      break;
     case 4:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 24];
      var $14 = _PyDict_Copy($13);
      HEAP[$dict] = $14;
      
      
      if (HEAP[$dict] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 6:
      
      
      var $19 = HEAP[HEAP[$self_addr] + 12];
      var $20 = HEAP[$initvalue];
      var $21 = HEAP[$dict];
      var $22 = _Py_BuildValue(__str1985, allocate([ $20, 0, 0, 0, $19, 0, 0, 0, $21, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$state] = $22;
      
      
      
      var $26 = HEAP[HEAP[$initvalue]] - 1;
      
      var $28 = HEAP[$initvalue];
      HEAP[$28] = $26;
      
      
      
      
      if (HEAP[HEAP[$initvalue]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $37 = HEAP[HEAP[HEAP[$initvalue] + 4] + 24];
      var $38 = HEAP[$initvalue];
      FUNCTION_TABLE[$37]($38);
      __label__ = 8;
      break;
     case 8:
      var $39 = HEAP[$state];
      HEAP[$0] = $39;
      __label__ = 9;
      break;
     case 9:
      var $40 = HEAP[$0];
      HEAP[$retval] = $40;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_setstate($self, $state) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $state_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $result = __stackBase__ + 16;
      var $position_obj = __stackBase__ + 20;
      var $dict = __stackBase__ + 24;
      var $pos = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$state_addr] = $state;
      
      
      if (HEAP[$state_addr] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str2086, __str167, 668, ___PRETTY_FUNCTION___9082);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$state_addr] + 4] + 84] & 67108864) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      if (HEAP[HEAP[$state_addr] + 8] <= 2) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $19 = HEAP[HEAP[HEAP[$state_addr] + 4] + 12];
      
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$self_addr] + 4] + 12];
      var $26 = HEAP[_PyExc_TypeError];
      var $27 = _PyErr_Format($26, __str2187, allocate([ $25, 0, 0, 0, $19, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 5:
      
      var $29 = HEAP[$self_addr] + 16;
      HEAP[$29] = 0;
      
      var $31 = HEAP[$self_addr] + 12;
      HEAP[$31] = 0;
      
      
      
      
      var $36 = HEAP[HEAP[$state_addr] + 12];
      var $37 = HEAP[$self_addr];
      var $38 = _bytesio_write($37, $36);
      HEAP[$result] = $38;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 7:
      
      
      
      var $44 = HEAP[HEAP[$result]] - 1;
      
      var $46 = HEAP[$result];
      HEAP[$46] = $44;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $55 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $56 = HEAP[$result];
      FUNCTION_TABLE[$55]($56);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      var $61 = HEAP[HEAP[$state_addr] + 12 + 4];
      HEAP[$position_obj] = $61;
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$position_obj] + 4] + 48] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$position_obj] + 4] + 84] & 131072) == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[HEAP[$position_obj] + 4] + 48] + 152] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $87 = HEAP[HEAP[HEAP[$position_obj] + 4] + 12];
      var $88 = HEAP[_PyExc_TypeError];
      var $89 = _PyErr_Format($88, __str2288, allocate([ $87, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 13:
      var $90 = HEAP[_PyExc_OverflowError];
      var $91 = HEAP[$position_obj];
      var $92 = _PyNumber_AsSsize_t($91, $90);
      HEAP[$pos] = $92;
      
      var $94 = HEAP[$pos] == -1;
      if ($94) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      var $95 = _PyErr_Occurred();
      
      if ($95 != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 16:
      
      
      if (HEAP[$pos] < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $99 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($99, __str2389);
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 18:
      
      var $101 = HEAP[$self_addr] + 12;
      var $102 = HEAP[$pos];
      HEAP[$101] = $102;
      
      
      
      
      var $107 = HEAP[HEAP[$state_addr] + 12 + 8];
      HEAP[$dict] = $107;
      
      
      if (HEAP[$dict] != __Py_NoneStruct) {
        __label__ = 19;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 19:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$dict] + 4] + 84] & 536870912) == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $121 = HEAP[HEAP[HEAP[$dict] + 4] + 12];
      var $122 = HEAP[_PyExc_TypeError];
      var $123 = _PyErr_Format($122, __str2490, allocate([ $121, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 22:
      
      
      var $130 = HEAP[HEAP[$self_addr] + 24];
      var $131 = HEAP[$dict];
      var $132 = _PyDict_Update($130, $131);
      
      if ($132 < 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      HEAP[$0] = 0;
      __label__ = 27;
      break;
     case 24:
      __label__ = 26;
      break;
     case 25:
      
      
      
      var $137 = HEAP[HEAP[$dict]] + 1;
      
      var $139 = HEAP[$dict];
      HEAP[$139] = $137;
      
      var $141 = HEAP[$self_addr] + 24;
      var $142 = HEAP[$dict];
      HEAP[$141] = $142;
      __label__ = 26;
      break;
     case 26:
      
      var $144 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $144;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 27;
      break;
     case 27:
      var $145 = HEAP[$0];
      HEAP[$retval] = $145;
      __label__ = 28;
      break;
     case 28:
      var $retval27 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval27;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      var $2 = HEAP[$self_addr] + -12;
      HEAP[$g] = $2;
      
      
      
      
      var $7 = HEAP[HEAP[$g] + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str2591, __str167, 738, ___PRETTY_FUNCTION___9166);
      throw "Reached an unreachable!";
     case 2:
      
      
      var $10 = HEAP[$g] + 8;
      HEAP[$10] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[HEAP[$g]];
      
      var $20 = HEAP[HEAP[$g] + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[HEAP[$g] + 4];
      
      var $30 = HEAP[HEAP[$g]] + 4;
      HEAP[$30] = $28;
      
      
      var $33 = HEAP[$g];
      HEAP[$33] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      var $40 = HEAP[HEAP[$self_addr] + 8];
      _PyMem_Free($40);
      
      var $42 = HEAP[$self_addr] + 8;
      HEAP[$42] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      var $49 = HEAP[HEAP[$self_addr] + 24];
      HEAP[$_py_tmp] = $49;
      
      var $51 = HEAP[$self_addr] + 24;
      HEAP[$51] = 0;
      
      
      
      var $55 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $57 = HEAP[$_py_tmp];
      HEAP[$57] = $55;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $66 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $67 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$66]($67);
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $73 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($73);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      
      var $79 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $81 = HEAP[$self_addr];
      FUNCTION_TABLE[$79]($81);
      __label__ = 10;
      break;
     case 10:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_new($type, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $self = __stackBase__ + 20;
      
      HEAP[$type_addr] = $type;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      
      if (HEAP[$type_addr] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$type_addr] + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str2692, __str167, 754, ___PRETTY_FUNCTION___9203);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[HEAP[$type_addr] + 152];
      var $10 = HEAP[$type_addr];
      var $11 = FUNCTION_TABLE[$9]($10, 0);
      var $12 = $11;
      HEAP[$self] = $12;
      
      
      if (HEAP[$self] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 5:
      var $15 = _PyMem_Malloc(0);
      
      var $17 = HEAP[$self] + 8;
      HEAP[$17] = $15;
      
      
      
      
      if (HEAP[HEAP[$self] + 8] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      var $23 = HEAP[$self];
      
      
      var $26 = HEAP[$23] - 1;
      var $27 = $23;
      HEAP[$27] = $26;
      
      
      
      if (HEAP[$23] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $36 = HEAP[HEAP[HEAP[$self] + 4] + 24];
      
      var $38 = HEAP[$self];
      FUNCTION_TABLE[$36]($38);
      __label__ = 8;
      break;
     case 8:
      var $39 = _PyErr_NoMemory();
      HEAP[$0] = $39;
      __label__ = 10;
      break;
     case 9:
      
      var $41 = HEAP[$self];
      HEAP[$0] = $41;
      __label__ = 10;
      break;
     case 10:
      var $42 = HEAP[$0];
      HEAP[$retval] = $42;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $kwlist = __stackBase__ + 20;
      var $initvalue = __stackBase__ + 28;
      var $res = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_82_9238];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_82_9238 + 4];
      HEAP[$kwlist + 4] = $4;
      HEAP[$initvalue] = 0;
      var $5 = HEAP[$args_addr];
      var $6 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $7 = _PyArg_ParseTupleAndKeywords($5, $6, __str2894, $kwlist1, allocate([ $initvalue, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 10;
      break;
     case 2:
      
      var $10 = HEAP[$self_addr] + 16;
      HEAP[$10] = 0;
      
      var $12 = HEAP[$self_addr] + 12;
      HEAP[$12] = 0;
      
      
      if (HEAP[$initvalue] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 3:
      
      
      if (HEAP[$initvalue] != __Py_NoneStruct) {
        __label__ = 4;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 4:
      var $17 = HEAP[$initvalue];
      var $18 = HEAP[$self_addr];
      var $19 = _bytesio_write($18, $17);
      HEAP[$res] = $19;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 10;
      break;
     case 6:
      
      
      
      var $25 = HEAP[HEAP[$res]] - 1;
      
      var $27 = HEAP[$res];
      HEAP[$27] = $25;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $36 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $37 = HEAP[$res];
      FUNCTION_TABLE[$36]($37);
      __label__ = 8;
      break;
     case 8:
      
      var $39 = HEAP[$self_addr] + 12;
      HEAP[$39] = 0;
      __label__ = 9;
      break;
     case 9:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 10:
      var $40 = HEAP[$0];
      HEAP[$retval] = $40;
      __label__ = 11;
      break;
     case 11:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 24];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 4;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 4:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _bytesio_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 24];
      HEAP[$_py_tmp] = $7;
      
      var $9 = HEAP[$self_addr] + 24;
      HEAP[$9] = 0;
      
      
      
      var $13 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $15 = HEAP[$_py_tmp];
      HEAP[$15] = $13;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $25 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$24]($25);
      __label__ = 3;
      break;
     case 3:
      HEAP[$0] = 0;
      var $26 = HEAP[$0];
      HEAP[$retval] = $26;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyFileIO_closed($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      
      
      
      
      
      var $6 = HEAP[HEAP[__stackBase__] + 8] < 0;
      HEAP[$0] = $6;
      var $7 = HEAP[$0];
      HEAP[$retval] = $7;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _internal_close($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $err = __stackBase__ + 12;
      var $save_errno = __stackBase__ + 16;
      var $fd = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$err] = 0;
      HEAP[$save_errno] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] >= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$fd] = $7;
      
      var $9 = HEAP[$self_addr] + 8;
      HEAP[$9] = -1;
      var $10 = HEAP[$fd];
      var $11 = _close($10);
      HEAP[$err] = $11;
      
      
      if (HEAP[$err] < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $14 = ___errno_location();
      var $15 = HEAP[$14];
      HEAP[$save_errno] = $15;
      __label__ = 3;
      break;
     case 3:
      
      
      if (HEAP[$err] < 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $18 = ___errno_location();
      var $19 = HEAP[$save_errno];
      HEAP[$18] = $19;
      var $20 = HEAP[_PyExc_IOError];
      var $21 = _PyErr_SetFromErrno($20);
      HEAP[$0] = -1;
      __label__ = 6;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 6:
      var $22 = HEAP[$0];
      HEAP[$retval] = $22;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_close($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 27 >>> 31 & 1) == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $9 = HEAP[$self_addr] + 8;
      HEAP[$9] = -1;
      
      var $11 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $11;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 2:
      var $12 = ___errno_location();
      var $13 = HEAP[$self_addr];
      var $14 = _internal_close($13);
      HEAP[$12] = $14;
      var $15 = ___errno_location();
      
      
      if (HEAP[$15] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 4:
      var $18 = HEAP[$self_addr];
      var $19 = __PyObject_CallMethod_SizeT(_PyRawIOBase_Type, __str117, __str1118, allocate([ $18, 0, 0, 0 ], [ "%struct.fileio*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $19;
      __label__ = 5;
      break;
     case 5:
      var $20 = HEAP[$0];
      HEAP[$retval] = $20;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_new($type, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $self = __stackBase__ + 20;
      
      HEAP[$type_addr] = $type;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      
      if (HEAP[$type_addr] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$type_addr] + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str2119, __str3120, 126, ___PRETTY_FUNCTION___8510);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[HEAP[$type_addr] + 152];
      var $10 = HEAP[$type_addr];
      var $11 = FUNCTION_TABLE[$9]($10, 0);
      var $12 = $11;
      HEAP[$self] = $12;
      
      
      if (HEAP[$self] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      var $16 = HEAP[$self] + 8;
      HEAP[$16] = -1;
      
      var $18 = HEAP[$self] + 12;
      
      var $20 = HEAP[$18] & -2;
      HEAP[$18] = $20;
      
      var $22 = HEAP[$self] + 12;
      
      var $24 = HEAP[$22] & -3;
      HEAP[$22] = $24;
      
      var $26 = HEAP[$self] + 12;
      
      var $28 = HEAP[$26] & -13;
      var $29 = $28 | 12;
      HEAP[$26] = $29;
      
      var $31 = HEAP[$self] + 12;
      
      var $33 = HEAP[$31] & -17;
      var $34 = $33 | 16;
      HEAP[$31] = $34;
      
      var $36 = HEAP[$self] + 16;
      HEAP[$36] = 0;
      __label__ = 5;
      break;
     case 5:
      
      var $38 = HEAP[$self];
      HEAP[$0] = $38;
      var $39 = HEAP[$0];
      HEAP[$retval] = $39;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _dircheck($self, $name) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 120;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 120);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $name_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buf = __stackBase__ + 16;
      var $msg = __stackBase__ + 112;
      var $exc = __stackBase__ + 116;
      
      HEAP[$self_addr] = $self;
      HEAP[$name_addr] = $name;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      var $8 = ___01fstat64_($7, $buf);
      
      if ($8 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 3:
      
      
      
      
      if ((HEAP[$buf + 16] & 61440) == 16384) {
        __label__ = 4;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 4:
      var $14 = _strerror(21);
      HEAP[$msg] = $14;
      var $15 = HEAP[$self_addr];
      var $16 = _internal_close($15);
      
      if ($16 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 11;
      break;
     case 6:
      var $18 = HEAP[_PyExc_IOError];
      var $19 = HEAP[$msg];
      var $20 = HEAP[$name_addr];
      var $21 = __PyObject_CallFunction_SizeT($18, __str4121, allocate([ 21, 0, 0, 0, $19, 0, 0, 0, $20, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$exc] = $21;
      var $22 = HEAP[_PyExc_IOError];
      var $23 = HEAP[$exc];
      _PyErr_SetObject($22, $23);
      
      
      if (HEAP[$exc] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      
      var $29 = HEAP[HEAP[$exc]] - 1;
      
      var $31 = HEAP[$exc];
      HEAP[$31] = $29;
      
      
      
      
      if (HEAP[HEAP[$exc]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $40 = HEAP[HEAP[HEAP[$exc] + 4] + 24];
      var $41 = HEAP[$exc];
      FUNCTION_TABLE[$40]($41);
      __label__ = 9;
      break;
     case 9:
      HEAP[$0] = -1;
      __label__ = 11;
      break;
     case 10:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 11:
      var $42 = HEAP[$0];
      HEAP[$retval] = $42;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _check_fd($fd) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 116;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 116);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $buf = __stackBase__ + 12;
      var $exc = __stackBase__ + 108;
      var $msg = __stackBase__ + 112;
      
      HEAP[__stackBase__] = $fd;
      var $1 = HEAP[__stackBase__];
      var $2 = ___01fstat64_($1, $buf);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 1:
      var $4 = ___errno_location();
      
      
      if (HEAP[$4] == 9) {
        __label__ = 2;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 2:
      var $7 = _strerror(9);
      HEAP[$msg] = $7;
      var $8 = HEAP[_PyExc_OSError];
      var $9 = HEAP[$msg];
      var $10 = __PyObject_CallFunction_SizeT($8, __str5122, allocate([ 9, 0, 0, 0, $9, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$exc] = $10;
      var $11 = HEAP[_PyExc_OSError];
      var $12 = HEAP[$exc];
      _PyErr_SetObject($11, $12);
      
      
      if (HEAP[$exc] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      
      var $18 = HEAP[HEAP[$exc]] - 1;
      
      var $20 = HEAP[$exc];
      HEAP[$20] = $18;
      
      
      
      
      if (HEAP[HEAP[$exc]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$exc] + 4] + 24];
      var $30 = HEAP[$exc];
      FUNCTION_TABLE[$29]($30);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = -1;
      __label__ = 7;
      break;
     case 6:
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 7:
      var $31 = HEAP[$0];
      HEAP[$retval] = $31;
      __label__ = 8;
      break;
     case 8:
      var $retval7 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_init($oself, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 88;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 88);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $oself_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $self = __stackBase__ + 20;
      var $name = __stackBase__ + 24;
      var $nameobj = __stackBase__ + 28;
      var $stringobj = __stackBase__ + 32;
      var $mode = __stackBase__ + 36;
      var $s = __stackBase__ + 40;
      var $ret = __stackBase__ + 44;
      var $rwa = __stackBase__ + 48;
      var $plus = __stackBase__ + 52;
      var $append = __stackBase__ + 56;
      var $flags = __stackBase__ + 60;
      var $fd = __stackBase__ + 64;
      var $closefd = __stackBase__ + 68;
      var $namelen = __stackBase__ + 72;
      var $u = __stackBase__ + 76;
      var $pos = __stackBase__ + 80;
      var $_py_tmp = __stackBase__ + 84;
      
      HEAP[$oself_addr] = $oself;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[$oself_addr];
      HEAP[$self] = $2;
      HEAP[$name] = 0;
      HEAP[$stringobj] = 0;
      HEAP[$mode] = __str6123;
      HEAP[$ret] = 0;
      HEAP[$rwa] = 0;
      HEAP[$plus] = 0;
      HEAP[$append] = 0;
      HEAP[$flags] = 0;
      HEAP[$fd] = -1;
      HEAP[$closefd] = 1;
      
      
      
      
      if (HEAP[HEAP[$oself_addr] + 4] != _PyFileIO_Type) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $9 = HEAP[HEAP[$oself_addr] + 4];
      var $10 = _PyType_IsSubtype($9, _PyFileIO_Type);
      
      if ($10 == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str7124, __str3120, 205, ___PRETTY_FUNCTION___8604);
      throw "Reached an unreachable!";
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self] + 8] >= 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      var $16 = HEAP[$self];
      var $17 = _internal_close($16);
      
      if ($17 < 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 6:
      var $19 = HEAP[$args_addr];
      var $20 = HEAP[$kwds_addr];
      var $21 = __PyArg_ParseTupleAndKeywords_SizeT($19, $20, __str8125, _kwlist_8591, allocate([ $nameobj, 0, 0, 0, $mode, 0, 0, 0, $closefd, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($21 == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 8:
      
      
      
      
      if (HEAP[HEAP[$nameobj] + 4] == _PyFloat_Type) {
        __label__ = 10;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      var $29 = HEAP[HEAP[$nameobj] + 4];
      var $30 = _PyType_IsSubtype($29, _PyFloat_Type);
      
      if ($30 != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $32 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($32, __str12129);
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 11:
      var $33 = HEAP[$nameobj];
      var $34 = _PyLong_AsLong($33);
      HEAP[$fd] = $34;
      
      
      if (HEAP[$fd] < 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 12:
      var $37 = _PyErr_Occurred();
      
      if ($37 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      var $39 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($39, __str13130);
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 14:
      _PyErr_Clear();
      __label__ = 15;
      break;
     case 15:
      
      
      if (HEAP[$fd] < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 16:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$nameobj] + 4] + 84] & 134217728) != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      if (HEAP[HEAP[$nameobj] + 4] == _PyByteArray_Type) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      var $55 = HEAP[HEAP[$nameobj] + 4];
      var $56 = _PyType_IsSubtype($55, _PyByteArray_Type);
      
      if ($56 != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 19:
      var $58 = HEAP[$nameobj];
      var $59 = _PyObject_AsCharBuffer($58, $name, $namelen);
      
      if ($59 < 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 21:
      __label__ = 31;
      break;
     case 22:
      var $61 = HEAP[$nameobj];
      var $62 = _PyUnicodeUCS2_FromObject($61);
      HEAP[$u] = $62;
      
      
      if (HEAP[$u] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 24:
      var $65 = HEAP[_Py_FileSystemDefaultEncoding];
      var $66 = HEAP[$u];
      var $67 = _PyUnicodeUCS2_AsEncodedString($66, $65, 0);
      HEAP[$stringobj] = $67;
      
      
      
      var $71 = HEAP[HEAP[$u]] - 1;
      
      var $73 = HEAP[$u];
      HEAP[$73] = $71;
      
      
      
      
      if (HEAP[HEAP[$u]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $82 = HEAP[HEAP[HEAP[$u] + 4] + 24];
      var $83 = HEAP[$u];
      FUNCTION_TABLE[$82]($83);
      __label__ = 26;
      break;
     case 26:
      
      
      if (HEAP[$stringobj] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      HEAP[$0] = -1;
      __label__ = 76;
      break;
     case 28:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$stringobj] + 4] + 84] & 134217728) == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      var $93 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($93, __str14131);
      __label__ = 71;
      break;
     case 30:
      
      
      
      var $97 = HEAP[$stringobj] + 20;
      HEAP[$name] = $97;
      __label__ = 31;
      break;
     case 31:
      var $98 = HEAP[$mode];
      HEAP[$s] = $98;
      __label__ = 44;
      break;
     case 32:
      
      
      var $101 = HEAP[HEAP[$s]];
      
      var $103 = HEAP[$s] + 1;
      HEAP[$s] = $103;
      if ($101 == 43) {
        __label__ = 41;
        break;
      } else if ($101 == 97) {
        __label__ = 38;
        break;
      } else if ($101 == 98) {
        __label__ = 40;
        break;
      } else if ($101 == 114) {
        __label__ = 33;
        break;
      } else if ($101 == 119) {
        __label__ = 36;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 33:
      
      
      if (HEAP[$rwa] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      var $106 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($106, __str15132);
      __label__ = 71;
      break;
     case 35:
      HEAP[$rwa] = 1;
      
      var $108 = HEAP[$self] + 12;
      
      var $110 = HEAP[$108] & -2;
      var $111 = $110 | 1;
      HEAP[$108] = $111;
      __label__ = 44;
      break;
     case 36:
      
      
      if (HEAP[$rwa] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 37:
      HEAP[$rwa] = 1;
      
      var $115 = HEAP[$self] + 12;
      
      var $117 = HEAP[$115] & -3;
      var $118 = $117 | 2;
      HEAP[$115] = $118;
      
      var $120 = HEAP[$flags] | 576;
      HEAP[$flags] = $120;
      __label__ = 44;
      break;
     case 38:
      
      
      if (HEAP[$rwa] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 39:
      HEAP[$rwa] = 1;
      
      var $124 = HEAP[$self] + 12;
      
      var $126 = HEAP[$124] & -3;
      var $127 = $126 | 2;
      HEAP[$124] = $127;
      
      var $129 = HEAP[$flags] | 64;
      HEAP[$flags] = $129;
      HEAP[$append] = 1;
      __label__ = 44;
      break;
     case 40:
      __label__ = 44;
      break;
     case 41:
      
      
      if (HEAP[$plus] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 42:
      
      var $133 = HEAP[$self] + 12;
      
      var $135 = HEAP[$133] & -3;
      var $136 = $135 | 2;
      HEAP[$133] = $136;
      
      
      
      
      
      
      
      var $144 = HEAP[$self] + 12;
      
      
      
      var $148 = HEAP[$144] & -2;
      var $149 = $148 | HEAP[HEAP[$self] + 12] << 30 >>> 31 & 1 & 1;
      HEAP[$144] = $149;
      HEAP[$plus] = 1;
      __label__ = 44;
      break;
     case 43:
      var $150 = HEAP[$mode];
      var $151 = HEAP[_PyExc_ValueError];
      var $152 = _PyErr_Format($151, __str16133, allocate([ $150, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 71;
      break;
     case 44:
      
      
      
      if (HEAP[HEAP[$s]] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      
      
      if (HEAP[$rwa] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self] + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self] + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 48:
      
      var $173 = HEAP[$flags] | 2;
      HEAP[$flags] = $173;
      __label__ = 52;
      break;
     case 49:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self] + 12] << 31 >>> 31 & 1) != 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      var $181 = HEAP[$flags];
      HEAP[$flags] = $181;
      __label__ = 52;
      break;
     case 51:
      
      var $183 = HEAP[$flags] | 1;
      HEAP[$flags] = $183;
      __label__ = 52;
      break;
     case 52:
      
      
      if (HEAP[$append] != 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 53:
      
      var $187 = HEAP[$flags] | 1024;
      HEAP[$flags] = $187;
      __label__ = 54;
      break;
     case 54:
      
      
      if (HEAP[$fd] >= 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 55:
      var $190 = HEAP[$fd];
      var $191 = _check_fd($190);
      
      if ($191 != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 56:
      
      var $194 = HEAP[$self] + 8;
      var $195 = HEAP[$fd];
      HEAP[$194] = $195;
      
      
      
      
      var $200 = HEAP[$self] + 12;
      
      
      
      
      var $205 = HEAP[$200] & -17;
      var $206 = $205 | (HEAP[$closefd] & 255 & 1) << 4 & 16;
      HEAP[$200] = $206;
      __label__ = 62;
      break;
     case 57:
      
      var $208 = HEAP[$self] + 12;
      
      var $210 = HEAP[$208] & -17;
      var $211 = $210 | 16;
      HEAP[$208] = $211;
      
      
      if (HEAP[$closefd] == 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      var $214 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($214, __str17134);
      __label__ = 71;
      break;
     case 59:
      var $215 = ___errno_location();
      HEAP[$215] = 0;
      var $216 = HEAP[$name];
      var $217 = HEAP[$flags];
      var $218 = ___01open64_($216, $217, allocate([ 438, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      
      var $220 = HEAP[$self] + 8;
      HEAP[$220] = $218;
      
      
      
      
      if (HEAP[HEAP[$self] + 8] < 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      var $225 = HEAP[$name];
      var $226 = HEAP[_PyExc_IOError];
      var $227 = _PyErr_SetFromErrnoWithFilename($226, $225);
      __label__ = 71;
      break;
     case 61:
      var $228 = HEAP[$name];
      var $229 = HEAP[$self];
      var $230 = _dircheck($229, $228);
      
      if ($230 < 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      var $232 = HEAP[$nameobj];
      
      var $234 = HEAP[$self];
      var $235 = _PyObject_SetAttrString($234, __str18135, $232);
      
      if ($235 < 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      
      
      if (HEAP[$append] != 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 64:
      
      
      var $241 = HEAP[HEAP[$self] + 8];
      var $242 = _portable_lseek($241, 0, 2);
      HEAP[$pos] = $242;
      
      
      if (HEAP[$pos] == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 65:
      
      
      if (HEAP[$closefd] != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      var $249 = HEAP[HEAP[$self] + 8];
      var $250 = _close($249);
      
      var $252 = HEAP[$self] + 8;
      HEAP[$252] = -1;
      __label__ = 67;
      break;
     case 67:
      __label__ = 71;
      break;
     case 68:
      
      
      
      var $256 = HEAP[HEAP[$pos]] - 1;
      
      var $258 = HEAP[$pos];
      HEAP[$258] = $256;
      
      
      
      
      if (HEAP[HEAP[$pos]] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $267 = HEAP[HEAP[HEAP[$pos] + 4] + 24];
      var $268 = HEAP[$pos];
      FUNCTION_TABLE[$267]($268);
      __label__ = 70;
      break;
     case 70:
      __label__ = 72;
      break;
     case 71:
      HEAP[$ret] = -1;
      __label__ = 72;
      break;
     case 72:
      
      
      if (HEAP[$stringobj] != 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 73:
      var $271 = HEAP[$stringobj];
      HEAP[$_py_tmp] = $271;
      HEAP[$stringobj] = 0;
      
      
      
      var $275 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $277 = HEAP[$_py_tmp];
      HEAP[$277] = $275;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      
      
      
      
      var $286 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $287 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$286]($287);
      __label__ = 75;
      break;
     case 75:
      var $288 = HEAP[$ret];
      HEAP[$0] = $288;
      __label__ = 76;
      break;
     case 76:
      var $289 = HEAP[$0];
      HEAP[$retval] = $289;
      __label__ = 77;
      break;
     case 77:
      var $retval73 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval73;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 20];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 4;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 4:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$_py_tmp] = $7;
      
      var $9 = HEAP[$self_addr] + 20;
      HEAP[$9] = 0;
      
      
      
      var $13 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $15 = HEAP[$_py_tmp];
      HEAP[$15] = $13;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $25 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$24]($25);
      __label__ = 3;
      break;
     case 3:
      HEAP[$0] = 0;
      var $26 = HEAP[$0];
      HEAP[$retval] = $26;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      var $1 = HEAP[$self_addr];
      var $2 = __PyIOBase_finalize($1);
      
      if ($2 < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      var $6 = HEAP[$self_addr] + -12;
      HEAP[$g] = $6;
      
      
      
      
      var $11 = HEAP[HEAP[$g] + 8] == -2;
      if ($11) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str19136, __str3120, 410, ___PRETTY_FUNCTION___8813);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $14 = HEAP[$g] + 8;
      HEAP[$14] = -2;
      
      
      
      
      
      
      
      var $22 = HEAP[HEAP[$g]];
      
      var $24 = HEAP[HEAP[$g] + 4];
      HEAP[$24] = $22;
      
      
      
      
      
      
      
      var $32 = HEAP[HEAP[$g] + 4];
      
      var $34 = HEAP[HEAP[$g]] + 4;
      HEAP[$34] = $32;
      
      
      var $37 = HEAP[$g];
      HEAP[$37] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      var $43 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($43);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      var $50 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$_py_tmp] = $50;
      
      var $52 = HEAP[$self_addr] + 20;
      HEAP[$52] = 0;
      
      
      
      var $56 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $58 = HEAP[$_py_tmp];
      HEAP[$58] = $56;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $67 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $68 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$67]($68);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      var $74 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $76 = HEAP[$self_addr];
      FUNCTION_TABLE[$74]($76);
      __label__ = 9;
      break;
     case 9:
      __label__ = 10;
      break;
     case 10:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _err_closed() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 8;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 8);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $retval = __stackBase__;
      var $0 = __stackBase__ + 4;
      
      var $1 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($1, __str20137);
      HEAP[$0] = 0;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _err_mode($action) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $action;
      var $1 = HEAP[_PyExc_ValueError];
      var $2 = HEAP[__stackBase__];
      var $3 = _PyErr_Format($1, __str21138, allocate([ $2, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      var $4 = HEAP[$0];
      HEAP[$retval] = $4;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_fileno($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[HEAP[$self_addr] + 8];
      var $9 = _PyInt_FromLong($8);
      HEAP[$0] = $9;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readable($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 12] << 31 >>> 31 & 1;
      var $13 = _PyBool_FromLong($12);
      HEAP[$0] = $13;
      __label__ = 3;
      break;
     case 3:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_writable($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      
      var $12 = HEAP[HEAP[$self_addr] + 12] << 30 >>> 31 & 1;
      var $13 = _PyBool_FromLong($12);
      HEAP[$0] = $13;
      __label__ = 3;
      break;
     case 3:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_seekable($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $pos = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 9;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 28 >> 30 & 3) < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 3:
      
      
      var $15 = HEAP[HEAP[$self_addr] + 8];
      var $16 = _portable_lseek($15, 0, 1);
      HEAP[$pos] = $16;
      
      
      if (HEAP[$pos] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      _PyErr_Clear();
      
      var $20 = HEAP[$self_addr] + 12;
      
      var $22 = HEAP[$20] & -13;
      HEAP[$20] = $22;
      __label__ = 8;
      break;
     case 5:
      
      
      
      var $26 = HEAP[HEAP[$pos]] - 1;
      
      var $28 = HEAP[$pos];
      HEAP[$28] = $26;
      
      
      
      
      if (HEAP[HEAP[$pos]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $37 = HEAP[HEAP[HEAP[$pos] + 4] + 24];
      var $38 = HEAP[$pos];
      FUNCTION_TABLE[$37]($38);
      __label__ = 7;
      break;
     case 7:
      
      var $40 = HEAP[$self_addr] + 12;
      
      var $42 = HEAP[$40] & -13;
      var $43 = $42 | 4;
      HEAP[$40] = $43;
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      
      var $50 = HEAP[HEAP[$self_addr] + 12] << 28 >> 30 & 3;
      var $51 = _PyBool_FromLong($50);
      HEAP[$0] = $51;
      __label__ = 9;
      break;
     case 9:
      var $52 = HEAP[$0];
      HEAP[$retval] = $52;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readinto($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 72;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 72);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $pbuf = __stackBase__ + 16;
      var $n = __stackBase__ + 68;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 11;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str22139);
      HEAP[$0] = $13;
      __label__ = 11;
      break;
     case 4:
      var $14 = HEAP[$args_addr];
      var $15 = __PyArg_ParseTuple_SizeT($14, __str23140, allocate([ $pbuf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 6:
      var $17 = ___errno_location();
      HEAP[$17] = 0;
      
      var $19 = HEAP[$pbuf + 8];
      
      var $21 = HEAP[$pbuf];
      
      
      var $24 = HEAP[HEAP[$self_addr] + 8];
      var $25 = _read($24, $21, $19);
      HEAP[$n] = $25;
      _PyBuffer_Release($pbuf);
      
      
      if (HEAP[$n] < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $28 = ___errno_location();
      
      
      if (HEAP[$28] == 11) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 11;
      break;
     case 9:
      var $33 = HEAP[_PyExc_IOError];
      var $34 = _PyErr_SetFromErrno($33);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 10:
      var $35 = HEAP[$n];
      var $36 = _PyLong_FromSsize_t($35);
      HEAP[$0] = $36;
      __label__ = 11;
      break;
     case 11:
      var $37 = HEAP[$0];
      HEAP[$retval] = $37;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _new_buffersize($self, $currentsize) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 128;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 128);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $currentsize_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $pos = __stackBase__ + 16;
      var $end = __stackBase__ + 24;
      var $st = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$currentsize_addr] = $currentsize;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      var $4 = ___01fstat64_($3, $st);
      
      if ($4 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      var $7 = HEAP[$st + 44];
      HEAP[$end] = $7;
      
      
      var $10 = HEAP[HEAP[$self_addr] + 8];
      var $11 = ___01lseek64_($10, 0, 1);
      HEAP[$pos] = $11;
      
      
      if (HEAP[$end] > 8191) {
        __label__ = 2;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 2:
      
      
      
      if (HEAP[$end] >= HEAP[$pos]) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      if (HEAP[$pos] >= 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      
      
      
      var $26 = (HEAP[$end] & 4294967295) + HEAP[$currentsize_addr] - (HEAP[$pos] & 4294967295) + 1;
      HEAP[$0] = $26;
      __label__ = 10;
      break;
     case 5:
      
      
      if (HEAP[$currentsize_addr] > 8192) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      if (HEAP[$currentsize_addr] <= 524288) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      var $33 = HEAP[$currentsize_addr] + HEAP[$currentsize_addr];
      HEAP[$0] = $33;
      __label__ = 10;
      break;
     case 8:
      
      var $35 = HEAP[$currentsize_addr] + 524288;
      HEAP[$0] = $35;
      __label__ = 10;
      break;
     case 9:
      
      var $37 = HEAP[$currentsize_addr] + 8192;
      HEAP[$0] = $37;
      __label__ = 10;
      break;
     case 10:
      var $38 = HEAP[$0];
      HEAP[$retval] = $38;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_readall($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $result = __stackBase__ + 12;
      var $total = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $newsize = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$total] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 33;
      break;
     case 2:
      var $6 = _PyString_FromStringAndSize(0, 8192);
      HEAP[$result] = $6;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 33;
      break;
     case 4:
      var $9 = HEAP[$total];
      var $10 = HEAP[$self_addr];
      var $11 = _new_buffersize($10, $9);
      HEAP[$newsize] = $11;
      
      
      if (HEAP[$newsize] < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      if (HEAP[$newsize] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      var $16 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($16, __str24141);
      var $17 = HEAP[$result];
      
      
      var $20 = HEAP[$17] - 1;
      var $21 = $17;
      HEAP[$21] = $20;
      
      
      
      if (HEAP[$17] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $30 = HEAP[$result];
      FUNCTION_TABLE[$29]($30);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = 0;
      __label__ = 33;
      break;
     case 9:
      
      
      
      
      
      
      if (HEAP[HEAP[$result] + 8] < HEAP[$newsize]) {
        __label__ = 10;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 10:
      var $37 = HEAP[$newsize];
      var $38 = __PyString_Resize($result, $37);
      
      if ($38 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 11:
      
      
      if (HEAP[$total] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 12:
      var $42 = HEAP[$result];
      
      
      var $45 = HEAP[$42] - 1;
      var $46 = $42;
      HEAP[$46] = $45;
      
      
      
      if (HEAP[$42] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $55 = HEAP[$result];
      FUNCTION_TABLE[$54]($55);
      __label__ = 14;
      break;
     case 14:
      HEAP[$0] = 0;
      __label__ = 33;
      break;
     case 15:
      _PyErr_Clear();
      __label__ = 27;
      break;
     case 16:
      var $56 = ___errno_location();
      HEAP[$56] = 0;
      
      
      var $59 = HEAP[$newsize] - HEAP[$total];
      
      
      
      
      
      var $65 = HEAP[$result] + 20 + HEAP[$total];
      
      
      var $68 = HEAP[HEAP[$self_addr] + 8];
      var $69 = _read($68, $65, $59);
      HEAP[$n] = $69;
      
      
      if (HEAP[$n] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 18:
      
      
      if (HEAP[$total] > 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      var $76 = ___errno_location();
      
      
      if (HEAP[$76] == 11) {
        __label__ = 20;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 20:
      var $79 = HEAP[$result];
      
      
      var $82 = HEAP[$79] - 1;
      var $83 = $79;
      HEAP[$83] = $82;
      
      
      
      if (HEAP[$79] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $91 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $92 = HEAP[$result];
      FUNCTION_TABLE[$91]($92);
      __label__ = 22;
      break;
     case 22:
      
      var $94 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $94;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 33;
      break;
     case 23:
      var $95 = HEAP[$result];
      
      
      var $98 = HEAP[$95] - 1;
      var $99 = $95;
      HEAP[$99] = $98;
      
      
      
      if (HEAP[$95] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $107 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $108 = HEAP[$result];
      FUNCTION_TABLE[$107]($108);
      __label__ = 25;
      break;
     case 25:
      var $109 = HEAP[_PyExc_IOError];
      var $110 = _PyErr_SetFromErrno($109);
      HEAP[$0] = 0;
      __label__ = 33;
      break;
     case 26:
      
      
      var $113 = HEAP[$total] + HEAP[$n];
      HEAP[$total] = $113;
      __label__ = 4;
      break;
     case 27:
      
      
      
      
      
      
      if (HEAP[HEAP[$result] + 8] > HEAP[$total]) {
        __label__ = 28;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 28:
      var $120 = HEAP[$total];
      var $121 = __PyString_Resize($result, $120);
      
      if ($121 < 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 29:
      var $123 = HEAP[$result];
      
      
      var $126 = HEAP[$123] - 1;
      var $127 = $123;
      HEAP[$127] = $126;
      
      
      
      if (HEAP[$123] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      
      
      
      
      var $135 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $136 = HEAP[$result];
      FUNCTION_TABLE[$135]($136);
      __label__ = 31;
      break;
     case 31:
      HEAP[$0] = 0;
      __label__ = 33;
      break;
     case 32:
      var $137 = HEAP[$result];
      HEAP[$0] = $137;
      __label__ = 33;
      break;
     case 33:
      var $138 = HEAP[$0];
      HEAP[$retval] = $138;
      __label__ = 34;
      break;
     case 34:
      var $retval33 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval33;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $ptr = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $size = __stackBase__ + 24;
      var $bytes = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$size] = -1;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 22;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 31 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str22139);
      HEAP[$0] = $13;
      __label__ = 22;
      break;
     case 4:
      var $14 = HEAP[$args_addr];
      var $15 = __PyArg_ParseTuple_SizeT($14, __str25142, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $size, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 6:
      
      
      if (HEAP[$size] < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      var $19 = HEAP[$self_addr];
      var $20 = _fileio_readall($19);
      HEAP[$0] = $20;
      __label__ = 22;
      break;
     case 8:
      var $21 = HEAP[$size];
      var $22 = _PyString_FromStringAndSize(0, $21);
      HEAP[$bytes] = $22;
      
      
      if (HEAP[$bytes] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 10:
      
      
      
      var $28 = HEAP[$bytes] + 20;
      HEAP[$ptr] = $28;
      var $29 = ___errno_location();
      HEAP[$29] = 0;
      var $30 = HEAP[$size];
      
      
      var $33 = HEAP[HEAP[$self_addr] + 8];
      var $34 = HEAP[$ptr];
      var $35 = _read($33, $34, $30);
      HEAP[$n] = $35;
      
      
      if (HEAP[$n] < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 11:
      var $38 = HEAP[$bytes];
      
      
      var $41 = HEAP[$38] - 1;
      var $42 = $38;
      HEAP[$42] = $41;
      
      
      
      if (HEAP[$38] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $50 = HEAP[HEAP[HEAP[$bytes] + 4] + 24];
      var $51 = HEAP[$bytes];
      FUNCTION_TABLE[$50]($51);
      __label__ = 13;
      break;
     case 13:
      var $52 = ___errno_location();
      
      
      if (HEAP[$52] == 11) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      var $56 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $56;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 22;
      break;
     case 15:
      var $57 = HEAP[_PyExc_IOError];
      var $58 = _PyErr_SetFromErrno($57);
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 16:
      
      
      
      if (HEAP[$n] != HEAP[$size]) {
        __label__ = 17;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 17:
      var $62 = HEAP[$n];
      var $63 = __PyString_Resize($bytes, $62);
      
      if ($63 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 18:
      var $65 = HEAP[$bytes];
      
      
      var $68 = HEAP[$65] - 1;
      var $69 = $65;
      HEAP[$69] = $68;
      
      
      
      if (HEAP[$65] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $77 = HEAP[HEAP[HEAP[$bytes] + 4] + 24];
      var $78 = HEAP[$bytes];
      FUNCTION_TABLE[$77]($78);
      __label__ = 20;
      break;
     case 20:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 21:
      var $79 = HEAP[$bytes];
      HEAP[$0] = $79;
      __label__ = 22;
      break;
     case 22:
      var $80 = HEAP[$0];
      HEAP[$retval] = $80;
      __label__ = 23;
      break;
     case 23:
      var $retval22 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 72;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 72);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $pbuf = __stackBase__ + 16;
      var $n = __stackBase__ + 68;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 11;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $13 = _err_mode(__str26143);
      HEAP[$0] = $13;
      __label__ = 11;
      break;
     case 4:
      var $14 = HEAP[$args_addr];
      var $15 = __PyArg_ParseTuple_SizeT($14, __str27144, allocate([ $pbuf, 0, 0, 0 ], [ "%struct.Py_buffer*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($15 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 6:
      var $17 = ___errno_location();
      HEAP[$17] = 0;
      
      var $19 = HEAP[$pbuf + 8];
      
      var $21 = HEAP[$pbuf];
      
      
      var $24 = HEAP[HEAP[$self_addr] + 8];
      var $25 = _write($24, $21, $19);
      HEAP[$n] = $25;
      _PyBuffer_Release($pbuf);
      
      
      if (HEAP[$n] < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      var $28 = ___errno_location();
      
      
      if (HEAP[$28] == 11) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 11;
      break;
     case 9:
      var $33 = HEAP[_PyExc_IOError];
      var $34 = _PyErr_SetFromErrno($33);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 10:
      var $35 = HEAP[$n];
      var $36 = _PyLong_FromSsize_t($35);
      HEAP[$0] = $36;
      __label__ = 11;
      break;
     case 11:
      var $37 = HEAP[$0];
      HEAP[$retval] = $37;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _portable_lseek($fd, $posobj, $whence) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $fd_addr = __stackBase__;
      var $posobj_addr = __stackBase__ + 4;
      var $whence_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $pos = __stackBase__ + 20;
      var $res = __stackBase__ + 28;
      
      HEAP[$fd_addr] = $fd;
      HEAP[$posobj_addr] = $posobj;
      HEAP[$whence_addr] = $whence;
      
      
      if (HEAP[$posobj_addr] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$pos] = 0;
      __label__ = 7;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$posobj_addr] + 4] == _PyFloat_Type) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      var $9 = HEAP[HEAP[$posobj_addr] + 4];
      var $10 = _PyType_IsSubtype($9, _PyFloat_Type);
      
      if ($10 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      var $12 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($12, __str28145);
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 5:
      var $13 = HEAP[$posobj_addr];
      var $14 = _PyLong_AsLongLong($13);
      HEAP[$pos] = $14;
      var $15 = _PyErr_Occurred();
      
      if ($15 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 7:
      var $17 = HEAP[$fd_addr];
      var $18 = HEAP[$pos];
      var $19 = HEAP[$whence_addr];
      var $20 = ___01lseek64_($17, $18, $19);
      HEAP[$res] = $20;
      
      
      if (HEAP[$res] < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $23 = HEAP[_PyExc_IOError];
      var $24 = _PyErr_SetFromErrno($23);
      HEAP[$0] = $24;
      __label__ = 10;
      break;
     case 9:
      var $25 = HEAP[$res];
      var $26 = _PyLong_FromLongLong($25);
      HEAP[$0] = $26;
      __label__ = 10;
      break;
     case 10:
      var $27 = HEAP[$0];
      HEAP[$retval] = $27;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $posobj = __stackBase__ + 16;
      var $whence = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$whence] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 5;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = __PyArg_ParseTuple_SizeT($6, __str29146, allocate([ $posobj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 4:
      var $9 = HEAP[$whence];
      var $10 = HEAP[$posobj];
      
      
      var $13 = HEAP[HEAP[$self_addr] + 8];
      var $14 = _portable_lseek($13, $10, $9);
      HEAP[$0] = $14;
      __label__ = 5;
      break;
     case 5:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_tell($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[HEAP[$self_addr] + 8];
      var $9 = _portable_lseek($8, 0, 1);
      HEAP[$0] = $9;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $posobj = __stackBase__ + 16;
      var $pos = __stackBase__ + 20;
      var $ret = __stackBase__ + 28;
      var $fd = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$posobj] = 0;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$fd] = $3;
      
      
      if (HEAP[$fd] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $6 = _err_closed();
      HEAP[$0] = $6;
      __label__ = 21;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 30 >>> 31 & 1) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $14 = _err_mode(__str26143);
      HEAP[$0] = $14;
      __label__ = 21;
      break;
     case 4:
      var $15 = HEAP[$args_addr];
      var $16 = __PyArg_ParseTuple_SizeT($15, __str30147, allocate([ $posobj, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($16 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 6:
      
      
      if (HEAP[$posobj] == __Py_NoneStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      var $22 = HEAP[$fd];
      var $23 = _portable_lseek($22, 0, 1);
      HEAP[$posobj] = $23;
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 10:
      __label__ = 12;
      break;
     case 11:
      
      
      
      var $29 = HEAP[HEAP[$posobj]] + 1;
      var $30 = HEAP[$posobj];
      HEAP[$30] = $29;
      __label__ = 12;
      break;
     case 12:
      var $31 = HEAP[$posobj];
      var $32 = _PyLong_AsLongLong($31);
      HEAP[$pos] = $32;
      var $33 = _PyErr_Occurred();
      
      if ($33 != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 13:
      var $35 = HEAP[$posobj];
      
      
      var $38 = HEAP[$35] - 1;
      var $39 = $35;
      HEAP[$39] = $38;
      
      
      
      if (HEAP[$35] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $48 = HEAP[$posobj];
      FUNCTION_TABLE[$47]($48);
      __label__ = 15;
      break;
     case 15:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 16:
      var $49 = ___errno_location();
      HEAP[$49] = 0;
      var $50 = HEAP[$fd];
      var $51 = HEAP[$pos];
      var $52 = ___01ftruncate64_($50, $51);
      HEAP[$ret] = $52;
      
      
      if (HEAP[$ret] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      var $55 = HEAP[$posobj];
      
      
      var $58 = HEAP[$55] - 1;
      var $59 = $55;
      HEAP[$59] = $58;
      
      
      
      if (HEAP[$55] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $67 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $68 = HEAP[$posobj];
      FUNCTION_TABLE[$67]($68);
      __label__ = 19;
      break;
     case 19:
      var $69 = HEAP[_PyExc_IOError];
      var $70 = _PyErr_SetFromErrno($69);
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 20:
      var $71 = HEAP[$posobj];
      HEAP[$0] = $71;
      __label__ = 21;
      break;
     case 21:
      var $72 = HEAP[$0];
      HEAP[$retval] = $72;
      __label__ = 22;
      break;
     case 22:
      var $retval21 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _mode_string($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 31 >>> 31 & 1) != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 12] << 30 >>> 31 & 1) != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      HEAP[$0] = __str31148;
      __label__ = 5;
      break;
     case 3:
      HEAP[$0] = __str32149;
      __label__ = 5;
      break;
     case 4:
      HEAP[$0] = __str33150;
      __label__ = 5;
      break;
     case 5:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_repr($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $nameobj = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $repr = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _PyString_FromFormat(__str34151, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $5;
      __label__ = 13;
      break;
     case 2:
      
      var $7 = HEAP[$self_addr];
      var $8 = _PyObject_GetAttrString($7, __str18135);
      HEAP[$nameobj] = $8;
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      var $11 = HEAP[_PyExc_AttributeError];
      var $12 = _PyErr_ExceptionMatches($11);
      
      if ($12 != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      _PyErr_Clear();
      var $14 = HEAP[$self_addr];
      var $15 = _mode_string($14);
      
      
      var $18 = HEAP[HEAP[$self_addr] + 8];
      var $19 = _PyString_FromFormat(__str35152, allocate([ $18, 0, 0, 0, $15, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $19;
      __label__ = 12;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 13;
      break;
     case 6:
      var $20 = HEAP[$nameobj];
      var $21 = _PyObject_Repr($20);
      HEAP[$repr] = $21;
      
      
      
      var $25 = HEAP[HEAP[$nameobj]] - 1;
      
      var $27 = HEAP[$nameobj];
      HEAP[$27] = $25;
      
      
      
      
      if (HEAP[HEAP[$nameobj]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $36 = HEAP[HEAP[HEAP[$nameobj] + 4] + 24];
      var $37 = HEAP[$nameobj];
      FUNCTION_TABLE[$36]($37);
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$repr] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 13;
      break;
     case 10:
      var $40 = HEAP[$self_addr];
      var $41 = _mode_string($40);
      
      
      
      var $45 = HEAP[$repr] + 20;
      var $46 = _PyString_FromFormat(__str36153, allocate([ $45, 0, 0, 0, $41, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $46;
      
      
      
      var $50 = HEAP[HEAP[$repr]] - 1;
      
      var $52 = HEAP[$repr];
      HEAP[$52] = $50;
      
      
      
      
      if (HEAP[HEAP[$repr]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $61 = HEAP[HEAP[HEAP[$repr] + 4] + 24];
      var $62 = HEAP[$repr];
      FUNCTION_TABLE[$61]($62);
      __label__ = 12;
      break;
     case 12:
      var $63 = HEAP[$res];
      HEAP[$0] = $63;
      __label__ = 13;
      break;
     case 13:
      var $64 = HEAP[$0];
      HEAP[$retval] = $64;
      __label__ = 14;
      break;
     case 14:
      var $retval13 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _fileio_isatty($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $res = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _err_closed();
      HEAP[$0] = $5;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[HEAP[$self_addr] + 8];
      var $9 = _isatty($8);
      HEAP[$res] = $9;
      var $10 = HEAP[$res];
      var $11 = _PyBool_FromLong($10);
      HEAP[$0] = $11;
      __label__ = 3;
      break;
     case 3:
      var $12 = HEAP[$0];
      HEAP[$retval] = $12;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_closed($self, $closure) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $closure_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$closure_addr] = $closure;
      
      
      
      
      var $5 = HEAP[HEAP[$self_addr] + 8] < 0;
      var $6 = _PyBool_FromLong($5);
      HEAP[$0] = $6;
      var $7 = HEAP[$0];
      HEAP[$retval] = $7;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_closefd($self, $closure) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $closure_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$closure_addr] = $closure;
      
      
      
      
      
      
      var $7 = HEAP[HEAP[$self_addr] + 12] << 27 >>> 31 & 1;
      var $8 = _PyBool_FromLong($7);
      HEAP[$0] = $8;
      var $9 = HEAP[$0];
      HEAP[$retval] = $9;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _get_mode($self, $closure) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $closure_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$closure_addr] = $closure;
      var $1 = HEAP[$self_addr];
      var $2 = _mode_string($1);
      var $3 = _PyUnicodeUCS2_FromString($2);
      HEAP[$0] = $3;
      var $4 = HEAP[$0];
      HEAP[$retval] = $4;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_unsupported($message) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $message;
      var $1 = HEAP[__PyIO_unsupported_operation];
      var $2 = HEAP[__stackBase__];
      _PyErr_SetString($1, $2);
      HEAP[$0] = 0;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _iobase_unsupported(__str181);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_tell($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = __PyObject_CallMethod_SizeT($1, __str181, __str1182, allocate([ 0, 0, 0, 0, 1, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $2;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _iobase_unsupported(__str2183);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_flush($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = _PyObject_HasAttrString($1, __str3184);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $4 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($4, __str4185);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      var $6 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $6;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      var $7 = HEAP[$0];
      HEAP[$retval] = $7;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_closed($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $res = __stackBase__ + 12;
      var $closed = __stackBase__ + 16;
      
      HEAP[__stackBase__] = $self;
      var $1 = HEAP[__PyIO_str_closed];
      var $2 = HEAP[__stackBase__];
      var $3 = _PyObject_GetAttr($2, $1);
      HEAP[$res] = $3;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      var $6 = HEAP[$res];
      var $7 = _PyObject_IsTrue($6);
      HEAP[$closed] = $7;
      
      
      
      var $11 = HEAP[HEAP[$res]] - 1;
      
      var $13 = HEAP[$res];
      HEAP[$13] = $11;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $22 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $23 = HEAP[$res];
      FUNCTION_TABLE[$22]($23);
      __label__ = 4;
      break;
     case 4:
      var $24 = HEAP[$closed];
      HEAP[$0] = $24;
      __label__ = 5;
      break;
     case 5:
      var $25 = HEAP[$0];
      HEAP[$retval] = $25;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_closed_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      var $1 = HEAP[$self_addr];
      var $2 = _PyObject_HasAttrString($1, __str3184);
      var $3 = _PyBool_FromLong($2);
      HEAP[$0] = $3;
      var $4 = HEAP[$0];
      HEAP[$retval] = $4;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_check_closed($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = _iobase_closed($1);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $4 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($4, __str4185);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      if (HEAP[$args_addr] == __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 4:
      
      var $8 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $8;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 5:
      var $9 = HEAP[$0];
      HEAP[$retval] = $9;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_close($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = _PyObject_HasAttrString($1, __str3184);
      
      if ($2 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      var $5 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $5;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 8;
      break;
     case 2:
      var $6 = HEAP[__PyIO_str_flush];
      var $7 = HEAP[$self_addr];
      var $8 = _PyObject_CallMethodObjArgs($7, $6, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $8;
      var $9 = HEAP[$self_addr];
      var $10 = _PyObject_SetAttrString($9, __str3184, __Py_TrueStruct);
      
      
      if (HEAP[$res] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 8;
      break;
     case 4:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      
      var $18 = HEAP[HEAP[$res]] - 1;
      
      var $20 = HEAP[$res];
      HEAP[$20] = $18;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $30 = HEAP[$res];
      FUNCTION_TABLE[$29]($30);
      __label__ = 7;
      break;
     case 7:
      
      var $32 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $32;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 8;
      break;
     case 8:
      var $33 = HEAP[$0];
      HEAP[$retval] = $33;
      __label__ = 9;
      break;
     case 9:
      var $retval8 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_finalize($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $res = __stackBase__ + 12;
      var $tp = __stackBase__ + 16;
      var $v = __stackBase__ + 20;
      var $tb = __stackBase__ + 24;
      var $closed = __stackBase__ + 28;
      var $is_zombie = __stackBase__ + 32;
      var $refcnt = __stackBase__ + 36;
      
      HEAP[$self_addr] = $self;
      HEAP[$closed] = 1;
      
      
      
      
      var $5 = HEAP[HEAP[$self_addr]] == 0;
      HEAP[$is_zombie] = $5;
      
      
      if (HEAP[$is_zombie] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      
      
      
      var $11 = HEAP[HEAP[$self_addr]] + 1;
      
      var $13 = HEAP[$self_addr];
      HEAP[$13] = $11;
      __label__ = 2;
      break;
     case 2:
      _PyErr_Fetch($tp, $v, $tb);
      var $14 = HEAP[__PyIO_str_closed];
      var $15 = HEAP[$self_addr];
      var $16 = _PyObject_GetAttr($15, $14);
      HEAP[$res] = $16;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      _PyErr_Clear();
      __label__ = 8;
      break;
     case 4:
      var $19 = HEAP[$res];
      var $20 = _PyObject_IsTrue($19);
      HEAP[$closed] = $20;
      
      
      
      var $24 = HEAP[HEAP[$res]] - 1;
      
      var $26 = HEAP[$res];
      HEAP[$26] = $24;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $35 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $36 = HEAP[$res];
      FUNCTION_TABLE[$35]($36);
      __label__ = 6;
      break;
     case 6:
      
      var $38 = HEAP[$closed] == -1;
      if ($38) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      _PyErr_Clear();
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$closed] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 9:
      var $41 = HEAP[__PyIO_str_close];
      var $42 = HEAP[$self_addr];
      var $43 = _PyObject_CallMethodObjArgs($42, $41, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $43;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      _PyErr_Clear();
      __label__ = 13;
      break;
     case 11:
      
      
      
      var $49 = HEAP[HEAP[$res]] - 1;
      
      var $51 = HEAP[$res];
      HEAP[$51] = $49;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $60 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $61 = HEAP[$res];
      FUNCTION_TABLE[$60]($61);
      __label__ = 13;
      break;
     case 13:
      var $62 = HEAP[$tb];
      var $63 = HEAP[$v];
      var $64 = HEAP[$tp];
      _PyErr_Restore($64, $63, $62);
      
      
      if (HEAP[$is_zombie] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      var $70 = HEAP[HEAP[$self_addr]] - 1;
      
      var $72 = HEAP[$self_addr];
      HEAP[$72] = $70;
      
      
      
      
      if (HEAP[HEAP[$self_addr]] != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      var $79 = HEAP[HEAP[$self_addr]];
      HEAP[$refcnt] = $79;
      
      var $81 = HEAP[$self_addr];
      HEAP[$81] = 1;
      
      var $83 = HEAP[$self_addr];
      var $84 = HEAP[$refcnt];
      HEAP[$83] = $84;
      HEAP[$0] = -1;
      __label__ = 17;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 17;
      break;
     case 17:
      var $85 = HEAP[$0];
      HEAP[$retval] = $85;
      __label__ = 18;
      break;
     case 18:
      var $retval17 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 8];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 4;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 4:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      var $2 = HEAP[$self_addr];
      var $3 = __PyIOBase_finalize($2);
      
      if ($3 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 6;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      var $11 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $11;
      
      var $13 = HEAP[$self_addr] + 8;
      HEAP[$13] = 0;
      
      
      
      var $17 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $19 = HEAP[$_py_tmp];
      HEAP[$19] = $17;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $28 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $29 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$28]($29);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 6:
      var $30 = HEAP[$0];
      HEAP[$retval] = $30;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      var $1 = HEAP[$self_addr];
      var $2 = __PyIOBase_finalize($1);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$self_addr] + 4] + 84] & 512) != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      
      
      
      var $19 = HEAP[HEAP[HEAP[$self_addr] + 4]] + 1;
      var $20 = HEAP[HEAP[$self_addr] + 4];
      HEAP[$20] = $19;
      __label__ = 3;
      break;
     case 3:
      __label__ = 12;
      break;
     case 4:
      
      
      var $23 = HEAP[$self_addr] + -12;
      HEAP[$g] = $23;
      
      
      
      
      var $28 = HEAP[HEAP[$g] + 8] == -2;
      if ($28) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      ___assert_fail(__str5186, __str6187, 291, ___PRETTY_FUNCTION___8582);
      throw "Reached an unreachable!";
     case 6:
      
      
      var $31 = HEAP[$g] + 8;
      HEAP[$31] = -2;
      
      
      
      
      
      
      
      var $39 = HEAP[HEAP[$g]];
      
      var $41 = HEAP[HEAP[$g] + 4];
      HEAP[$41] = $39;
      
      
      
      
      
      
      
      var $49 = HEAP[HEAP[$g] + 4];
      
      var $51 = HEAP[HEAP[$g]] + 4;
      HEAP[$51] = $49;
      
      
      var $54 = HEAP[$g];
      HEAP[$54] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      var $60 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($60);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      var $67 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $67;
      
      var $69 = HEAP[$self_addr] + 8;
      HEAP[$69] = 0;
      
      
      
      var $73 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $75 = HEAP[$_py_tmp];
      HEAP[$75] = $73;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $84 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $85 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$84]($85);
      __label__ = 11;
      break;
     case 11:
      
      
      
      
      
      var $91 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $93 = HEAP[$self_addr];
      FUNCTION_TABLE[$91]($93);
      __label__ = 12;
      break;
     case 12:
      __label__ = 13;
      break;
     case 13:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_seekable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $3;
      HEAP[$0] = __Py_ZeroStruct;
      var $5 = HEAP[$0];
      HEAP[$retval] = $5;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_check_seekable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $_py_tmp = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[__PyIO_str_seekable];
      var $2 = HEAP[$self_addr];
      var $3 = _PyObject_CallMethodObjArgs($2, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $3;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if (HEAP[$res] != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      var $10 = HEAP[$res];
      HEAP[$_py_tmp] = $10;
      HEAP[$res] = 0;
      
      
      
      var $14 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $16 = HEAP[$_py_tmp];
      HEAP[$16] = $14;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $26 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$25]($26);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str7188);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if (HEAP[$args_addr] == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[HEAP[$res]] - 1;
      
      var $35 = HEAP[$res];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $45 = HEAP[$res];
      FUNCTION_TABLE[$44]($45);
      __label__ = 10;
      break;
     case 10:
      var $46 = HEAP[$res];
      HEAP[$0] = $46;
      __label__ = 11;
      break;
     case 11:
      var $47 = HEAP[$0];
      HEAP[$retval] = $47;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $3;
      HEAP[$0] = __Py_ZeroStruct;
      var $5 = HEAP[$0];
      HEAP[$retval] = $5;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_check_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $_py_tmp = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[__PyIO_str_readable];
      var $2 = HEAP[$self_addr];
      var $3 = _PyObject_CallMethodObjArgs($2, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $3;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if (HEAP[$res] != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      var $10 = HEAP[$res];
      HEAP[$_py_tmp] = $10;
      HEAP[$res] = 0;
      
      
      
      var $14 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $16 = HEAP[$_py_tmp];
      HEAP[$16] = $14;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $26 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$25]($26);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str8189);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if (HEAP[$args_addr] == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[HEAP[$res]] - 1;
      
      var $35 = HEAP[$res];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $45 = HEAP[$res];
      FUNCTION_TABLE[$44]($45);
      __label__ = 10;
      break;
     case 10:
      var $46 = HEAP[$res];
      HEAP[$0] = $46;
      __label__ = 11;
      break;
     case 11:
      var $47 = HEAP[$0];
      HEAP[$retval] = $47;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      
      
      var $3 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $3;
      HEAP[$0] = __Py_ZeroStruct;
      var $5 = HEAP[$0];
      HEAP[$retval] = $5;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIOBase_check_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $_py_tmp = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[__PyIO_str_writable];
      var $2 = HEAP[$self_addr];
      var $3 = _PyObject_CallMethodObjArgs($2, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $3;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 2:
      
      
      if (HEAP[$res] != __Py_TrueStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      var $10 = HEAP[$res];
      HEAP[$_py_tmp] = $10;
      HEAP[$res] = 0;
      
      
      
      var $14 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $16 = HEAP[$_py_tmp];
      HEAP[$16] = $14;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $25 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $26 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$25]($26);
      __label__ = 6;
      break;
     case 6:
      var $27 = HEAP[_PyExc_IOError];
      _PyErr_SetString($27, __str9190);
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 7:
      
      
      if (HEAP[$args_addr] == __Py_TrueStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      
      var $33 = HEAP[HEAP[$res]] - 1;
      
      var $35 = HEAP[$res];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $45 = HEAP[$res];
      FUNCTION_TABLE[$44]($45);
      __label__ = 10;
      break;
     case 10:
      var $46 = HEAP[$res];
      HEAP[$0] = $46;
      __label__ = 11;
      break;
     case 11:
      var $47 = HEAP[$0];
      HEAP[$retval] = $47;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_enter($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = __PyIOBase_check_closed($1, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $7 = HEAP[HEAP[$self_addr]] + 1;
      
      var $9 = HEAP[$self_addr];
      HEAP[$9] = $7;
      var $10 = HEAP[$self_addr];
      HEAP[$0] = $10;
      __label__ = 3;
      break;
     case 3:
      var $11 = HEAP[$0];
      HEAP[$retval] = $11;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_exit($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[__PyIO_str_close];
      var $2 = HEAP[$self_addr];
      var $3 = _PyObject_CallMethodObjArgs($2, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $3;
      var $4 = HEAP[$0];
      HEAP[$retval] = $4;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_fileno($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _iobase_unsupported(__str10191);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_isatty($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$self_addr];
      var $2 = __PyIOBase_check_closed($1, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $6 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $6;
      HEAP[$0] = __Py_ZeroStruct;
      __label__ = 3;
      break;
     case 3:
      var $8 = HEAP[$0];
      HEAP[$retval] = $8;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 68;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 68);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_62 = __stackBase__ + 12;
      var $iftmp_54 = __stackBase__ + 16;
      var $iftmp_51 = __stackBase__ + 20;
      var $0 = __stackBase__ + 24;
      var $limit = __stackBase__ + 28;
      var $has_peek = __stackBase__ + 32;
      var $buffer = __stackBase__ + 36;
      var $result = __stackBase__ + 40;
      var $old_size = __stackBase__ + 44;
      var $nreadahead = __stackBase__ + 48;
      var $b = __stackBase__ + 52;
      var $readahead = __stackBase__ + 56;
      var $n = __stackBase__ + 60;
      var $buf = __stackBase__ + 64;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$limit] = -1;
      HEAP[$has_peek] = 0;
      HEAP[$old_size] = -1;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str11192, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $limit, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 2:
      var $4 = HEAP[$self_addr];
      var $5 = _PyObject_HasAttrString($4, __str12193);
      
      if ($5 != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$has_peek] = 1;
      __label__ = 4;
      break;
     case 4:
      var $7 = _PyByteArray_FromStringAndSize(0, 0);
      HEAP[$buffer] = $7;
      
      
      if (HEAP[$buffer] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 6:
      __label__ = 56;
      break;
     case 7:
      HEAP[$nreadahead] = 1;
      
      
      if (HEAP[$has_peek] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 8:
      var $12 = HEAP[$self_addr];
      var $13 = __PyObject_CallMethod_SizeT($12, __str12193, __str13194, allocate([ 1, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$readahead] = $13;
      
      
      if (HEAP[$readahead] == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$readahead] + 4] + 84] & 134217728) == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 10:
      
      
      
      
      var $27 = HEAP[HEAP[HEAP[$readahead] + 4] + 12];
      var $28 = HEAP[_PyExc_IOError];
      var $29 = _PyErr_Format($28, __str14195, allocate([ $27, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $33 = HEAP[HEAP[$readahead]] - 1;
      
      var $35 = HEAP[$readahead];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$readahead]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$readahead] + 4] + 24];
      var $45 = HEAP[$readahead];
      FUNCTION_TABLE[$44]($45);
      __label__ = 12;
      break;
     case 12:
      __label__ = 70;
      break;
     case 13:
      
      
      
      
      
      if (HEAP[HEAP[$readahead] + 8] > 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 14:
      HEAP[$n] = 0;
      
      
      
      var $54 = HEAP[$readahead] + 20;
      HEAP[$buf] = $54;
      
      
      if (HEAP[$limit] >= 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 15:
      
      
      
      
      
      
      if (HEAP[HEAP[$readahead] + 8] <= HEAP[$n]) {
        __label__ = 19;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      if (HEAP[$n] >= HEAP[$limit]) {
        __label__ = 19;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 17:
      
      
      
      
      
      var $71 = HEAP[HEAP[$buf] + HEAP[$n]] == 10;
      
      var $73 = HEAP[$n] + 1;
      HEAP[$n] = $73;
      
      if ($71 != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      __label__ = 15;
      break;
     case 19:
      __label__ = 23;
      break;
     case 20:
      
      
      
      
      
      
      if (HEAP[HEAP[$readahead] + 8] <= HEAP[$n]) {
        __label__ = 23;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      
      
      
      var $85 = HEAP[HEAP[$buf] + HEAP[$n]] == 10;
      
      var $87 = HEAP[$n] + 1;
      HEAP[$n] = $87;
      
      if ($85 != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      __label__ = 20;
      break;
     case 23:
      var $88 = HEAP[$n];
      HEAP[$nreadahead] = $88;
      __label__ = 24;
      break;
     case 24:
      
      
      
      var $92 = HEAP[HEAP[$readahead]] - 1;
      
      var $94 = HEAP[$readahead];
      HEAP[$94] = $92;
      
      
      
      
      if (HEAP[HEAP[$readahead]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $103 = HEAP[HEAP[HEAP[$readahead] + 4] + 24];
      var $104 = HEAP[$readahead];
      FUNCTION_TABLE[$103]($104);
      __label__ = 26;
      break;
     case 26:
      var $105 = HEAP[$self_addr];
      var $106 = HEAP[$nreadahead];
      var $107 = __PyObject_CallMethod_SizeT($105, __str15196, __str16197, allocate([ $106, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$b] = $107;
      
      
      if (HEAP[$b] == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$b] + 4] + 84] & 134217728) == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 28:
      
      
      
      
      var $121 = HEAP[HEAP[HEAP[$b] + 4] + 12];
      var $122 = HEAP[_PyExc_IOError];
      var $123 = _PyErr_Format($122, __str17198, allocate([ $121, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $127 = HEAP[HEAP[$b]] - 1;
      
      var $129 = HEAP[$b];
      HEAP[$129] = $127;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $138 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $139 = HEAP[$b];
      FUNCTION_TABLE[$138]($139);
      __label__ = 30;
      break;
     case 30:
      __label__ = 70;
      break;
     case 31:
      
      
      
      
      
      if (HEAP[HEAP[$b] + 8] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 32:
      
      
      
      var $148 = HEAP[HEAP[$b]] - 1;
      
      var $150 = HEAP[$b];
      HEAP[$150] = $148;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      
      
      
      
      var $159 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $160 = HEAP[$b];
      FUNCTION_TABLE[$159]($160);
      __label__ = 34;
      break;
     case 34:
      __label__ = 58;
      break;
     case 35:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 36;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 36:
      
      
      var $167 = HEAP[HEAP[$buffer] + 4];
      var $168 = _PyType_IsSubtype($167, _PyByteArray_Type);
      
      if ($168 == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      ___assert_fail(__str18199, __str6187, 519, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 38:
      
      
      
      var $173 = HEAP[HEAP[$buffer] + 8];
      HEAP[$old_size] = $173;
      
      
      
      
      
      var $179 = HEAP[HEAP[$b] + 8] + HEAP[$old_size];
      var $180 = HEAP[$buffer];
      var $181 = _PyByteArray_Resize($180, $179);
      
      
      
      var $185 = HEAP[HEAP[$b] + 8];
      
      
      
      var $189 = HEAP[$b] + 20;
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      
      var $196 = HEAP[HEAP[$buffer] + 4];
      var $197 = _PyType_IsSubtype($196, _PyByteArray_Type);
      
      if ($197 == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      ___assert_fail(__str18199, __str6187, 521, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 41:
      
      
      
      
      
      if (HEAP[HEAP[$buffer] + 8] != 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 42:
      
      
      
      var $207 = HEAP[HEAP[$buffer] + 20];
      HEAP[$iftmp_51] = $207;
      __label__ = 44;
      break;
     case 43:
      HEAP[$iftmp_51] = __PyByteArray_empty_string;
      __label__ = 44;
      break;
     case 44:
      
      
      var $210 = HEAP[$iftmp_51] + HEAP[$old_size];
      _llvm_memcpy_p0i8_p0i8_i32($210, $189, $185, 1, 0);
      
      
      
      var $214 = HEAP[HEAP[$b]] - 1;
      
      var $216 = HEAP[$b];
      HEAP[$216] = $214;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      
      
      
      
      var $225 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $226 = HEAP[$b];
      FUNCTION_TABLE[$225]($226);
      __label__ = 46;
      break;
     case 46:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 47;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 47:
      
      
      var $233 = HEAP[HEAP[$buffer] + 4];
      var $234 = _PyType_IsSubtype($233, _PyByteArray_Type);
      
      if ($234 == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      ___assert_fail(__str18199, __str6187, 526, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 49:
      
      
      
      
      
      if (HEAP[HEAP[$buffer] + 8] != 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      
      
      var $244 = HEAP[HEAP[$buffer] + 20];
      HEAP[$iftmp_54] = $244;
      __label__ = 52;
      break;
     case 51:
      HEAP[$iftmp_54] = __PyByteArray_empty_string;
      __label__ = 52;
      break;
     case 52:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 53;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 53:
      
      
      var $251 = HEAP[HEAP[$buffer] + 4];
      var $252 = _PyType_IsSubtype($251, _PyByteArray_Type);
      
      if ($252 == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      ___assert_fail(__str18199, __str6187, 526, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 55:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$iftmp_54] + (HEAP[HEAP[$buffer] + 8] - 1)] == 10) {
        __label__ = 58;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 56:
      
      
      if (HEAP[$limit] < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 57:
      
      
      
      
      
      
      if (HEAP[HEAP[$buffer] + 8] < HEAP[$limit]) {
        __label__ = 7;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 59;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 59:
      
      
      var $277 = HEAP[HEAP[$buffer] + 4];
      var $278 = _PyType_IsSubtype($277, _PyByteArray_Type);
      
      if ($278 == 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      ___assert_fail(__str18199, __str6187, 531, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 61:
      
      
      
      var $283 = HEAP[HEAP[$buffer] + 8];
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] != _PyByteArray_Type) {
        __label__ = 62;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 62:
      
      
      var $290 = HEAP[HEAP[$buffer] + 4];
      var $291 = _PyType_IsSubtype($290, _PyByteArray_Type);
      
      if ($291 == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      ___assert_fail(__str18199, __str6187, 530, ___PRETTY_FUNCTION___8823);
      throw "Reached an unreachable!";
     case 64:
      
      
      
      
      
      if (HEAP[HEAP[$buffer] + 8] != 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      
      
      
      var $301 = HEAP[HEAP[$buffer] + 20];
      HEAP[$iftmp_62] = $301;
      __label__ = 67;
      break;
     case 66:
      HEAP[$iftmp_62] = __PyByteArray_empty_string;
      __label__ = 67;
      break;
     case 67:
      var $302 = HEAP[$iftmp_62];
      var $303 = _PyString_FromStringAndSize($302, $283);
      HEAP[$result] = $303;
      
      
      
      var $307 = HEAP[HEAP[$buffer]] - 1;
      
      var $309 = HEAP[$buffer];
      HEAP[$309] = $307;
      
      
      
      
      if (HEAP[HEAP[$buffer]] == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      
      
      
      
      var $318 = HEAP[HEAP[HEAP[$buffer] + 4] + 24];
      var $319 = HEAP[$buffer];
      FUNCTION_TABLE[$318]($319);
      __label__ = 69;
      break;
     case 69:
      var $320 = HEAP[$result];
      HEAP[$0] = $320;
      __label__ = 73;
      break;
     case 70:
      
      
      
      var $324 = HEAP[HEAP[$buffer]] - 1;
      
      var $326 = HEAP[$buffer];
      HEAP[$326] = $324;
      
      
      
      
      if (HEAP[HEAP[$buffer]] == 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      
      
      
      
      var $335 = HEAP[HEAP[HEAP[$buffer] + 4] + 24];
      var $336 = HEAP[$buffer];
      FUNCTION_TABLE[$335]($336);
      __label__ = 72;
      break;
     case 72:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 73:
      var $337 = HEAP[$0];
      HEAP[$retval] = $337;
      __label__ = 74;
      break;
     case 74:
      var $retval73 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval73;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_iter($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      var $1 = HEAP[$self_addr];
      var $2 = __PyIOBase_check_closed($1, __Py_TrueStruct);
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $7 = HEAP[HEAP[$self_addr]] + 1;
      
      var $9 = HEAP[$self_addr];
      HEAP[$9] = $7;
      var $10 = HEAP[$self_addr];
      HEAP[$0] = $10;
      __label__ = 3;
      break;
     case 3:
      var $11 = HEAP[$0];
      HEAP[$retval] = $11;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $line = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      var $1 = HEAP[__PyIO_str_readline];
      var $2 = HEAP[__stackBase__];
      var $3 = _PyObject_CallMethodObjArgs($2, $1, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$line] = $3;
      
      
      if (HEAP[$line] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 2:
      var $6 = HEAP[$line];
      var $7 = _PyObject_Size($6);
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      
      var $12 = HEAP[HEAP[$line]] - 1;
      
      var $14 = HEAP[$line];
      HEAP[$14] = $12;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $24 = HEAP[$line];
      FUNCTION_TABLE[$23]($24);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 6:
      var $25 = HEAP[$line];
      HEAP[$0] = $25;
      __label__ = 7;
      break;
     case 7:
      var $26 = HEAP[$0];
      HEAP[$retval] = $26;
      __label__ = 8;
      break;
     case 8:
      var $retval7 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_readlines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $hint = __stackBase__ + 16;
      var $length = __stackBase__ + 20;
      var $result = __stackBase__ + 24;
      var $ret = __stackBase__ + 28;
      var $line = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$hint] = -1;
      HEAP[$length] = 0;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str19200, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $hint, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 28;
      break;
     case 2:
      var $4 = _PyList_New(0);
      HEAP[$result] = $4;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 28;
      break;
     case 4:
      
      
      if (HEAP[$hint] <= 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 5:
      var $9 = HEAP[$result];
      var $10 = HEAP[$self_addr];
      var $11 = __PyObject_CallMethod_SizeT($9, __str20201, __str21202, allocate([ $10, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$ret] = $11;
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      var $17 = HEAP[HEAP[$result]] - 1;
      
      var $19 = HEAP[$result];
      HEAP[$19] = $17;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $28 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $29 = HEAP[$result];
      FUNCTION_TABLE[$28]($29);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = 0;
      __label__ = 28;
      break;
     case 9:
      
      
      
      var $33 = HEAP[HEAP[$ret]] - 1;
      
      var $35 = HEAP[$ret];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $45 = HEAP[$ret];
      FUNCTION_TABLE[$44]($45);
      __label__ = 11;
      break;
     case 11:
      var $46 = HEAP[$result];
      HEAP[$0] = $46;
      __label__ = 28;
      break;
     case 12:
      var $47 = HEAP[$self_addr];
      var $48 = _PyIter_Next($47);
      HEAP[$line] = $48;
      
      
      if (HEAP[$line] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 13:
      var $51 = _PyErr_Occurred();
      
      if ($51 != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 14:
      
      
      
      var $56 = HEAP[HEAP[$result]] - 1;
      
      var $58 = HEAP[$result];
      HEAP[$58] = $56;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $67 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $68 = HEAP[$result];
      FUNCTION_TABLE[$67]($68);
      __label__ = 16;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 28;
      break;
     case 17:
      var $69 = HEAP[$result];
      var $70 = HEAP[$line];
      var $71 = _PyList_Append($69, $70);
      
      if ($71 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 18:
      
      
      
      var $76 = HEAP[HEAP[$line]] - 1;
      
      var $78 = HEAP[$line];
      HEAP[$78] = $76;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $87 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $88 = HEAP[$line];
      FUNCTION_TABLE[$87]($88);
      __label__ = 20;
      break;
     case 20:
      
      
      
      var $92 = HEAP[HEAP[$result]] - 1;
      
      var $94 = HEAP[$result];
      HEAP[$94] = $92;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $103 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $104 = HEAP[$result];
      FUNCTION_TABLE[$103]($104);
      __label__ = 22;
      break;
     case 22:
      HEAP[$0] = 0;
      __label__ = 28;
      break;
     case 23:
      var $105 = HEAP[$line];
      var $106 = _PyObject_Size($105);
      
      var $108 = $106 + HEAP[$length];
      HEAP[$length] = $108;
      
      
      
      var $112 = HEAP[HEAP[$line]] - 1;
      
      var $114 = HEAP[$line];
      HEAP[$114] = $112;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $123 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $124 = HEAP[$line];
      FUNCTION_TABLE[$123]($124);
      __label__ = 25;
      break;
     case 25:
      
      
      
      if (HEAP[$length] > HEAP[$hint]) {
        __label__ = 27;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      __label__ = 12;
      break;
     case 27:
      var $128 = HEAP[$result];
      HEAP[$0] = $128;
      __label__ = 28;
      break;
     case 28:
      var $129 = HEAP[$0];
      HEAP[$retval] = $129;
      __label__ = 29;
      break;
     case 29:
      var $retval28 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval28;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _iobase_writelines($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $lines = __stackBase__ + 16;
      var $iter = __stackBase__ + 20;
      var $res = __stackBase__ + 24;
      var $line = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str22203, allocate([ $lines, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 2:
      var $4 = HEAP[$self_addr];
      var $5 = __PyIOBase_check_closed($4, __Py_TrueStruct);
      
      if ($5 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 4:
      var $7 = HEAP[$lines];
      var $8 = _PyObject_GetIter($7);
      HEAP[$iter] = $8;
      
      
      if (HEAP[$iter] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 6:
      var $11 = HEAP[$iter];
      var $12 = _PyIter_Next($11);
      HEAP[$line] = $12;
      
      
      if (HEAP[$line] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      var $15 = _PyErr_Occurred();
      
      if ($15 != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 8:
      
      
      
      var $20 = HEAP[HEAP[$iter]] - 1;
      
      var $22 = HEAP[$iter];
      HEAP[$22] = $20;
      
      
      
      
      if (HEAP[HEAP[$iter]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $31 = HEAP[HEAP[HEAP[$iter] + 4] + 24];
      var $32 = HEAP[$iter];
      FUNCTION_TABLE[$31]($32);
      __label__ = 10;
      break;
     case 10:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 11:
      var $33 = HEAP[__PyIO_str_write];
      var $34 = HEAP[$self_addr];
      var $35 = HEAP[$line];
      var $36 = _PyObject_CallMethodObjArgs($34, $33, allocate([ $35, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $36;
      
      
      
      var $40 = HEAP[HEAP[$line]] - 1;
      
      var $42 = HEAP[$line];
      HEAP[$42] = $40;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $51 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $52 = HEAP[$line];
      FUNCTION_TABLE[$51]($52);
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      var $58 = HEAP[HEAP[$iter]] - 1;
      
      var $60 = HEAP[$iter];
      HEAP[$60] = $58;
      
      
      
      
      if (HEAP[HEAP[$iter]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $69 = HEAP[HEAP[HEAP[$iter] + 4] + 24];
      var $70 = HEAP[$iter];
      FUNCTION_TABLE[$69]($70);
      __label__ = 16;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 23;
      break;
     case 17:
      
      
      
      var $74 = HEAP[HEAP[$res]] - 1;
      
      var $76 = HEAP[$res];
      HEAP[$76] = $74;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $85 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $86 = HEAP[$res];
      FUNCTION_TABLE[$85]($86);
      __label__ = 19;
      break;
     case 19:
      __label__ = 6;
      break;
     case 20:
      
      
      
      var $90 = HEAP[HEAP[$iter]] - 1;
      
      var $92 = HEAP[$iter];
      HEAP[$92] = $90;
      
      
      
      
      if (HEAP[HEAP[$iter]] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $101 = HEAP[HEAP[HEAP[$iter] + 4] + 24];
      var $102 = HEAP[$iter];
      FUNCTION_TABLE[$101]($102);
      __label__ = 22;
      break;
     case 22:
      
      var $104 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $104;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 23;
      break;
     case 23:
      var $105 = HEAP[$0];
      HEAP[$retval] = $105;
      __label__ = 24;
      break;
     case 24:
      var $retval23 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _rawiobase_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      var $b = __stackBase__ + 20;
      var $res = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$n] = -1;
      var $1 = HEAP[$args_addr];
      var $2 = __PyArg_ParseTuple_SizeT($1, __str41223, allocate([ $n, 0, 0, 0 ], [ "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 2:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $6 = HEAP[$self_addr];
      var $7 = __PyObject_CallMethod_SizeT($6, __str42224, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $7;
      __label__ = 21;
      break;
     case 4:
      var $8 = HEAP[$n];
      var $9 = _PyByteArray_FromStringAndSize(0, $8);
      HEAP[$b] = $9;
      
      
      if (HEAP[$b] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 6:
      var $12 = HEAP[__PyIO_str_readinto];
      var $13 = HEAP[$self_addr];
      var $14 = HEAP[$b];
      var $15 = _PyObject_CallMethodObjArgs($13, $12, allocate([ $14, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $15;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      if (HEAP[$res] == __Py_NoneStruct) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $23 = HEAP[HEAP[$b]] - 1;
      
      var $25 = HEAP[$b];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $35 = HEAP[$b];
      FUNCTION_TABLE[$34]($35);
      __label__ = 10;
      break;
     case 10:
      var $36 = HEAP[$res];
      HEAP[$0] = $36;
      __label__ = 21;
      break;
     case 11:
      var $37 = HEAP[_PyExc_ValueError];
      var $38 = HEAP[$res];
      var $39 = _PyNumber_AsSsize_t($38, $37);
      HEAP[$n] = $39;
      
      
      
      var $43 = HEAP[HEAP[$res]] - 1;
      
      var $45 = HEAP[$res];
      HEAP[$45] = $43;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $55 = HEAP[$res];
      FUNCTION_TABLE[$54]($55);
      __label__ = 13;
      break;
     case 13:
      
      var $57 = HEAP[$n] == -1;
      if ($57) {
        __label__ = 14;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 14:
      var $58 = _PyErr_Occurred();
      
      if ($58 != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 15:
      
      
      
      var $63 = HEAP[HEAP[$b]] - 1;
      
      var $65 = HEAP[$b];
      HEAP[$65] = $63;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $74 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $75 = HEAP[$b];
      FUNCTION_TABLE[$74]($75);
      __label__ = 17;
      break;
     case 17:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 18:
      var $76 = HEAP[$n];
      var $77 = HEAP[$b];
      var $78 = _PyByteArray_AsString($77);
      var $79 = _PyString_FromStringAndSize($78, $76);
      HEAP[$res] = $79;
      
      
      
      var $83 = HEAP[HEAP[$b]] - 1;
      
      var $85 = HEAP[$b];
      HEAP[$85] = $83;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $94 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $95 = HEAP[$b];
      FUNCTION_TABLE[$94]($95);
      __label__ = 20;
      break;
     case 20:
      var $96 = HEAP[$res];
      HEAP[$0] = $96;
      __label__ = 21;
      break;
     case 21:
      var $97 = HEAP[$0];
      HEAP[$retval] = $97;
      __label__ = 22;
      break;
     case 22:
      var $retval21 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _rawiobase_readall($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $r = __stackBase__ + 16;
      var $chunks = __stackBase__ + 20;
      var $result = __stackBase__ + 24;
      var $data = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      var $1 = _PyList_New(0);
      HEAP[$chunks] = $1;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 2:
      var $4 = HEAP[$self_addr];
      var $5 = __PyObject_CallMethod_SizeT($4, __str15196, __str13194, allocate([ 8192, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$data] = $5;
      
      
      if (HEAP[$data] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      
      
      var $11 = HEAP[HEAP[$chunks]] - 1;
      
      var $13 = HEAP[$chunks];
      HEAP[$13] = $11;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $22 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $23 = HEAP[$chunks];
      FUNCTION_TABLE[$22]($23);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 6:
      
      
      if (HEAP[$data] == __Py_NoneStruct) {
        __label__ = 7;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 7:
      
      
      
      
      
      if (HEAP[HEAP[$chunks] + 8] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      var $34 = HEAP[HEAP[$chunks]] - 1;
      
      var $36 = HEAP[$chunks];
      HEAP[$36] = $34;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $46 = HEAP[$chunks];
      FUNCTION_TABLE[$45]($46);
      __label__ = 10;
      break;
     case 10:
      var $47 = HEAP[$data];
      HEAP[$0] = $47;
      __label__ = 34;
      break;
     case 11:
      
      
      
      var $51 = HEAP[HEAP[$data]] - 1;
      
      var $53 = HEAP[$data];
      HEAP[$53] = $51;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $62 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $63 = HEAP[$data];
      FUNCTION_TABLE[$62]($63);
      __label__ = 13;
      break;
     case 13:
      __label__ = 31;
      break;
     case 14:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$data] + 4] + 84] & 134217728) == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 15:
      
      
      
      var $74 = HEAP[HEAP[$chunks]] - 1;
      
      var $76 = HEAP[$chunks];
      HEAP[$76] = $74;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $85 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $86 = HEAP[$chunks];
      FUNCTION_TABLE[$85]($86);
      __label__ = 17;
      break;
     case 17:
      
      
      
      var $90 = HEAP[HEAP[$data]] - 1;
      
      var $92 = HEAP[$data];
      HEAP[$92] = $90;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $101 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $102 = HEAP[$data];
      FUNCTION_TABLE[$101]($102);
      __label__ = 19;
      break;
     case 19:
      var $103 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($103, __str43225);
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 20:
      
      
      
      
      
      if (HEAP[HEAP[$data] + 8] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 21:
      
      
      
      var $112 = HEAP[HEAP[$data]] - 1;
      
      var $114 = HEAP[$data];
      HEAP[$114] = $112;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $123 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $124 = HEAP[$data];
      FUNCTION_TABLE[$123]($124);
      __label__ = 23;
      break;
     case 23:
      __label__ = 31;
      break;
     case 24:
      var $125 = HEAP[$chunks];
      var $126 = HEAP[$data];
      var $127 = _PyList_Append($125, $126);
      HEAP[$r] = $127;
      
      
      
      var $131 = HEAP[HEAP[$data]] - 1;
      
      var $133 = HEAP[$data];
      HEAP[$133] = $131;
      
      
      
      
      if (HEAP[HEAP[$data]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $142 = HEAP[HEAP[HEAP[$data] + 4] + 24];
      var $143 = HEAP[$data];
      FUNCTION_TABLE[$142]($143);
      __label__ = 26;
      break;
     case 26:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 27:
      
      
      
      var $149 = HEAP[HEAP[$chunks]] - 1;
      
      var $151 = HEAP[$chunks];
      HEAP[$151] = $149;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      
      var $160 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $161 = HEAP[$chunks];
      FUNCTION_TABLE[$160]($161);
      __label__ = 29;
      break;
     case 29:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 30:
      __label__ = 2;
      break;
     case 31:
      var $162 = HEAP[__PyIO_empty_bytes];
      var $163 = HEAP[$chunks];
      var $164 = __PyString_Join($162, $163);
      HEAP[$result] = $164;
      
      
      
      var $168 = HEAP[HEAP[$chunks]] - 1;
      
      var $170 = HEAP[$chunks];
      HEAP[$170] = $168;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $179 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $180 = HEAP[$chunks];
      FUNCTION_TABLE[$179]($180);
      __label__ = 33;
      break;
     case 33:
      var $181 = HEAP[$result];
      HEAP[$0] = $181;
      __label__ = 34;
      break;
     case 34:
      var $182 = HEAP[$0];
      HEAP[$retval] = $182;
      __label__ = 35;
      break;
     case 35:
      var $retval34 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval34;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _blockingioerror_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 36;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 36);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $myerrno = __stackBase__ + 20;
      var $strerror = __stackBase__ + 24;
      var $baseargs = __stackBase__ + 28;
      var $written = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      HEAP[$myerrno] = 0;
      HEAP[$strerror] = 0;
      HEAP[$baseargs] = 0;
      HEAP[$written] = 0;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$args_addr] + 4] + 84] & 67108864) == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str232, __str1233, 104, ___PRETTY_FUNCTION___8402);
      throw "Reached an unreachable!";
     case 2:
      
      var $9 = HEAP[$self_addr] + 32;
      HEAP[$9] = 0;
      var $10 = HEAP[$args_addr];
      var $11 = __PyArg_ParseTuple_SizeT($10, __str2234, allocate([ $myerrno, 0, 0, 0, $strerror, 0, 0, 0, $written, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = -1;
      __label__ = 13;
      break;
     case 4:
      var $13 = HEAP[$strerror];
      var $14 = HEAP[$myerrno];
      var $15 = _PyTuple_Pack(2, allocate([ $14, 0, 0, 0, $13, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$baseargs] = $15;
      
      
      if (HEAP[$baseargs] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 13;
      break;
     case 6:
      
      
      
      var $21 = HEAP[HEAP[_PyExc_IOError] + 148];
      
      var $23 = HEAP[$self_addr];
      var $24 = HEAP[$baseargs];
      var $25 = HEAP[$kwds_addr];
      var $26 = FUNCTION_TABLE[$21]($23, $24, $25);
      var $27 = $26 == -1;
      if ($27) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      
      
      
      var $31 = HEAP[HEAP[$baseargs]] - 1;
      
      var $33 = HEAP[$baseargs];
      HEAP[$33] = $31;
      
      
      
      
      if (HEAP[HEAP[$baseargs]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $42 = HEAP[HEAP[HEAP[$baseargs] + 4] + 24];
      var $43 = HEAP[$baseargs];
      FUNCTION_TABLE[$42]($43);
      __label__ = 9;
      break;
     case 9:
      HEAP[$0] = -1;
      __label__ = 13;
      break;
     case 10:
      
      
      
      var $47 = HEAP[HEAP[$baseargs]] - 1;
      
      var $49 = HEAP[$baseargs];
      HEAP[$49] = $47;
      
      
      
      
      if (HEAP[HEAP[$baseargs]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $58 = HEAP[HEAP[HEAP[$baseargs] + 4] + 24];
      var $59 = HEAP[$baseargs];
      FUNCTION_TABLE[$58]($59);
      __label__ = 12;
      break;
     case 12:
      var $60 = HEAP[$written];
      
      var $62 = HEAP[$self_addr] + 32;
      HEAP[$62] = $60;
      HEAP[$0] = 0;
      __label__ = 13;
      break;
     case 13:
      var $63 = HEAP[$0];
      HEAP[$retval] = $63;
      __label__ = 14;
      break;
     case 14:
      var $retval13 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval13;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _io_open($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 270;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 270);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $kwlist = __stackBase__ + 20;
      var $file = __stackBase__ + 52;
      var $mode = __stackBase__ + 56;
      var $buffering = __stackBase__ + 60;
      var $closefd = __stackBase__ + 64;
      var $encoding = __stackBase__ + 68;
      var $errors = __stackBase__ + 72;
      var $newline = __stackBase__ + 76;
      var $i = __stackBase__ + 80;
      var $reading = __stackBase__ + 84;
      var $writing = __stackBase__ + 88;
      var $appending = __stackBase__ + 92;
      var $updating = __stackBase__ + 96;
      var $text = __stackBase__ + 100;
      var $binary = __stackBase__ + 104;
      var $universal = __stackBase__ + 108;
      var $rawmode = __stackBase__ + 112;
      var $m = __stackBase__ + 117;
      var $line_buffering = __stackBase__ + 121;
      var $isatty = __stackBase__ + 125;
      var $raw = __stackBase__ + 129;
      var $modeobj = __stackBase__ + 133;
      var $buffer = __stackBase__ + 137;
      var $wrapper = __stackBase__ + 141;
      var $repr = __stackBase__ + 145;
      var $c = __stackBase__ + 149;
      var $res = __stackBase__ + 150;
      var $st = __stackBase__ + 154;
      var $fileno = __stackBase__ + 250;
      var $res66 = __stackBase__ + 254;
      var $Buffered_class = __stackBase__ + 258;
      var $_py_tmp = __stackBase__ + 262;
      var $_py_tmp100 = __stackBase__ + 266;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_6_8496];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_6_8496 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_6_8496 + 8];
      HEAP[$kwlist + 8] = $6;
      
      var $8 = HEAP[_C_6_8496 + 12];
      HEAP[$kwlist + 12] = $8;
      
      var $10 = HEAP[_C_6_8496 + 16];
      HEAP[$kwlist + 16] = $10;
      
      var $12 = HEAP[_C_6_8496 + 20];
      HEAP[$kwlist + 20] = $12;
      
      var $14 = HEAP[_C_6_8496 + 24];
      HEAP[$kwlist + 24] = $14;
      
      var $16 = HEAP[_C_6_8496 + 28];
      HEAP[$kwlist + 28] = $16;
      HEAP[$mode] = __str13246;
      HEAP[$buffering] = -1;
      HEAP[$closefd] = 1;
      HEAP[$encoding] = 0;
      HEAP[$errors] = 0;
      HEAP[$newline] = 0;
      HEAP[$reading] = 0;
      HEAP[$writing] = 0;
      HEAP[$appending] = 0;
      HEAP[$updating] = 0;
      HEAP[$text] = 0;
      HEAP[$binary] = 0;
      HEAP[$universal] = 0;
      HEAP[$modeobj] = 0;
      HEAP[$buffer] = 0;
      HEAP[$wrapper] = 0;
      var $17 = HEAP[$args_addr];
      var $18 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $19 = __PyArg_ParseTupleAndKeywords_SizeT($17, $18, __str14247, $kwlist1, allocate([ $file, 0, 0, 0, $mode, 0, 0, 0, $buffering, 0, 0, 0, $encoding, 0, 0, 0, $errors, 0, 0, 0, $newline, 0, 0, 0, $closefd, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($19 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$file] + 4] + 84] & 268435456) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$file] + 4] + 84] & 134217728) == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 4:
      var $35 = HEAP[$file];
      var $36 = _PyNumber_Check($35);
      
      if ($36 == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 5:
      var $38 = HEAP[$file];
      var $39 = _PyObject_Repr($38);
      HEAP[$repr] = $39;
      
      
      if (HEAP[$repr] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      
      var $45 = HEAP[$repr] + 20;
      var $46 = HEAP[_PyExc_TypeError];
      var $47 = _PyErr_Format($46, __str15248, allocate([ $45, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $51 = HEAP[HEAP[$repr]] - 1;
      
      var $53 = HEAP[$repr];
      HEAP[$53] = $51;
      
      
      
      
      if (HEAP[HEAP[$repr]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $62 = HEAP[HEAP[HEAP[$repr] + 4] + 24];
      var $63 = HEAP[$repr];
      FUNCTION_TABLE[$62]($63);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 9:
      HEAP[$i] = 0;
      __label__ = 22;
      break;
     case 10:
      
      
      
      var $67 = HEAP[HEAP[$mode] + HEAP[$i]];
      HEAP[$c] = $67;
      
      var $69 = HEAP[$c];
      if ($69 == 43) {
        __label__ = 14;
        break;
      } else if ($69 == 85) {
        __label__ = 17;
        break;
      } else if ($69 == 97) {
        __label__ = 13;
        break;
      } else if ($69 == 98) {
        __label__ = 16;
        break;
      } else if ($69 == 114) {
        __label__ = 11;
        break;
      } else if ($69 == 116) {
        __label__ = 15;
        break;
      } else if ($69 == 119) {
        __label__ = 12;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 11:
      HEAP[$reading] = 1;
      __label__ = 19;
      break;
     case 12:
      HEAP[$writing] = 1;
      __label__ = 19;
      break;
     case 13:
      HEAP[$appending] = 1;
      __label__ = 19;
      break;
     case 14:
      HEAP[$updating] = 1;
      __label__ = 19;
      break;
     case 15:
      HEAP[$text] = 1;
      __label__ = 19;
      break;
     case 16:
      HEAP[$binary] = 1;
      __label__ = 19;
      break;
     case 17:
      HEAP[$universal] = 1;
      HEAP[$reading] = 1;
      __label__ = 19;
      break;
     case 18:
      __label__ = 20;
      break;
     case 19:
      
      var $71 = HEAP[$c];
      
      
      
      var $75 = HEAP[$mode] + HEAP[$i] + 1;
      var $76 = _strchr($75, $71);
      
      if ($76 != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      var $78 = HEAP[$mode];
      var $79 = HEAP[_PyExc_ValueError];
      var $80 = _PyErr_Format($79, __str16249, allocate([ $78, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 21:
      
      var $82 = HEAP[$i] + 1;
      HEAP[$i] = $82;
      __label__ = 22;
      break;
     case 22:
      var $83 = HEAP[$mode];
      var $84 = _strlen($83);
      
      
      if ($84 > HEAP[$i]) {
        __label__ = 10;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 23:
      
      HEAP[$m] = $rawmode;
      
      
      if (HEAP[$reading] != 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      var $89 = HEAP[$m];
      HEAP[$89] = 114;
      
      var $91 = HEAP[$m] + 1;
      HEAP[$m] = $91;
      __label__ = 25;
      break;
     case 25:
      
      
      if (HEAP[$writing] != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      var $94 = HEAP[$m];
      HEAP[$94] = 119;
      
      var $96 = HEAP[$m] + 1;
      HEAP[$m] = $96;
      __label__ = 27;
      break;
     case 27:
      
      
      if (HEAP[$appending] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      var $99 = HEAP[$m];
      HEAP[$99] = 97;
      
      var $101 = HEAP[$m] + 1;
      HEAP[$m] = $101;
      __label__ = 29;
      break;
     case 29:
      
      
      if (HEAP[$updating] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      var $104 = HEAP[$m];
      HEAP[$104] = 43;
      
      var $106 = HEAP[$m] + 1;
      HEAP[$m] = $106;
      __label__ = 31;
      break;
     case 31:
      var $107 = HEAP[$m];
      HEAP[$107] = 0;
      
      
      if (HEAP[$universal] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 32:
      
      
      if (HEAP[$writing] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 33:
      
      
      if (HEAP[$appending] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      var $114 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($114, __str17250);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 35:
      HEAP[$reading] = 1;
      __label__ = 36;
      break;
     case 36:
      
      
      if (HEAP[$text] != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 37:
      
      
      if (HEAP[$binary] != 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      var $119 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($119, __str18251);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 39:
      
      
      
      
      
      
      if (HEAP[$reading] + HEAP[$writing] + HEAP[$appending] > 1) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      var $126 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($126, __str19252);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 41:
      
      
      if (HEAP[$binary] != 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 42:
      
      
      if (HEAP[$encoding] != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      var $131 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($131, __str20253);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 44:
      
      
      if (HEAP[$binary] != 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 45:
      
      
      if (HEAP[$errors] != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      var $136 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($136, __str21254);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 47:
      
      
      if (HEAP[$binary] != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 48:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      var $141 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($141, __str22255);
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 50:
      var $142 = HEAP[$closefd];
      var $143 = HEAP[$file];
      var $rawmode51 = $rawmode;
      var $144 = __PyObject_CallFunction_SizeT(_PyFileIO_Type, __str23256, allocate([ $143, 0, 0, 0, $rawmode51, 0, 0, 0, $142, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$raw] = $144;
      
      
      if (HEAP[$raw] == 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 51:
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 52:
      var $147 = HEAP[$mode];
      var $148 = _PyUnicodeUCS2_FromString($147);
      HEAP[$modeobj] = $148;
      
      
      if (HEAP[$modeobj] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 53:
      var $151 = HEAP[$raw];
      var $152 = __PyObject_CallMethod_SizeT($151, __str24257, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $152;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 54:
      var $155 = HEAP[$res];
      var $156 = _PyLong_AsLong($155);
      HEAP[$isatty] = $156;
      
      
      
      var $160 = HEAP[HEAP[$res]] - 1;
      
      var $162 = HEAP[$res];
      HEAP[$162] = $160;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $171 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $172 = HEAP[$res];
      FUNCTION_TABLE[$171]($172);
      __label__ = 56;
      break;
     case 56:
      
      var $174 = HEAP[$isatty] == -1;
      if ($174) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      var $175 = _PyErr_Occurred();
      
      if ($175 != 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      if (HEAP[$buffering] == 1) {
        __label__ = 61;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 59:
      
      
      if (HEAP[$buffering] >= 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      
      if (HEAP[$isatty] != 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 61:
      HEAP[$buffering] = -1;
      HEAP[$line_buffering] = 1;
      __label__ = 63;
      break;
     case 62:
      HEAP[$line_buffering] = 0;
      __label__ = 63;
      break;
     case 63:
      
      
      if (HEAP[$buffering] < 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 64:
      HEAP[$buffering] = 8192;
      var $185 = HEAP[$raw];
      var $186 = __PyObject_CallMethod_SizeT($185, __str25258, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res66] = $186;
      
      
      if (HEAP[$res66] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      var $189 = HEAP[$res66];
      var $190 = _PyInt_AsLong($189);
      HEAP[$fileno] = $190;
      
      
      
      var $194 = HEAP[HEAP[$res66]] - 1;
      
      var $196 = HEAP[$res66];
      HEAP[$196] = $194;
      
      
      
      
      if (HEAP[HEAP[$res66]] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      
      
      var $205 = HEAP[HEAP[HEAP[$res66] + 4] + 24];
      var $206 = HEAP[$res66];
      FUNCTION_TABLE[$205]($206);
      __label__ = 67;
      break;
     case 67:
      
      var $208 = HEAP[$fileno] == -1;
      if ($208) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      var $209 = _PyErr_Occurred();
      
      if ($209 != 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 69:
      var $211 = HEAP[$fileno];
      var $212 = ___01fstat64_($211, $st);
      
      if ($212 >= 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 70:
      
      
      
      if (HEAP[$st + 52] > 1) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      
      var $218 = HEAP[$st + 52];
      HEAP[$buffering] = $218;
      __label__ = 72;
      break;
     case 72:
      
      
      if (HEAP[$buffering] < 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 73:
      var $221 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($221, __str26259);
      __label__ = 104;
      break;
     case 74:
      
      
      if (HEAP[$buffering] == 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 75:
      
      
      if (HEAP[$binary] == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      var $226 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($226, __str27260);
      __label__ = 104;
      break;
     case 77:
      
      
      
      var $230 = HEAP[HEAP[$modeobj]] - 1;
      
      var $232 = HEAP[$modeobj];
      HEAP[$232] = $230;
      
      
      
      
      if (HEAP[HEAP[$modeobj]] == 0) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      
      
      
      
      var $241 = HEAP[HEAP[HEAP[$modeobj] + 4] + 24];
      var $242 = HEAP[$modeobj];
      FUNCTION_TABLE[$241]($242);
      __label__ = 79;
      break;
     case 79:
      var $243 = HEAP[$raw];
      HEAP[$0] = $243;
      __label__ = 117;
      break;
     case 80:
      
      
      if (HEAP[$updating] != 0) {
        __label__ = 81;
        break;
      } else {
        __label__ = 82;
        break;
      }
     case 81:
      HEAP[$Buffered_class] = _PyBufferedRandom_Type;
      __label__ = 88;
      break;
     case 82:
      
      
      if (HEAP[$writing] != 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 83:
      
      
      if (HEAP[$appending] != 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 84:
      HEAP[$Buffered_class] = _PyBufferedWriter_Type;
      __label__ = 88;
      break;
     case 85:
      
      
      if (HEAP[$reading] != 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 86:
      HEAP[$Buffered_class] = _PyBufferedReader_Type;
      __label__ = 88;
      break;
     case 87:
      var $252 = HEAP[$mode];
      var $253 = HEAP[_PyExc_ValueError];
      var $254 = _PyErr_Format($253, __str28261, allocate([ $252, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 104;
      break;
     case 88:
      var $255 = HEAP[$buffering];
      var $256 = HEAP[$Buffered_class];
      var $257 = HEAP[$raw];
      var $258 = __PyObject_CallFunction_SizeT($256, __str29262, allocate([ $257, 0, 0, 0, $255, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$buffer] = $258;
      
      
      if (HEAP[$raw] != 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 89:
      var $261 = HEAP[$raw];
      HEAP[$_py_tmp] = $261;
      HEAP[$raw] = 0;
      
      
      
      var $265 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $267 = HEAP[$_py_tmp];
      HEAP[$267] = $265;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 90:
      
      
      
      
      var $276 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $277 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$276]($277);
      __label__ = 91;
      break;
     case 91:
      
      
      if (HEAP[$buffer] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 92:
      
      
      if (HEAP[$binary] != 0) {
        __label__ = 93;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 93:
      
      
      
      var $285 = HEAP[HEAP[$modeobj]] - 1;
      
      var $287 = HEAP[$modeobj];
      HEAP[$287] = $285;
      
      
      
      
      if (HEAP[HEAP[$modeobj]] == 0) {
        __label__ = 94;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 94:
      
      
      
      
      var $296 = HEAP[HEAP[HEAP[$modeobj] + 4] + 24];
      var $297 = HEAP[$modeobj];
      FUNCTION_TABLE[$296]($297);
      __label__ = 95;
      break;
     case 95:
      var $298 = HEAP[$buffer];
      HEAP[$0] = $298;
      __label__ = 117;
      break;
     case 96:
      var $299 = HEAP[$newline];
      var $300 = HEAP[$errors];
      var $301 = HEAP[$encoding];
      var $302 = HEAP[$buffer];
      var $303 = HEAP[$line_buffering];
      var $304 = __PyObject_CallFunction_SizeT(_PyTextIOWrapper_Type, __str30263, allocate([ $302, 0, 0, 0, $301, 0, 0, 0, $300, 0, 0, 0, $299, 0, 0, 0, $303, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$wrapper] = $304;
      
      
      if (HEAP[$buffer] != 0) {
        __label__ = 97;
        break;
      } else {
        __label__ = 99;
        break;
      }
     case 97:
      var $307 = HEAP[$buffer];
      HEAP[$_py_tmp100] = $307;
      HEAP[$buffer] = 0;
      
      
      
      var $311 = HEAP[HEAP[$_py_tmp100]] - 1;
      
      var $313 = HEAP[$_py_tmp100];
      HEAP[$313] = $311;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp100]] == 0) {
        __label__ = 98;
        break;
      } else {
        __label__ = 99;
        break;
      }
     case 98:
      
      
      
      
      var $322 = HEAP[HEAP[HEAP[$_py_tmp100] + 4] + 24];
      var $323 = HEAP[$_py_tmp100];
      FUNCTION_TABLE[$322]($323);
      __label__ = 99;
      break;
     case 99:
      
      
      if (HEAP[$wrapper] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 100;
        break;
      }
     case 100:
      var $326 = HEAP[$wrapper];
      var $327 = HEAP[$modeobj];
      var $328 = _PyObject_SetAttrString($326, __str7240, $327);
      
      if ($328 < 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 101;
        break;
      }
     case 101:
      
      
      
      var $333 = HEAP[HEAP[$modeobj]] - 1;
      
      var $335 = HEAP[$modeobj];
      HEAP[$335] = $333;
      
      
      
      
      if (HEAP[HEAP[$modeobj]] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 103;
        break;
      }
     case 102:
      
      
      
      
      var $344 = HEAP[HEAP[HEAP[$modeobj] + 4] + 24];
      var $345 = HEAP[$modeobj];
      FUNCTION_TABLE[$344]($345);
      __label__ = 103;
      break;
     case 103:
      var $346 = HEAP[$wrapper];
      HEAP[$0] = $346;
      __label__ = 117;
      break;
     case 104:
      
      
      if (HEAP[$raw] != 0) {
        __label__ = 105;
        break;
      } else {
        __label__ = 107;
        break;
      }
     case 105:
      
      
      
      var $352 = HEAP[HEAP[$raw]] - 1;
      
      var $354 = HEAP[$raw];
      HEAP[$354] = $352;
      
      
      
      
      if (HEAP[HEAP[$raw]] == 0) {
        __label__ = 106;
        break;
      } else {
        __label__ = 107;
        break;
      }
     case 106:
      
      
      
      
      var $363 = HEAP[HEAP[HEAP[$raw] + 4] + 24];
      var $364 = HEAP[$raw];
      FUNCTION_TABLE[$363]($364);
      __label__ = 107;
      break;
     case 107:
      
      
      if (HEAP[$modeobj] != 0) {
        __label__ = 108;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 108:
      
      
      
      var $370 = HEAP[HEAP[$modeobj]] - 1;
      
      var $372 = HEAP[$modeobj];
      HEAP[$372] = $370;
      
      
      
      
      if (HEAP[HEAP[$modeobj]] == 0) {
        __label__ = 109;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 109:
      
      
      
      
      var $381 = HEAP[HEAP[HEAP[$modeobj] + 4] + 24];
      var $382 = HEAP[$modeobj];
      FUNCTION_TABLE[$381]($382);
      __label__ = 110;
      break;
     case 110:
      
      
      if (HEAP[$buffer] != 0) {
        __label__ = 111;
        break;
      } else {
        __label__ = 113;
        break;
      }
     case 111:
      
      
      
      var $388 = HEAP[HEAP[$buffer]] - 1;
      
      var $390 = HEAP[$buffer];
      HEAP[$390] = $388;
      
      
      
      
      if (HEAP[HEAP[$buffer]] == 0) {
        __label__ = 112;
        break;
      } else {
        __label__ = 113;
        break;
      }
     case 112:
      
      
      
      
      var $399 = HEAP[HEAP[HEAP[$buffer] + 4] + 24];
      var $400 = HEAP[$buffer];
      FUNCTION_TABLE[$399]($400);
      __label__ = 113;
      break;
     case 113:
      
      
      if (HEAP[$wrapper] != 0) {
        __label__ = 114;
        break;
      } else {
        __label__ = 116;
        break;
      }
     case 114:
      
      
      
      var $406 = HEAP[HEAP[$wrapper]] - 1;
      
      var $408 = HEAP[$wrapper];
      HEAP[$408] = $406;
      
      
      
      
      if (HEAP[HEAP[$wrapper]] == 0) {
        __label__ = 115;
        break;
      } else {
        __label__ = 116;
        break;
      }
     case 115:
      
      
      
      
      var $417 = HEAP[HEAP[HEAP[$wrapper] + 4] + 24];
      var $418 = HEAP[$wrapper];
      FUNCTION_TABLE[$417]($418);
      __label__ = 116;
      break;
     case 116:
      HEAP[$0] = 0;
      __label__ = 117;
      break;
     case 117:
      var $419 = HEAP[$0];
      HEAP[$retval] = $419;
      __label__ = 118;
      break;
     case 118:
      var $retval120 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval120;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _PyNumber_AsOff_t($item, $err) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $item_addr = __stackBase__;
      var $err_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 16;
      var $result = __stackBase__ + 24;
      var $runerr = __stackBase__ + 32;
      var $value = __stackBase__ + 36;
      
      HEAP[$item_addr] = $item;
      HEAP[$err_addr] = $err;
      var $1 = HEAP[$item_addr];
      var $2 = _PyNumber_Index($1);
      HEAP[$value] = $2;
      
      
      if (HEAP[$value] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 18;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$value] + 4] + 84] & 8388608) != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $16 = HEAP[HEAP[$value] + 8];
      HEAP[$result] = $16;
      __label__ = 15;
      break;
     case 4:
      var $17 = HEAP[$value];
      var $18 = _PyLong_AsLongLong($17);
      HEAP[$result] = $18;
      
      var $20 = HEAP[$result] != -1;
      if ($20) {
        __label__ = 15;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      var $21 = _PyErr_Occurred();
      HEAP[$runerr] = $21;
      
      
      if (HEAP[$runerr] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      var $24 = HEAP[_PyExc_OverflowError];
      var $25 = HEAP[$runerr];
      var $26 = _PyErr_GivenExceptionMatches($25, $24);
      
      if ($26 == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      _PyErr_Clear();
      
      
      if (HEAP[$err_addr] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$value] + 4] + 84] & 16777216) == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      ___assert_fail(__str31264, __str1233, 564, ___PRETTY_FUNCTION___8759);
      throw "Reached an unreachable!";
     case 10:
      var $37 = HEAP[$value];
      var $38 = __PyLong_Sign($37);
      
      if ($38 < 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$result] = -0x8000000000000000;
      __label__ = 13;
      break;
     case 12:
      HEAP[$result] = 0x8000000000000000;
      __label__ = 13;
      break;
     case 13:
      __label__ = 15;
      break;
     case 14:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$item_addr] + 4] + 12];
      var $45 = HEAP[$err_addr];
      var $46 = _PyErr_Format($45, __str32265, allocate([ $44, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 15;
      break;
     case 15:
      
      
      
      var $50 = HEAP[HEAP[$value]] - 1;
      
      var $52 = HEAP[$value];
      HEAP[$52] = $50;
      
      
      
      
      if (HEAP[HEAP[$value]] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $61 = HEAP[HEAP[HEAP[$value] + 4] + 24];
      var $62 = HEAP[$value];
      FUNCTION_TABLE[$61]($62);
      __label__ = 17;
      break;
     case 17:
      var $63 = HEAP[$result];
      HEAP[$0] = $63;
      __label__ = 18;
      break;
     case 18:
      var $64 = HEAP[$0];
      HEAP[$retval] = $64;
      __label__ = 19;
      break;
     case 19:
      var $retval17 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIO_ConvertSsize_t($obj, $result) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $obj_addr = __stackBase__;
      var $result_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $limit = __stackBase__ + 16;
      
      HEAP[$obj_addr] = $obj;
      HEAP[$result_addr] = $result;
      
      
      if (HEAP[$obj_addr] == __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$limit] = -1;
      __label__ = 8;
      break;
     case 2:
      var $3 = HEAP[$obj_addr];
      var $4 = _PyNumber_Check($3);
      
      if ($4 != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      var $6 = HEAP[_PyExc_OverflowError];
      var $7 = HEAP[$obj_addr];
      var $8 = _PyNumber_AsSsize_t($7, $6);
      HEAP[$limit] = $8;
      
      var $10 = HEAP[$limit] == -1;
      if ($10) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      var $11 = _PyErr_Occurred();
      
      if ($11 != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 6:
      __label__ = 8;
      break;
     case 7:
      
      
      
      
      var $17 = HEAP[HEAP[HEAP[$obj_addr] + 4] + 12];
      var $18 = HEAP[_PyExc_TypeError];
      var $19 = _PyErr_Format($18, __str33266, allocate([ $17, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 8:
      
      var $21 = HEAP[$result_addr];
      var $22 = HEAP[$limit];
      HEAP[$21] = $22;
      HEAP[$0] = 1;
      __label__ = 9;
      break;
     case 9:
      var $23 = HEAP[$0];
      HEAP[$retval] = $23;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _init_io() {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $m = __stackBase__;
      var $_py_tmp = __stackBase__ + 4;
      var $_py_tmp105 = __stackBase__ + 8;
      
      var $0 = _Py_InitModule4(__str35269, _module_methods, _module_doc, 0, 1013);
      HEAP[$m] = $0;
      
      
      if (HEAP[$m] == 0) {
        __label__ = 110;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      var $3 = _PyImport_ImportModule(__str36270);
      HEAP[__PyIO_os_module] = $3;
      
      
      if (HEAP[__PyIO_os_module] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      var $6 = HEAP[$m];
      var $7 = _PyModule_AddIntConstant($6, __str37271, 8192);
      
      if ($7 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      var $9 = HEAP[_PyExc_IOError];
      var $10 = HEAP[_PyExc_ValueError];
      var $11 = __PyObject_CallFunction_SizeT(_PyType_Type, __str38272, allocate([ __str39273, 0, 0, 0, $10, 0, 0, 0, $9, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[__PyIO_unsupported_operation] = $11;
      
      
      if (HEAP[__PyIO_unsupported_operation] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      var $17 = HEAP[HEAP[__PyIO_unsupported_operation]] + 1;
      var $18 = HEAP[__PyIO_unsupported_operation];
      HEAP[$18] = $17;
      var $19 = HEAP[__PyIO_unsupported_operation];
      var $20 = HEAP[$m];
      var $21 = _PyModule_AddObject($20, __str39273, $19);
      
      if ($21 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      var $24 = HEAP[_PyExc_IOError];
      HEAP[__PyExc_BlockingIOError + 128] = $24;
      var $25 = _PyType_Ready(__PyExc_BlockingIOError);
      
      if ($25 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 6:
      
      
      var $29 = HEAP[__PyExc_BlockingIOError] + 1;
      
      HEAP[__PyExc_BlockingIOError] = $29;
      var $31 = HEAP[$m];
      var $32 = _PyModule_AddObject($31, __str4236, __PyExc_BlockingIOError);
      
      if ($32 < 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 7:
      
      
      var $36 = HEAP[__PyExc_BlockingIOError] - 1;
      
      HEAP[__PyExc_BlockingIOError] = $36;
      
      
      
      if (HEAP[__PyExc_BlockingIOError] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      var $44 = HEAP[HEAP[__PyExc_BlockingIOError + 4] + 24];
      FUNCTION_TABLE[$44](__PyExc_BlockingIOError);
      __label__ = 9;
      break;
     case 9:
      __label__ = 102;
      break;
     case 10:
      var $45 = _PyType_Ready(_PyIOBase_Type);
      
      if ($45 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      
      
      var $49 = HEAP[_PyIOBase_Type] + 1;
      
      HEAP[_PyIOBase_Type] = $49;
      var $51 = HEAP[$m];
      var $52 = _PyModule_AddObject($51, __str40274, _PyIOBase_Type);
      
      if ($52 < 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 12:
      
      
      var $56 = HEAP[_PyIOBase_Type] - 1;
      
      HEAP[_PyIOBase_Type] = $56;
      
      
      
      if (HEAP[_PyIOBase_Type] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      var $64 = HEAP[HEAP[_PyIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$64](_PyIOBase_Type);
      __label__ = 14;
      break;
     case 14:
      __label__ = 102;
      break;
     case 15:
      var $65 = _PyType_Ready(_PyRawIOBase_Type);
      
      if ($65 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      var $69 = HEAP[_PyRawIOBase_Type] + 1;
      
      HEAP[_PyRawIOBase_Type] = $69;
      var $71 = HEAP[$m];
      var $72 = _PyModule_AddObject($71, __str41275, _PyRawIOBase_Type);
      
      if ($72 < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      
      
      var $76 = HEAP[_PyRawIOBase_Type] - 1;
      
      HEAP[_PyRawIOBase_Type] = $76;
      
      
      
      if (HEAP[_PyRawIOBase_Type] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      var $84 = HEAP[HEAP[_PyRawIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$84](_PyRawIOBase_Type);
      __label__ = 19;
      break;
     case 19:
      __label__ = 102;
      break;
     case 20:
      var $85 = _PyType_Ready(_PyBufferedIOBase_Type);
      
      if ($85 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      var $89 = HEAP[_PyBufferedIOBase_Type] + 1;
      
      HEAP[_PyBufferedIOBase_Type] = $89;
      var $91 = HEAP[$m];
      var $92 = _PyModule_AddObject($91, __str42276, _PyBufferedIOBase_Type);
      
      if ($92 < 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 22:
      
      
      var $96 = HEAP[_PyBufferedIOBase_Type] - 1;
      
      HEAP[_PyBufferedIOBase_Type] = $96;
      
      
      
      if (HEAP[_PyBufferedIOBase_Type] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      var $104 = HEAP[HEAP[_PyBufferedIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$104](_PyBufferedIOBase_Type);
      __label__ = 24;
      break;
     case 24:
      __label__ = 102;
      break;
     case 25:
      var $105 = _PyType_Ready(_PyTextIOBase_Type);
      
      if ($105 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      
      var $109 = HEAP[_PyTextIOBase_Type] + 1;
      
      HEAP[_PyTextIOBase_Type] = $109;
      var $111 = HEAP[$m];
      var $112 = _PyModule_AddObject($111, __str43277, _PyTextIOBase_Type);
      
      if ($112 < 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 27:
      
      
      var $116 = HEAP[_PyTextIOBase_Type] - 1;
      
      HEAP[_PyTextIOBase_Type] = $116;
      
      
      
      if (HEAP[_PyTextIOBase_Type] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      var $124 = HEAP[HEAP[_PyTextIOBase_Type + 4] + 24];
      FUNCTION_TABLE[$124](_PyTextIOBase_Type);
      __label__ = 29;
      break;
     case 29:
      __label__ = 102;
      break;
     case 30:
      HEAP[_PyFileIO_Type + 128] = _PyRawIOBase_Type;
      var $125 = _PyType_Ready(_PyFileIO_Type);
      
      if ($125 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      var $129 = HEAP[_PyFileIO_Type] + 1;
      
      HEAP[_PyFileIO_Type] = $129;
      var $131 = HEAP[$m];
      var $132 = _PyModule_AddObject($131, __str44278, _PyFileIO_Type);
      
      if ($132 < 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 32:
      
      
      var $136 = HEAP[_PyFileIO_Type] - 1;
      
      HEAP[_PyFileIO_Type] = $136;
      
      
      
      if (HEAP[_PyFileIO_Type] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      
      
      
      var $144 = HEAP[HEAP[_PyFileIO_Type + 4] + 24];
      FUNCTION_TABLE[$144](_PyFileIO_Type);
      __label__ = 34;
      break;
     case 34:
      __label__ = 102;
      break;
     case 35:
      HEAP[_PyBytesIO_Type + 128] = _PyBufferedIOBase_Type;
      var $145 = _PyType_Ready(_PyBytesIO_Type);
      
      if ($145 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 36:
      
      
      var $149 = HEAP[_PyBytesIO_Type] + 1;
      
      HEAP[_PyBytesIO_Type] = $149;
      var $151 = HEAP[$m];
      var $152 = _PyModule_AddObject($151, __str45279, _PyBytesIO_Type);
      
      if ($152 < 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 37:
      
      
      var $156 = HEAP[_PyBytesIO_Type] - 1;
      
      HEAP[_PyBytesIO_Type] = $156;
      
      
      
      if (HEAP[_PyBytesIO_Type] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      var $164 = HEAP[HEAP[_PyBytesIO_Type + 4] + 24];
      FUNCTION_TABLE[$164](_PyBytesIO_Type);
      __label__ = 39;
      break;
     case 39:
      __label__ = 102;
      break;
     case 40:
      HEAP[_PyStringIO_Type + 128] = _PyTextIOBase_Type;
      var $165 = _PyType_Ready(_PyStringIO_Type);
      
      if ($165 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 41:
      
      
      var $169 = HEAP[_PyStringIO_Type] + 1;
      
      HEAP[_PyStringIO_Type] = $169;
      var $171 = HEAP[$m];
      var $172 = _PyModule_AddObject($171, __str46280, _PyStringIO_Type);
      
      if ($172 < 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 42:
      
      
      var $176 = HEAP[_PyStringIO_Type] - 1;
      
      HEAP[_PyStringIO_Type] = $176;
      
      
      
      if (HEAP[_PyStringIO_Type] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      
      
      
      var $184 = HEAP[HEAP[_PyStringIO_Type + 4] + 24];
      FUNCTION_TABLE[$184](_PyStringIO_Type);
      __label__ = 44;
      break;
     case 44:
      __label__ = 102;
      break;
     case 45:
      HEAP[_PyBufferedReader_Type + 128] = _PyBufferedIOBase_Type;
      var $185 = _PyType_Ready(_PyBufferedReader_Type);
      
      if ($185 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      var $189 = HEAP[_PyBufferedReader_Type] + 1;
      
      HEAP[_PyBufferedReader_Type] = $189;
      var $191 = HEAP[$m];
      var $192 = _PyModule_AddObject($191, __str47281, _PyBufferedReader_Type);
      
      if ($192 < 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 47:
      
      
      var $196 = HEAP[_PyBufferedReader_Type] - 1;
      
      HEAP[_PyBufferedReader_Type] = $196;
      
      
      
      if (HEAP[_PyBufferedReader_Type] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      
      
      
      var $204 = HEAP[HEAP[_PyBufferedReader_Type + 4] + 24];
      FUNCTION_TABLE[$204](_PyBufferedReader_Type);
      __label__ = 49;
      break;
     case 49:
      __label__ = 102;
      break;
     case 50:
      HEAP[_PyBufferedWriter_Type + 128] = _PyBufferedIOBase_Type;
      var $205 = _PyType_Ready(_PyBufferedWriter_Type);
      
      if ($205 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 51:
      
      
      var $209 = HEAP[_PyBufferedWriter_Type] + 1;
      
      HEAP[_PyBufferedWriter_Type] = $209;
      var $211 = HEAP[$m];
      var $212 = _PyModule_AddObject($211, __str48282, _PyBufferedWriter_Type);
      
      if ($212 < 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 52:
      
      
      var $216 = HEAP[_PyBufferedWriter_Type] - 1;
      
      HEAP[_PyBufferedWriter_Type] = $216;
      
      
      
      if (HEAP[_PyBufferedWriter_Type] == 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 54;
        break;
      }
     case 53:
      
      
      
      var $224 = HEAP[HEAP[_PyBufferedWriter_Type + 4] + 24];
      FUNCTION_TABLE[$224](_PyBufferedWriter_Type);
      __label__ = 54;
      break;
     case 54:
      __label__ = 102;
      break;
     case 55:
      HEAP[_PyBufferedRWPair_Type + 128] = _PyBufferedIOBase_Type;
      var $225 = _PyType_Ready(_PyBufferedRWPair_Type);
      
      if ($225 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 56:
      
      
      var $229 = HEAP[_PyBufferedRWPair_Type] + 1;
      
      HEAP[_PyBufferedRWPair_Type] = $229;
      var $231 = HEAP[$m];
      var $232 = _PyModule_AddObject($231, __str49283, _PyBufferedRWPair_Type);
      
      if ($232 < 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 57:
      
      
      var $236 = HEAP[_PyBufferedRWPair_Type] - 1;
      
      HEAP[_PyBufferedRWPair_Type] = $236;
      
      
      
      if (HEAP[_PyBufferedRWPair_Type] == 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      
      
      var $244 = HEAP[HEAP[_PyBufferedRWPair_Type + 4] + 24];
      FUNCTION_TABLE[$244](_PyBufferedRWPair_Type);
      __label__ = 59;
      break;
     case 59:
      __label__ = 102;
      break;
     case 60:
      HEAP[_PyBufferedRandom_Type + 128] = _PyBufferedIOBase_Type;
      var $245 = _PyType_Ready(_PyBufferedRandom_Type);
      
      if ($245 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      
      var $249 = HEAP[_PyBufferedRandom_Type] + 1;
      
      HEAP[_PyBufferedRandom_Type] = $249;
      var $251 = HEAP[$m];
      var $252 = _PyModule_AddObject($251, __str50284, _PyBufferedRandom_Type);
      
      if ($252 < 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 62:
      
      
      var $256 = HEAP[_PyBufferedRandom_Type] - 1;
      
      HEAP[_PyBufferedRandom_Type] = $256;
      
      
      
      if (HEAP[_PyBufferedRandom_Type] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      
      
      
      var $264 = HEAP[HEAP[_PyBufferedRandom_Type + 4] + 24];
      FUNCTION_TABLE[$264](_PyBufferedRandom_Type);
      __label__ = 64;
      break;
     case 64:
      __label__ = 102;
      break;
     case 65:
      HEAP[_PyTextIOWrapper_Type + 128] = _PyTextIOBase_Type;
      var $265 = _PyType_Ready(_PyTextIOWrapper_Type);
      
      if ($265 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 66:
      
      
      var $269 = HEAP[_PyTextIOWrapper_Type] + 1;
      
      HEAP[_PyTextIOWrapper_Type] = $269;
      var $271 = HEAP[$m];
      var $272 = _PyModule_AddObject($271, __str51285, _PyTextIOWrapper_Type);
      
      if ($272 < 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 67:
      
      
      var $276 = HEAP[_PyTextIOWrapper_Type] - 1;
      
      HEAP[_PyTextIOWrapper_Type] = $276;
      
      
      
      if (HEAP[_PyTextIOWrapper_Type] == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      
      
      
      var $284 = HEAP[HEAP[_PyTextIOWrapper_Type + 4] + 24];
      FUNCTION_TABLE[$284](_PyTextIOWrapper_Type);
      __label__ = 69;
      break;
     case 69:
      __label__ = 102;
      break;
     case 70:
      var $285 = _PyType_Ready(_PyIncrementalNewlineDecoder_Type);
      
      if ($285 < 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 71:
      
      
      var $289 = HEAP[_PyIncrementalNewlineDecoder_Type] + 1;
      
      HEAP[_PyIncrementalNewlineDecoder_Type] = $289;
      var $291 = HEAP[$m];
      var $292 = _PyModule_AddObject($291, __str52286, _PyIncrementalNewlineDecoder_Type);
      
      if ($292 < 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 72:
      
      
      var $296 = HEAP[_PyIncrementalNewlineDecoder_Type] - 1;
      
      HEAP[_PyIncrementalNewlineDecoder_Type] = $296;
      
      
      
      if (HEAP[_PyIncrementalNewlineDecoder_Type] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 73:
      
      
      
      var $304 = HEAP[HEAP[_PyIncrementalNewlineDecoder_Type + 4] + 24];
      FUNCTION_TABLE[$304](_PyIncrementalNewlineDecoder_Type);
      __label__ = 74;
      break;
     case 74:
      __label__ = 102;
      break;
     case 75:
      var $305 = _PyString_InternFromString(__str53287);
      HEAP[__PyIO_str_close] = $305;
      
      
      if (HEAP[__PyIO_str_close] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 76:
      var $308 = _PyString_InternFromString(__str54289);
      HEAP[__PyIO_str_closed] = $308;
      
      
      if (HEAP[__PyIO_str_closed] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 77:
      var $311 = _PyString_InternFromString(__str55291);
      HEAP[__PyIO_str_decode] = $311;
      
      
      if (HEAP[__PyIO_str_decode] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 78:
      var $314 = _PyString_InternFromString(__str56292);
      HEAP[__PyIO_str_encode] = $314;
      
      
      if (HEAP[__PyIO_str_encode] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 79:
      var $317 = _PyString_InternFromString(__str25258);
      HEAP[__PyIO_str_fileno] = $317;
      
      
      if (HEAP[__PyIO_str_fileno] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 80:
      var $320 = _PyString_InternFromString(__str57294);
      HEAP[__PyIO_str_flush] = $320;
      
      
      if (HEAP[__PyIO_str_flush] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      var $323 = _PyString_InternFromString(__str58296);
      HEAP[__PyIO_str_getstate] = $323;
      
      
      if (HEAP[__PyIO_str_getstate] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 82;
        break;
      }
     case 82:
      var $326 = _PyString_InternFromString(__str24257);
      HEAP[__PyIO_str_isatty] = $326;
      
      
      if (HEAP[__PyIO_str_isatty] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 83:
      var $329 = _PyString_InternFromString(__str59298);
      HEAP[__PyIO_str_newlines] = $329;
      
      
      if (HEAP[__PyIO_str_newlines] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 84:
      var $332 = _PyString_InternFromString(__str60299);
      HEAP[__PyIO_str_nl] = $332;
      
      
      if (HEAP[__PyIO_str_nl] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 85:
      var $335 = _PyString_InternFromString(__str61300);
      HEAP[__PyIO_str_read] = $335;
      
      
      if (HEAP[__PyIO_str_read] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 86:
      var $338 = _PyString_InternFromString(__str62302);
      HEAP[__PyIO_str_read1] = $338;
      
      
      if (HEAP[__PyIO_str_read1] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 87:
      var $341 = _PyString_InternFromString(__str63303);
      HEAP[__PyIO_str_readable] = $341;
      
      
      if (HEAP[__PyIO_str_readable] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 88:
      var $344 = _PyString_InternFromString(__str64305);
      HEAP[__PyIO_str_readinto] = $344;
      
      
      if (HEAP[__PyIO_str_readinto] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 89:
      var $347 = _PyString_InternFromString(__str65307);
      HEAP[__PyIO_str_readline] = $347;
      
      
      if (HEAP[__PyIO_str_readline] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 90:
      var $350 = _PyString_InternFromString(__str66309);
      HEAP[__PyIO_str_reset] = $350;
      
      
      if (HEAP[__PyIO_str_reset] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 91:
      var $353 = _PyString_InternFromString(__str67);
      HEAP[__PyIO_str_seek] = $353;
      
      
      if (HEAP[__PyIO_str_seek] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 92:
      var $356 = _PyString_InternFromString(__str68);
      HEAP[__PyIO_str_seekable] = $356;
      
      
      if (HEAP[__PyIO_str_seekable] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 93:
      var $359 = _PyString_InternFromString(__str69);
      HEAP[__PyIO_str_setstate] = $359;
      
      
      if (HEAP[__PyIO_str_setstate] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 94;
        break;
      }
     case 94:
      var $362 = _PyString_InternFromString(__str70);
      HEAP[__PyIO_str_tell] = $362;
      
      
      if (HEAP[__PyIO_str_tell] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 95:
      var $365 = _PyString_InternFromString(__str71);
      HEAP[__PyIO_str_truncate] = $365;
      
      
      if (HEAP[__PyIO_str_truncate] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 96:
      var $368 = _PyString_InternFromString(__str72);
      HEAP[__PyIO_str_write] = $368;
      
      
      if (HEAP[__PyIO_str_write] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 97;
        break;
      }
     case 97:
      var $371 = _PyString_InternFromString(__str73);
      HEAP[__PyIO_str_writable] = $371;
      
      
      if (HEAP[__PyIO_str_writable] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 98;
        break;
      }
     case 98:
      var $374 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      HEAP[__PyIO_empty_str] = $374;
      
      
      if (HEAP[__PyIO_empty_str] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 99;
        break;
      }
     case 99:
      var $377 = _PyString_FromStringAndSize(0, 0);
      HEAP[__PyIO_empty_bytes] = $377;
      
      
      if (HEAP[__PyIO_empty_bytes] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 100;
        break;
      }
     case 100:
      var $380 = _PyLong_FromLong(0);
      HEAP[__PyIO_zero] = $380;
      
      
      if (HEAP[__PyIO_zero] == 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 101;
        break;
      }
     case 101:
      __label__ = 110;
      break;
     case 102:
      
      
      if (HEAP[__PyIO_os_module] != 0) {
        __label__ = 103;
        break;
      } else {
        __label__ = 105;
        break;
      }
     case 103:
      var $385 = HEAP[__PyIO_os_module];
      HEAP[$_py_tmp] = $385;
      HEAP[__PyIO_os_module] = 0;
      
      
      
      var $389 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $391 = HEAP[$_py_tmp];
      HEAP[$391] = $389;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 105;
        break;
      }
     case 104:
      
      
      
      
      var $400 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $401 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$400]($401);
      __label__ = 105;
      break;
     case 105:
      
      
      if (HEAP[__PyIO_unsupported_operation] != 0) {
        __label__ = 106;
        break;
      } else {
        __label__ = 108;
        break;
      }
     case 106:
      var $404 = HEAP[__PyIO_unsupported_operation];
      HEAP[$_py_tmp105] = $404;
      HEAP[__PyIO_unsupported_operation] = 0;
      
      
      
      var $408 = HEAP[HEAP[$_py_tmp105]] - 1;
      
      var $410 = HEAP[$_py_tmp105];
      HEAP[$410] = $408;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp105]] == 0) {
        __label__ = 107;
        break;
      } else {
        __label__ = 108;
        break;
      }
     case 107:
      
      
      
      
      var $419 = HEAP[HEAP[HEAP[$_py_tmp105] + 4] + 24];
      var $420 = HEAP[$_py_tmp105];
      FUNCTION_TABLE[$419]($420);
      __label__ = 108;
      break;
     case 108:
      
      
      
      var $424 = HEAP[HEAP[$m]] - 1;
      
      var $426 = HEAP[$m];
      HEAP[$426] = $424;
      
      
      
      
      if (HEAP[HEAP[$m]] == 0) {
        __label__ = 109;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 109:
      
      
      
      
      var $435 = HEAP[HEAP[HEAP[$m] + 4] + 24];
      var $436 = HEAP[$m];
      FUNCTION_TABLE[$435]($436);
      __label__ = 110;
      break;
     case 110:
      __label__ = 111;
      break;
     case 111:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  Module["_init_io"] = _init_io;
  function _resize_buffer373($self, $size) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $size_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $iftmp_1 = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $alloc = __stackBase__ + 20;
      var $new_buf = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$size_addr] = $size;
      
      
      var $3 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$alloc] = $3;
      HEAP[$new_buf] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str319, __str1320, 61, ___PRETTY_FUNCTION___8390);
      throw "Reached an unreachable!";
     case 2:
      
      var $9 = HEAP[$size_addr] + 1;
      HEAP[$size_addr] = $9;
      
      
      if (HEAP[$size_addr] < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      var $12 = HEAP[$alloc];
      var $13 = Math.floor($12 / 2);
      
      
      if ($13 > HEAP[$size_addr]) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      var $17 = HEAP[$size_addr] + 1;
      HEAP[$alloc] = $17;
      __label__ = 13;
      break;
     case 5:
      
      
      
      if (HEAP[$size_addr] < HEAP[$alloc]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 7:
      
      
      
      
      
      
      if (HEAP[$size_addr] <= HEAP[$alloc] * 1.125) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      var $30 = (HEAP[$size_addr] >>> 3) + HEAP[$size_addr];
      
      
      if (HEAP[$size_addr] <= 8) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$iftmp_1] = 3;
      __label__ = 11;
      break;
     case 10:
      HEAP[$iftmp_1] = 6;
      __label__ = 11;
      break;
     case 11:
      
      var $34 = $30 + HEAP[$iftmp_1];
      HEAP[$alloc] = $34;
      __label__ = 13;
      break;
     case 12:
      
      var $36 = HEAP[$size_addr] + 1;
      HEAP[$alloc] = $36;
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$alloc] < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      var $40 = HEAP[$alloc] * 2;
      
      
      
      var $44 = HEAP[HEAP[$self_addr] + 8];
      var $45 = _PyMem_Realloc($44, $40);
      var $46 = $45;
      HEAP[$new_buf] = $46;
      
      
      if (HEAP[$new_buf] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $49 = _PyErr_NoMemory();
      HEAP[$0] = -1;
      __label__ = 18;
      break;
     case 16:
      
      var $51 = HEAP[$self_addr] + 20;
      var $52 = HEAP[$alloc];
      HEAP[$51] = $52;
      
      var $54 = HEAP[$self_addr] + 8;
      var $55 = HEAP[$new_buf];
      HEAP[$54] = $55;
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 17:
      var $56 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($56, __str2321);
      HEAP[$0] = -1;
      __label__ = 18;
      break;
     case 18:
      var $57 = HEAP[$0];
      HEAP[$retval] = $57;
      __label__ = 19;
      break;
     case 19:
      var $retval17 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval17;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _write_str($self, $obj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $obj_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $str = __stackBase__ + 16;
      var $len = __stackBase__ + 20;
      var $decoded = __stackBase__ + 24;
      var $translated = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$obj_addr] = $obj;
      HEAP[$decoded] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str319, __str1320, 114, ___PRETTY_FUNCTION___8432);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str3322, __str1320, 115, ___PRETTY_FUNCTION___8432);
      throw "Reached an unreachable!";
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      var $15 = HEAP[HEAP[$self_addr] + 28];
      var $16 = HEAP[$obj_addr];
      var $17 = __PyIncrementalNewlineDecoder_decode($15, $16, 1);
      HEAP[$decoded] = $17;
      __label__ = 7;
      break;
     case 6:
      var $18 = HEAP[$obj_addr];
      HEAP[$decoded] = $18;
      
      
      
      var $22 = HEAP[HEAP[$decoded]] + 1;
      
      var $24 = HEAP[$decoded];
      HEAP[$24] = $22;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      var $31 = HEAP[HEAP[$self_addr] + 36];
      var $32 = HEAP[__PyIO_str_nl];
      var $33 = HEAP[$decoded];
      var $34 = _PyUnicodeUCS2_Replace($33, $32, $31, -1);
      HEAP[$translated] = $34;
      
      
      
      var $38 = HEAP[HEAP[$decoded]] - 1;
      
      var $40 = HEAP[$decoded];
      HEAP[$40] = $38;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $49 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $50 = HEAP[$decoded];
      FUNCTION_TABLE[$49]($50);
      __label__ = 10;
      break;
     case 10:
      var $51 = HEAP[$translated];
      HEAP[$decoded] = $51;
      __label__ = 11;
      break;
     case 11:
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      HEAP[$0] = -1;
      __label__ = 32;
      break;
     case 13:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$decoded] + 4] + 84] & 268435456) == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      ___assert_fail(__str4323, __str1320, 134, ___PRETTY_FUNCTION___8432);
      throw "Reached an unreachable!";
     case 15:
      
      
      
      var $64 = HEAP[HEAP[$decoded] + 12];
      HEAP[$str] = $64;
      
      
      
      var $68 = HEAP[HEAP[$decoded] + 8];
      HEAP[$len] = $68;
      
      
      if (HEAP[$len] < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      ___assert_fail(__str5324, __str1320, 138, ___PRETTY_FUNCTION___8432);
      throw "Reached an unreachable!";
     case 17:
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] > 2147483647 - HEAP[$len]) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      var $77 = HEAP[_PyExc_OverflowError];
      _PyErr_SetString($77, __str6325);
      __label__ = 28;
      break;
     case 19:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] + HEAP[$len] > HEAP[HEAP[$self_addr] + 16]) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $91 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len];
      var $92 = HEAP[$self_addr];
      var $93 = _resize_buffer373($92, $91);
      
      if ($93 < 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] > HEAP[HEAP[$self_addr] + 16]) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      
      
      
      var $109 = (HEAP[HEAP[$self_addr] + 12] - HEAP[HEAP[$self_addr] + 16]) * 2;
      
      
      
      
      
      
      
      var $117 = HEAP[HEAP[$self_addr] + 8] + 2 * HEAP[HEAP[$self_addr] + 16];
      _llvm_memset_p0i8_i32($117, 0, $109, 1, 0);
      __label__ = 23;
      break;
     case 23:
      
      var $119 = HEAP[$len] * 2;
      
      
      
      
      
      
      
      
      var $128 = HEAP[HEAP[$self_addr] + 8] + 2 * HEAP[HEAP[$self_addr] + 12];
      var $129 = HEAP[$str];
      _llvm_memcpy_p0i8_p0i8_i32($128, $129, $119, 1, 0);
      
      
      
      
      var $134 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len];
      
      var $136 = HEAP[$self_addr] + 12;
      HEAP[$136] = $134;
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] < HEAP[HEAP[$self_addr] + 12]) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      var $146 = HEAP[HEAP[$self_addr] + 12];
      
      var $148 = HEAP[$self_addr] + 16;
      HEAP[$148] = $146;
      __label__ = 25;
      break;
     case 25:
      
      
      
      var $152 = HEAP[HEAP[$decoded]] - 1;
      
      var $154 = HEAP[$decoded];
      HEAP[$154] = $152;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $163 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $164 = HEAP[$decoded];
      FUNCTION_TABLE[$163]($164);
      __label__ = 27;
      break;
     case 27:
      HEAP[$0] = 0;
      __label__ = 32;
      break;
     case 28:
      
      
      if (HEAP[$decoded] != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 29:
      
      
      
      var $170 = HEAP[HEAP[$decoded]] - 1;
      
      var $172 = HEAP[$decoded];
      HEAP[$172] = $170;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      
      
      
      
      var $181 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $182 = HEAP[$decoded];
      FUNCTION_TABLE[$181]($182);
      __label__ = 31;
      break;
     case 31:
      HEAP[$0] = -1;
      __label__ = 32;
      break;
     case 32:
      var $183 = HEAP[$0];
      HEAP[$retval] = $183;
      __label__ = 33;
      break;
     case 33:
      var $retval31 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval31;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_getvalue($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 4:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 16];
      
      
      var $16 = HEAP[HEAP[$self_addr] + 8];
      var $17 = _PyUnicodeUCS2_FromUnicode($16, $13);
      HEAP[$0] = $17;
      __label__ = 5;
      break;
     case 5:
      var $18 = HEAP[$0];
      HEAP[$retval] = $18;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_tell($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 4:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 12];
      var $14 = _PyLong_FromSsize_t($13);
      HEAP[$0] = $14;
      __label__ = 5;
      break;
     case 5:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      var $output = __stackBase__ + 24;
      var $arg = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = __PyArg_ParseTuple_SizeT($6, __str9328, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      HEAP[$size] = $19;
      
      var $21 = HEAP[$size] == -1;
      if ($21) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 10:
      __label__ = 14;
      break;
     case 11:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      HEAP[$size] = -1;
      __label__ = 14;
      break;
     case 13:
      
      
      
      
      var $30 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str10329, allocate([ $30, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 19;
      break;
     case 14:
      
      
      
      
      
      
      var $39 = HEAP[HEAP[$self_addr] + 16] - HEAP[HEAP[$self_addr] + 12];
      HEAP[$n] = $39;
      
      
      if (HEAP[$size] < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      if (HEAP[$size] > HEAP[$n]) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      var $45 = HEAP[$n];
      HEAP[$size] = $45;
      
      
      if (HEAP[$size] < 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      HEAP[$size] = 0;
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      
      
      var $54 = HEAP[HEAP[$self_addr] + 8] + 2 * HEAP[HEAP[$self_addr] + 12];
      HEAP[$output] = $54;
      
      
      
      
      var $59 = HEAP[HEAP[$self_addr] + 12] + HEAP[$size];
      
      var $61 = HEAP[$self_addr] + 12;
      HEAP[$61] = $59;
      var $62 = HEAP[$output];
      var $63 = HEAP[$size];
      var $64 = _PyUnicodeUCS2_FromUnicode($62, $63);
      HEAP[$0] = $64;
      __label__ = 19;
      break;
     case 19:
      var $65 = HEAP[$0];
      HEAP[$retval] = $65;
      __label__ = 20;
      break;
     case 20:
      var $retval19 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval19;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __stringio_readline($self, $limit) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 34;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 34);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $limit_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $start = __stackBase__ + 16;
      var $end = __stackBase__ + 20;
      var $old_char = __stackBase__ + 24;
      var $len = __stackBase__ + 26;
      var $consumed = __stackBase__ + 30;
      
      HEAP[$self_addr] = $self;
      HEAP[$limit_addr] = $limit;
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] >= HEAP[HEAP[$self_addr] + 16]) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $8 = _PyUnicodeUCS2_FromString(__str11330);
      HEAP[$0] = $8;
      __label__ = 8;
      break;
     case 2:
      
      
      
      
      
      
      var $15 = HEAP[HEAP[$self_addr] + 8] + 2 * HEAP[HEAP[$self_addr] + 12];
      HEAP[$start] = $15;
      
      
      if (HEAP[$limit_addr] < 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 3:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] - HEAP[HEAP[$self_addr] + 12] < HEAP[$limit_addr]) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      
      
      var $33 = HEAP[HEAP[$self_addr] + 16] - HEAP[HEAP[$self_addr] + 12];
      HEAP[$limit_addr] = $33;
      __label__ = 5;
      break;
     case 5:
      
      
      var $36 = HEAP[$start] + 2 * HEAP[$limit_addr];
      HEAP[$end] = $36;
      
      var $38 = HEAP[HEAP[$end]];
      HEAP[$old_char] = $38;
      var $39 = HEAP[$end];
      HEAP[$39] = 0;
      
      
      var $42 = HEAP[HEAP[$self_addr] + 32];
      
      
      
      var $46 = HEAP[HEAP[$self_addr] + 26];
      
      
      
      var $50 = HEAP[HEAP[$self_addr] + 27];
      var $51 = HEAP[$start];
      var $52 = HEAP[$end];
      var $53 = __PyIO_find_line_ending($50, $46, $42, $51, $52, $consumed);
      HEAP[$len] = $53;
      var $54 = HEAP[$end];
      var $55 = HEAP[$old_char];
      HEAP[$54] = $55;
      
      
      if (HEAP[$len] < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $58 = HEAP[$limit_addr];
      HEAP[$len] = $58;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      var $63 = HEAP[HEAP[$self_addr] + 12] + HEAP[$len];
      
      var $65 = HEAP[$self_addr] + 12;
      HEAP[$65] = $63;
      var $66 = HEAP[$start];
      var $67 = HEAP[$len];
      var $68 = _PyUnicodeUCS2_FromUnicode($66, $67);
      HEAP[$0] = $68;
      __label__ = 8;
      break;
     case 8:
      var $69 = HEAP[$0];
      HEAP[$retval] = $69;
      __label__ = 9;
      break;
     case 9:
      var $retval8 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval8;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $arg = __stackBase__ + 16;
      var $limit = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      HEAP[$limit] = -1;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = __PyArg_ParseTuple_SizeT($6, __str12331, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      HEAP[$limit] = $19;
      
      var $21 = HEAP[$limit] == -1;
      if ($21) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 10:
      __label__ = 13;
      break;
     case 11:
      
      
      if (HEAP[$arg] != __Py_NoneStruct) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $30 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str10329, allocate([ $30, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 13:
      var $33 = HEAP[$self_addr];
      var $34 = HEAP[$limit];
      var $35 = __stringio_readline($33, $34);
      HEAP[$0] = $35;
      __label__ = 14;
      break;
     case 14:
      var $36 = HEAP[$0];
      HEAP[$retval] = $36;
      __label__ = 15;
      break;
     case 15:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $line = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 4:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyStringIO_Type) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $16 = HEAP[$self_addr];
      var $17 = __stringio_readline($16, -1);
      HEAP[$line] = $17;
      __label__ = 11;
      break;
     case 6:
      var $18 = HEAP[__PyIO_str_readline];
      
      var $20 = HEAP[$self_addr];
      var $21 = _PyObject_CallMethodObjArgs($20, $18, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$line] = $21;
      
      
      if (HEAP[$line] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$line] + 4] + 84] & 268435456) == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      
      
      
      
      var $35 = HEAP[HEAP[HEAP[$line] + 4] + 12];
      var $36 = HEAP[_PyExc_IOError];
      var $37 = _PyErr_Format($36, __str13332, allocate([ $35, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $41 = HEAP[HEAP[$line]] - 1;
      
      var $43 = HEAP[$line];
      HEAP[$43] = $41;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $52 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $53 = HEAP[$line];
      FUNCTION_TABLE[$52]($53);
      __label__ = 10;
      break;
     case 10:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 11:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 13:
      
      
      
      
      
      if (HEAP[HEAP[$line] + 8] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      var $64 = HEAP[HEAP[$line]] - 1;
      
      var $66 = HEAP[$line];
      HEAP[$66] = $64;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $75 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $76 = HEAP[$line];
      FUNCTION_TABLE[$75]($76);
      __label__ = 16;
      break;
     case 16:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 17:
      var $77 = HEAP[$line];
      HEAP[$0] = $77;
      __label__ = 18;
      break;
     case 18:
      var $78 = HEAP[$0];
      HEAP[$retval] = $78;
      __label__ = 19;
      break;
     case 19:
      var $retval18 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      var $arg = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$arg] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = __PyArg_ParseTuple_SizeT($6, __str14333, allocate([ $arg, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $13 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($13, __str8327);
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 6:
      var $14 = HEAP[$arg];
      var $15 = _PyNumber_Check($14);
      
      if ($15 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 7:
      var $17 = HEAP[_PyExc_OverflowError];
      var $18 = HEAP[$arg];
      var $19 = _PyNumber_AsSsize_t($18, $17);
      HEAP[$size] = $19;
      
      var $21 = HEAP[$size] == -1;
      if ($21) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      var $22 = _PyErr_Occurred();
      
      if ($22 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 10:
      __label__ = 14;
      break;
     case 11:
      
      
      if (HEAP[$arg] == __Py_NoneStruct) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      var $28 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$size] = $28;
      __label__ = 14;
      break;
     case 13:
      
      
      
      
      var $33 = HEAP[HEAP[HEAP[$arg] + 4] + 12];
      var $34 = HEAP[_PyExc_TypeError];
      var $35 = _PyErr_Format($34, __str10329, allocate([ $33, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 14:
      
      
      if (HEAP[$size] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $38 = HEAP[_PyExc_ValueError];
      var $39 = HEAP[$size];
      var $40 = _PyErr_Format($38, __str15334, allocate([ $39, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 16:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 16] > HEAP[$size]) {
        __label__ = 17;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 17:
      var $46 = HEAP[$size];
      var $47 = HEAP[$self_addr];
      var $48 = _resize_buffer373($47, $46);
      
      if ($48 < 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      HEAP[$0] = 0;
      __label__ = 21;
      break;
     case 19:
      
      var $51 = HEAP[$self_addr] + 16;
      var $52 = HEAP[$size];
      HEAP[$51] = $52;
      __label__ = 20;
      break;
     case 20:
      var $53 = HEAP[$size];
      var $54 = _PyLong_FromSsize_t($53);
      HEAP[$0] = $54;
      __label__ = 21;
      break;
     case 21:
      var $55 = HEAP[$0];
      HEAP[$retval] = $55;
      __label__ = 22;
      break;
     case 22:
      var $retval21 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval21;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $posobj = __stackBase__ + 16;
      var $pos = __stackBase__ + 20;
      var $mode = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$mode] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 2:
      var $6 = HEAP[$args_addr];
      var $7 = __PyArg_ParseTuple_SizeT($6, __str16335, allocate([ $posobj, 0, 0, 0, $mode, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($7 == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 4:
      var $9 = HEAP[_PyExc_OverflowError];
      var $10 = HEAP[$posobj];
      var $11 = _PyNumber_AsSsize_t($10, $9);
      HEAP[$pos] = $11;
      
      var $13 = HEAP[$pos] == -1;
      if ($13) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      var $14 = _PyErr_Occurred();
      
      if ($14 != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $20 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($20, __str8327);
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 9:
      
      
      if (HEAP[$mode] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      if (HEAP[$mode] == 1) {
        __label__ = 13;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 11:
      
      
      if (HEAP[$mode] == 2) {
        __label__ = 13;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      var $27 = HEAP[$mode];
      var $28 = HEAP[_PyExc_ValueError];
      var $29 = _PyErr_Format($28, __str17336, allocate([ $27, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 13:
      
      
      if (HEAP[$pos] >= 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      if (HEAP[$mode] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      var $34 = HEAP[_PyExc_ValueError];
      var $35 = HEAP[$pos];
      var $36 = _PyErr_Format($34, __str18337, allocate([ $35, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 16:
      
      
      if (HEAP[$mode] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 17:
      
      
      if (HEAP[$pos] != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      var $41 = HEAP[_PyExc_IOError];
      _PyErr_SetString($41, __str19338);
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 19:
      
      
      if (HEAP[$mode] == 1) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      var $46 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$pos] = $46;
      __label__ = 23;
      break;
     case 21:
      
      
      if (HEAP[$mode] == 2) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      var $51 = HEAP[HEAP[$self_addr] + 16];
      HEAP[$pos] = $51;
      __label__ = 23;
      break;
     case 23:
      
      var $53 = HEAP[$self_addr] + 12;
      var $54 = HEAP[$pos];
      HEAP[$53] = $54;
      
      
      var $57 = HEAP[HEAP[$self_addr] + 12];
      var $58 = _PyLong_FromSsize_t($57);
      HEAP[$0] = $58;
      __label__ = 24;
      break;
     case 24:
      var $59 = HEAP[$0];
      HEAP[$retval] = $59;
      __label__ = 25;
      break;
     case 25:
      var $retval24 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval24;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_write($self, $obj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $obj_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $size = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$obj_addr] = $obj;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 2:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$obj_addr] + 4] + 84] & 268435456) == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      
      var $17 = HEAP[HEAP[HEAP[$obj_addr] + 4] + 12];
      var $18 = HEAP[_PyExc_TypeError];
      var $19 = _PyErr_Format($18, __str20339, allocate([ $17, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $24 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($24, __str8327);
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 6:
      
      
      
      var $28 = HEAP[HEAP[$obj_addr] + 8];
      HEAP[$size] = $28;
      
      
      if (HEAP[$size] > 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      var $31 = HEAP[$self_addr];
      var $32 = HEAP[$obj_addr];
      var $33 = _write_str($31, $32);
      
      if ($33 < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 9:
      var $35 = HEAP[$size];
      var $36 = _PyLong_FromSsize_t($35);
      HEAP[$0] = $36;
      __label__ = 10;
      break;
     case 10:
      var $37 = HEAP[$0];
      HEAP[$retval] = $37;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_close($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      var $_py_tmp6 = __stackBase__ + 16;
      var $_py_tmp10 = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      var $2 = HEAP[$self_addr] + 25;
      HEAP[$2] = 1;
      var $3 = HEAP[$self_addr];
      var $4 = _resize_buffer373($3, 0);
      
      if ($4 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      var $12 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp] = $12;
      
      var $14 = HEAP[$self_addr] + 32;
      HEAP[$14] = 0;
      
      
      
      var $18 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $20 = HEAP[$_py_tmp];
      HEAP[$20] = $18;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $30 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$29]($30);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      var $37 = HEAP[HEAP[$self_addr] + 36];
      HEAP[$_py_tmp6] = $37;
      
      var $39 = HEAP[$self_addr] + 36;
      HEAP[$39] = 0;
      
      
      
      var $43 = HEAP[HEAP[$_py_tmp6]] - 1;
      
      var $45 = HEAP[$_py_tmp6];
      HEAP[$45] = $43;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp6]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$_py_tmp6] + 4] + 24];
      var $55 = HEAP[$_py_tmp6];
      FUNCTION_TABLE[$54]($55);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 9:
      
      
      var $62 = HEAP[HEAP[$self_addr] + 28];
      HEAP[$_py_tmp10] = $62;
      
      var $64 = HEAP[$self_addr] + 28;
      HEAP[$64] = 0;
      
      
      
      var $68 = HEAP[HEAP[$_py_tmp10]] - 1;
      
      var $70 = HEAP[$_py_tmp10];
      HEAP[$70] = $68;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp10]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $79 = HEAP[HEAP[HEAP[$_py_tmp10] + 4] + 24];
      var $80 = HEAP[$_py_tmp10];
      FUNCTION_TABLE[$79]($80);
      __label__ = 11;
      break;
     case 11:
      
      var $82 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $82;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 12:
      var $83 = HEAP[$0];
      HEAP[$retval] = $83;
      __label__ = 13;
      break;
     case 13:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 40];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 4;
      break;
     case 3:
      HEAP[$0] = 0;
      __label__ = 4;
      break;
     case 4:
      var $14 = HEAP[$0];
      HEAP[$retval] = $14;
      __label__ = 5;
      break;
     case 5:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$_py_tmp] = $7;
      
      var $9 = HEAP[$self_addr] + 40;
      HEAP[$9] = 0;
      
      
      
      var $13 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $15 = HEAP[$_py_tmp];
      HEAP[$15] = $13;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $24 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $25 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$24]($25);
      __label__ = 3;
      break;
     case 3:
      HEAP[$0] = 0;
      var $26 = HEAP[$0];
      HEAP[$retval] = $26;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      var $_py_tmp8 = __stackBase__ + 12;
      var $_py_tmp12 = __stackBase__ + 16;
      var $_py_tmp16 = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      
      
      var $2 = HEAP[$self_addr] + -12;
      HEAP[$g] = $2;
      
      
      
      
      var $7 = HEAP[HEAP[$g] + 8] == -2;
      if ($7) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str21340, __str1320, 516, ___PRETTY_FUNCTION___8969);
      throw "Reached an unreachable!";
     case 2:
      
      
      var $10 = HEAP[$g] + 8;
      HEAP[$10] = -2;
      
      
      
      
      
      
      
      var $18 = HEAP[HEAP[$g]];
      
      var $20 = HEAP[HEAP[$g] + 4];
      HEAP[$20] = $18;
      
      
      
      
      
      
      
      var $28 = HEAP[HEAP[$g] + 4];
      
      var $30 = HEAP[HEAP[$g]] + 4;
      HEAP[$30] = $28;
      
      
      var $33 = HEAP[$g];
      HEAP[$33] = 0;
      
      var $35 = HEAP[$self_addr] + 24;
      HEAP[$35] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      
      
      var $43 = HEAP[HEAP[$self_addr] + 8];
      _PyMem_Free($43);
      
      var $45 = HEAP[$self_addr] + 8;
      HEAP[$45] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 5:
      
      
      var $52 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp] = $52;
      
      var $54 = HEAP[$self_addr] + 32;
      HEAP[$54] = 0;
      
      
      
      var $58 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $60 = HEAP[$_py_tmp];
      HEAP[$60] = $58;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $69 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $70 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$69]($70);
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 8:
      
      
      var $77 = HEAP[HEAP[$self_addr] + 36];
      HEAP[$_py_tmp8] = $77;
      
      var $79 = HEAP[$self_addr] + 36;
      HEAP[$79] = 0;
      
      
      
      var $83 = HEAP[HEAP[$_py_tmp8]] - 1;
      
      var $85 = HEAP[$_py_tmp8];
      HEAP[$85] = $83;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp8]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $94 = HEAP[HEAP[HEAP[$_py_tmp8] + 4] + 24];
      var $95 = HEAP[$_py_tmp8];
      FUNCTION_TABLE[$94]($95);
      __label__ = 10;
      break;
     case 10:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      var $102 = HEAP[HEAP[$self_addr] + 28];
      HEAP[$_py_tmp12] = $102;
      
      var $104 = HEAP[$self_addr] + 28;
      HEAP[$104] = 0;
      
      
      
      var $108 = HEAP[HEAP[$_py_tmp12]] - 1;
      
      var $110 = HEAP[$_py_tmp12];
      HEAP[$110] = $108;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp12]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $119 = HEAP[HEAP[HEAP[$_py_tmp12] + 4] + 24];
      var $120 = HEAP[$_py_tmp12];
      FUNCTION_TABLE[$119]($120);
      __label__ = 13;
      break;
     case 13:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      var $127 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$_py_tmp16] = $127;
      
      var $129 = HEAP[$self_addr] + 40;
      HEAP[$129] = 0;
      
      
      
      var $133 = HEAP[HEAP[$_py_tmp16]] - 1;
      
      var $135 = HEAP[$_py_tmp16];
      HEAP[$135] = $133;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp16]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $144 = HEAP[HEAP[HEAP[$_py_tmp16] + 4] + 24];
      var $145 = HEAP[$_py_tmp16];
      FUNCTION_TABLE[$144]($145);
      __label__ = 16;
      break;
     case 16:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 44] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      var $151 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($151);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      
      var $157 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $159 = HEAP[$self_addr];
      FUNCTION_TABLE[$157]($159);
      __label__ = 19;
      break;
     case 19:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_new($type, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $type_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $self = __stackBase__ + 20;
      
      HEAP[$type_addr] = $type;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      
      if (HEAP[$type_addr] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$type_addr] + 152] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str22341, __str1320, 536, ___PRETTY_FUNCTION___9039);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $9 = HEAP[HEAP[$type_addr] + 152];
      var $10 = HEAP[$type_addr];
      var $11 = FUNCTION_TABLE[$9]($10, 0);
      var $12 = $11;
      HEAP[$self] = $12;
      
      
      if (HEAP[$self] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 5:
      var $15 = _PyMem_Malloc(0);
      
      
      var $18 = HEAP[$self] + 8;
      HEAP[$18] = $15;
      
      
      
      
      if (HEAP[HEAP[$self] + 8] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      var $24 = HEAP[$self];
      
      
      var $27 = HEAP[$24] - 1;
      var $28 = $24;
      HEAP[$28] = $27;
      
      
      
      if (HEAP[$24] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $37 = HEAP[HEAP[HEAP[$self] + 4] + 24];
      
      var $39 = HEAP[$self];
      FUNCTION_TABLE[$37]($39);
      __label__ = 8;
      break;
     case 8:
      var $40 = _PyErr_NoMemory();
      HEAP[$0] = $40;
      __label__ = 10;
      break;
     case 9:
      
      var $42 = HEAP[$self];
      HEAP[$0] = $42;
      __label__ = 10;
      break;
     case 10:
      var $43 = HEAP[$0];
      HEAP[$retval] = $43;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 60;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 60);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_90 = __stackBase__ + 16;
      var $0 = __stackBase__ + 20;
      var $kwlist = __stackBase__ + 24;
      var $value = __stackBase__ + 36;
      var $newline = __stackBase__ + 40;
      var $_py_tmp = __stackBase__ + 44;
      var $_py_tmp21 = __stackBase__ + 48;
      var $_py_tmp25 = __stackBase__ + 52;
      var $len = __stackBase__ + 56;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_71_9078];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_71_9078 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_71_9078 + 8];
      HEAP[$kwlist + 8] = $6;
      HEAP[$value] = 0;
      HEAP[$newline] = __str25344;
      var $7 = HEAP[$args_addr];
      var $8 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $9 = __PyArg_ParseTupleAndKeywords_SizeT($7, $8, __str26345, $kwlist1, allocate([ $value, 0, 0, 0, $newline, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($9 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 2:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 4:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 10) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 10) {
        __label__ = 11;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$newline] + 2] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $45 = HEAP[$newline];
      var $46 = HEAP[_PyExc_ValueError];
      var $47 = _PyErr_Format($46, __str27346, allocate([ $45, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 12:
      
      
      if (HEAP[$value] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 13:
      
      
      if (HEAP[$value] != __Py_NoneStruct) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$value] + 4] + 84] & 268435456) == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $63 = HEAP[HEAP[HEAP[$value] + 4] + 12];
      var $64 = HEAP[_PyExc_TypeError];
      var $65 = _PyErr_Format($64, __str28347, allocate([ $63, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 16:
      
      var $67 = HEAP[$self_addr] + 24;
      HEAP[$67] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 17:
      
      
      var $74 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp] = $74;
      
      var $76 = HEAP[$self_addr] + 32;
      HEAP[$76] = 0;
      
      
      
      var $80 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $82 = HEAP[$_py_tmp];
      HEAP[$82] = $80;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      
      
      var $91 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $92 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$91]($92);
      __label__ = 19;
      break;
     case 19:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 20:
      
      
      var $99 = HEAP[HEAP[$self_addr] + 36];
      HEAP[$_py_tmp21] = $99;
      
      var $101 = HEAP[$self_addr] + 36;
      HEAP[$101] = 0;
      
      
      
      var $105 = HEAP[HEAP[$_py_tmp21]] - 1;
      
      var $107 = HEAP[$_py_tmp21];
      HEAP[$107] = $105;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp21]] == 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 21:
      
      
      
      
      var $116 = HEAP[HEAP[HEAP[$_py_tmp21] + 4] + 24];
      var $117 = HEAP[$_py_tmp21];
      FUNCTION_TABLE[$116]($117);
      __label__ = 22;
      break;
     case 22:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      
      var $124 = HEAP[HEAP[$self_addr] + 28];
      HEAP[$_py_tmp25] = $124;
      
      var $126 = HEAP[$self_addr] + 28;
      HEAP[$126] = 0;
      
      
      
      var $130 = HEAP[HEAP[$_py_tmp25]] - 1;
      
      var $132 = HEAP[$_py_tmp25];
      HEAP[$132] = $130;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp25]] == 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      
      
      
      
      var $141 = HEAP[HEAP[HEAP[$_py_tmp25] + 4] + 24];
      var $142 = HEAP[$_py_tmp25];
      FUNCTION_TABLE[$141]($142);
      __label__ = 25;
      break;
     case 25:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 26:
      var $145 = HEAP[$newline];
      var $146 = _PyString_FromString($145);
      
      var $148 = HEAP[$self_addr] + 32;
      HEAP[$148] = $146;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 28:
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      HEAP[$iftmp_90] = 1;
      __label__ = 32;
      break;
     case 31:
      HEAP[$iftmp_90] = 0;
      __label__ = 32;
      break;
     case 32:
      
      var $160 = HEAP[$iftmp_90] & 255;
      
      var $162 = HEAP[$self_addr] + 26;
      HEAP[$162] = $160;
      
      
      var $165 = HEAP[$newline] == 0;
      
      var $167 = HEAP[$self_addr] + 27;
      HEAP[$167] = $165;
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 33:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 13) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      var $174 = HEAP[$newline];
      var $175 = _PyUnicodeUCS2_FromString($174);
      
      var $177 = HEAP[$self_addr] + 36;
      HEAP[$177] = $175;
      __label__ = 35;
      break;
     case 35:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 26] != 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 36:
      
      
      
      var $185 = HEAP[HEAP[$self_addr] + 27];
      var $186 = __PyObject_CallFunction_SizeT(_PyIncrementalNewlineDecoder_Type, __str29348, allocate([ __Py_NoneStruct, 0, 0, 0, $185, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      
      var $188 = HEAP[$self_addr] + 28;
      HEAP[$188] = $186;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 38:
      
      var $194 = HEAP[$self_addr] + 16;
      HEAP[$194] = 0;
      
      
      if (HEAP[$value] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 39:
      
      
      if (HEAP[$value] == __Py_NoneStruct) {
        __label__ = 45;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 40:
      var $199 = HEAP[$value];
      var $200 = _PyUnicodeUCS2_GetSize($199);
      HEAP[$len] = $200;
      var $201 = HEAP[$len];
      var $202 = HEAP[$self_addr];
      var $203 = _resize_buffer373($202, $201);
      
      if ($203 < 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 42:
      
      var $206 = HEAP[$self_addr] + 12;
      HEAP[$206] = 0;
      var $207 = HEAP[$value];
      var $208 = HEAP[$self_addr];
      var $209 = _write_str($208, $207);
      
      if ($209 < 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 44:
      __label__ = 47;
      break;
     case 45:
      var $211 = HEAP[$self_addr];
      var $212 = _resize_buffer373($211, 0);
      
      if ($212 < 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      HEAP[$0] = -1;
      __label__ = 48;
      break;
     case 47:
      
      var $215 = HEAP[$self_addr] + 12;
      HEAP[$215] = 0;
      
      var $217 = HEAP[$self_addr] + 25;
      HEAP[$217] = 0;
      
      var $219 = HEAP[$self_addr] + 24;
      HEAP[$219] = 1;
      HEAP[$0] = 0;
      __label__ = 48;
      break;
     case 48:
      var $220 = HEAP[$0];
      HEAP[$retval] = $220;
      __label__ = 49;
      break;
     case 49:
      var $retval51 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval51;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_seekable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[__Py_TrueStruct] + 1;
      
      HEAP[__Py_TrueStruct] = $8;
      HEAP[$0] = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[__Py_TrueStruct] + 1;
      
      HEAP[__Py_TrueStruct] = $8;
      HEAP[$0] = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      var $8 = HEAP[__Py_TrueStruct] + 1;
      
      HEAP[__Py_TrueStruct] = $8;
      HEAP[$0] = __Py_TrueStruct;
      __label__ = 3;
      break;
     case 3:
      var $10 = HEAP[$0];
      HEAP[$retval] = $10;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_getstate($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $iftmp_109 = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $initvalue = __stackBase__ + 16;
      var $dict = __stackBase__ + 20;
      var $state = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      var $1 = HEAP[$self_addr];
      var $2 = _stringio_getvalue($1);
      HEAP[$initvalue] = $2;
      
      
      if (HEAP[$initvalue] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      
      var $10 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $10;
      HEAP[$dict] = __Py_NoneStruct;
      __label__ = 6;
      break;
     case 4:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 40];
      var $14 = _PyDict_Copy($13);
      HEAP[$dict] = $14;
      
      
      if (HEAP[$dict] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 6:
      
      
      var $19 = HEAP[HEAP[$self_addr] + 12];
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      var $26 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$iftmp_109] = $26;
      __label__ = 9;
      break;
     case 8:
      HEAP[$iftmp_109] = __Py_NoneStruct;
      __label__ = 9;
      break;
     case 9:
      var $27 = HEAP[$initvalue];
      var $28 = HEAP[$iftmp_109];
      var $29 = HEAP[$dict];
      var $30 = __Py_BuildValue_SizeT(__str30349, allocate([ $27, 0, 0, 0, $28, 0, 0, 0, $19, 0, 0, 0, $29, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$state] = $30;
      
      
      
      var $34 = HEAP[HEAP[$initvalue]] - 1;
      
      var $36 = HEAP[$initvalue];
      HEAP[$36] = $34;
      
      
      
      
      if (HEAP[HEAP[$initvalue]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $45 = HEAP[HEAP[HEAP[$initvalue] + 4] + 24];
      var $46 = HEAP[$initvalue];
      FUNCTION_TABLE[$45]($46);
      __label__ = 11;
      break;
     case 11:
      var $47 = HEAP[$state];
      HEAP[$0] = $47;
      __label__ = 12;
      break;
     case 12:
      var $48 = HEAP[$0];
      HEAP[$retval] = $48;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_setstate($self, $state) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $state_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $initarg = __stackBase__ + 16;
      var $position_obj = __stackBase__ + 20;
      var $dict = __stackBase__ + 24;
      var $pos = __stackBase__ + 28;
      var $buf = __stackBase__ + 32;
      var $bufsize = __stackBase__ + 36;
      
      HEAP[$self_addr] = $self;
      HEAP[$state_addr] = $state;
      
      
      if (HEAP[$state_addr] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      ___assert_fail(__str31350, __str1320, 702, ___PRETTY_FUNCTION___9300);
      throw "Reached an unreachable!";
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $7 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($7, __str8327);
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 4:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$state_addr] + 4] + 84] & 67108864) == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      
      if (HEAP[HEAP[$state_addr] + 8] <= 3) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $24 = HEAP[HEAP[HEAP[$state_addr] + 4] + 12];
      
      
      
      
      
      var $30 = HEAP[HEAP[HEAP[$self_addr] + 4] + 12];
      var $31 = HEAP[_PyExc_TypeError];
      var $32 = _PyErr_Format($31, __str32351, allocate([ $30, 0, 0, 0, $24, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 7:
      var $33 = HEAP[$state_addr];
      var $34 = _PyTuple_GetSlice($33, 0, 2);
      HEAP[$initarg] = $34;
      
      
      if (HEAP[$initarg] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 9:
      var $37 = HEAP[$self_addr];
      var $38 = HEAP[$initarg];
      var $39 = _stringio_init($37, $38, 0);
      
      if ($39 < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 10:
      
      
      
      var $44 = HEAP[HEAP[$initarg]] - 1;
      
      var $46 = HEAP[$initarg];
      HEAP[$46] = $44;
      
      
      
      
      if (HEAP[HEAP[$initarg]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $55 = HEAP[HEAP[HEAP[$initarg] + 4] + 24];
      var $56 = HEAP[$initarg];
      FUNCTION_TABLE[$55]($56);
      __label__ = 12;
      break;
     case 12:
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 13:
      
      
      
      var $60 = HEAP[HEAP[$initarg]] - 1;
      
      var $62 = HEAP[$initarg];
      HEAP[$62] = $60;
      
      
      
      
      if (HEAP[HEAP[$initarg]] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $71 = HEAP[HEAP[HEAP[$initarg] + 4] + 24];
      var $72 = HEAP[$initarg];
      FUNCTION_TABLE[$71]($72);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      
      
      
      var $80 = HEAP[HEAP[HEAP[$state_addr] + 12] + 12];
      HEAP[$buf] = $80;
      
      
      
      
      
      
      
      var $88 = HEAP[HEAP[HEAP[$state_addr] + 12] + 8];
      HEAP[$bufsize] = $88;
      var $89 = HEAP[$bufsize];
      var $90 = HEAP[$self_addr];
      var $91 = _resize_buffer373($90, $89);
      
      if ($91 < 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 17:
      
      var $94 = HEAP[$bufsize] * 2;
      
      
      
      
      var $99 = HEAP[HEAP[$self_addr] + 8];
      var $100 = HEAP[$buf];
      _llvm_memcpy_p0i8_p0i8_i32($99, $100, $94, 1, 0);
      
      var $102 = HEAP[$self_addr] + 16;
      var $103 = HEAP[$bufsize];
      HEAP[$102] = $103;
      
      
      
      
      var $108 = HEAP[HEAP[$state_addr] + 12 + 8];
      HEAP[$position_obj] = $108;
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$position_obj] + 4] + 48] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 18:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$position_obj] + 4] + 84] & 131072) == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[HEAP[$position_obj] + 4] + 48] + 152] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $134 = HEAP[HEAP[HEAP[$position_obj] + 4] + 12];
      var $135 = HEAP[_PyExc_TypeError];
      var $136 = _PyErr_Format($135, __str33352, allocate([ $134, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 21:
      var $137 = HEAP[_PyExc_OverflowError];
      var $138 = HEAP[$position_obj];
      var $139 = _PyNumber_AsSsize_t($138, $137);
      HEAP[$pos] = $139;
      
      var $141 = HEAP[$pos] == -1;
      if ($141) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      var $142 = _PyErr_Occurred();
      
      if ($142 != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 24:
      
      
      if (HEAP[$pos] < 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      var $146 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($146, __str34353);
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 26:
      
      var $148 = HEAP[$self_addr] + 12;
      var $149 = HEAP[$pos];
      HEAP[$148] = $149;
      
      
      
      
      var $154 = HEAP[HEAP[$state_addr] + 12 + 12];
      HEAP[$dict] = $154;
      
      
      if (HEAP[$dict] != __Py_NoneStruct) {
        __label__ = 27;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 27:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$dict] + 4] + 84] & 536870912) == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      
      var $168 = HEAP[HEAP[HEAP[$dict] + 4] + 12];
      var $169 = HEAP[_PyExc_TypeError];
      var $170 = _PyErr_Format($169, __str35354, allocate([ $168, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 29:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 30:
      
      
      var $177 = HEAP[HEAP[$self_addr] + 40];
      var $178 = HEAP[$dict];
      var $179 = _PyDict_Update($177, $178);
      
      if ($179 < 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      HEAP[$0] = 0;
      __label__ = 35;
      break;
     case 32:
      __label__ = 34;
      break;
     case 33:
      
      
      
      var $184 = HEAP[HEAP[$dict]] + 1;
      
      var $186 = HEAP[$dict];
      HEAP[$186] = $184;
      
      var $188 = HEAP[$self_addr] + 40;
      var $189 = HEAP[$dict];
      HEAP[$188] = $189;
      __label__ = 34;
      break;
     case 34:
      
      var $191 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $191;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 35;
      break;
     case 35:
      var $192 = HEAP[$0];
      HEAP[$retval] = $192;
      __label__ = 36;
      break;
     case 36:
      var $retval35 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval35;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_closed($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      
      
      
      var $9 = HEAP[HEAP[$self_addr] + 25];
      var $10 = _PyBool_FromLong($9);
      HEAP[$0] = $10;
      __label__ = 3;
      break;
     case 3:
      var $11 = HEAP[$0];
      HEAP[$retval] = $11;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_line_buffering($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 4:
      
      
      var $13 = HEAP[__Py_ZeroStruct] + 1;
      
      HEAP[__Py_ZeroStruct] = $13;
      HEAP[$0] = __Py_ZeroStruct;
      __label__ = 5;
      break;
     case 5:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _stringio_newlines($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($5, __str7326);
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 25] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str8327);
      HEAP[$0] = 0;
      __label__ = 7;
      break;
     case 4:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      var $16 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $16;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 7;
      break;
     case 6:
      var $17 = HEAP[__PyIO_str_newlines];
      
      
      var $20 = HEAP[HEAP[$self_addr] + 28];
      var $21 = _PyObject_GetAttr($20, $17);
      HEAP[$0] = $21;
      __label__ = 7;
      break;
     case 7:
      var $22 = HEAP[$0];
      HEAP[$retval] = $22;
      __label__ = 8;
      break;
     case 8:
      var $retval7 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __unsupported($message) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $message;
      var $1 = HEAP[__PyIO_unsupported_operation];
      var $2 = HEAP[__stackBase__];
      _PyErr_SetString($1, $2);
      HEAP[$0] = 0;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_detach($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      
      HEAP[__stackBase__] = $self;
      var $1 = __unsupported(__str374);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = __unsupported(__str1375);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = __unsupported(__str2376);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$args_addr] = $args;
      var $1 = __unsupported(__str3377);
      HEAP[$0] = $1;
      var $2 = HEAP[$0];
      HEAP[$retval] = $2;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_encoding_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$context_addr] = $context;
      
      var $2 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $2;
      HEAP[$0] = __Py_NoneStruct;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_newlines_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$context_addr] = $context;
      
      var $2 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $2;
      HEAP[$0] = __Py_NoneStruct;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiobase_errors_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[__stackBase__] = $self;
      HEAP[$context_addr] = $context;
      
      var $2 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $2;
      HEAP[$0] = __Py_NoneStruct;
      var $3 = HEAP[$0];
      HEAP[$retval] = $3;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 48;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 48);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $decoder = __stackBase__ + 20;
      var $translate = __stackBase__ + 24;
      var $errors = __stackBase__ + 28;
      var $kwlist = __stackBase__ + 32;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      HEAP[$errors] = 0;
      
      var $2 = HEAP[_C_1_8453];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_1_8453 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_1_8453 + 8];
      HEAP[$kwlist + 8] = $6;
      
      var $8 = HEAP[_C_1_8453 + 12];
      HEAP[$kwlist + 12] = $8;
      var $9 = HEAP[$args_addr];
      var $10 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $11 = __PyArg_ParseTupleAndKeywords_SizeT($9, $10, __str10385, $kwlist1, allocate([ $decoder, 0, 0, 0, $translate, 0, 0, 0, $errors, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($11 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 8;
      break;
     case 2:
      var $13 = HEAP[$decoder];
      
      var $15 = HEAP[$self_addr] + 8;
      HEAP[$15] = $13;
      
      
      
      var $19 = HEAP[HEAP[$decoder]] + 1;
      var $20 = HEAP[$decoder];
      HEAP[$20] = $19;
      
      
      if (HEAP[$errors] == 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      var $23 = _PyUnicodeUCS2_FromString(__str11386);
      
      var $25 = HEAP[$self_addr] + 12;
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = -1;
      __label__ = 8;
      break;
     case 5:
      __label__ = 7;
      break;
     case 6:
      
      
      
      var $33 = HEAP[HEAP[$errors]] + 1;
      var $34 = HEAP[$errors];
      HEAP[$34] = $33;
      var $35 = HEAP[$errors];
      
      var $37 = HEAP[$self_addr] + 12;
      HEAP[$37] = $35;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      var $42 = HEAP[$self_addr] + 16;
      
      
      
      
      var $47 = HEAP[$42] & -3;
      var $48 = $47 | (HEAP[$translate] & 255 & 1) << 1 & 2;
      HEAP[$42] = $48;
      
      var $50 = HEAP[$self_addr] + 16;
      
      var $52 = HEAP[$50] & -29;
      HEAP[$50] = $52;
      
      var $54 = HEAP[$self_addr] + 16;
      
      var $56 = HEAP[$54] & -2;
      HEAP[$54] = $56;
      HEAP[$0] = 0;
      __label__ = 8;
      break;
     case 8:
      var $57 = HEAP[$0];
      HEAP[$retval] = $57;
      __label__ = 9;
      break;
     case 9:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $_py_tmp = __stackBase__ + 4;
      var $_py_tmp4 = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $6 = HEAP[HEAP[$self_addr] + 8];
      HEAP[$_py_tmp] = $6;
      
      var $8 = HEAP[$self_addr] + 8;
      HEAP[$8] = 0;
      
      
      
      var $12 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $14 = HEAP[$_py_tmp];
      HEAP[$14] = $12;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $24 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$23]($24);
      __label__ = 3;
      break;
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $31 = HEAP[HEAP[$self_addr] + 12];
      HEAP[$_py_tmp4] = $31;
      
      var $33 = HEAP[$self_addr] + 12;
      HEAP[$33] = 0;
      
      
      
      var $37 = HEAP[HEAP[$_py_tmp4]] - 1;
      
      var $39 = HEAP[$_py_tmp4];
      HEAP[$39] = $37;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp4]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $48 = HEAP[HEAP[HEAP[$_py_tmp4] + 4] + 24];
      var $49 = HEAP[$_py_tmp4];
      FUNCTION_TABLE[$48]($49);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      
      var $55 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $57 = HEAP[$self_addr];
      FUNCTION_TABLE[$55]($57);
      __label__ = 7;
      break;
     case 7:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIncrementalNewlineDecoder_decode($_self, $input, $final) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 106;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 106);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $_self_addr = __stackBase__;
      var $input_addr = __stackBase__ + 4;
      var $final_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_10 = __stackBase__ + 16;
      var $0 = __stackBase__ + 20;
      var $output = __stackBase__ + 24;
      var $output_len = __stackBase__ + 28;
      var $self = __stackBase__ + 32;
      var $out = __stackBase__ + 36;
      var $modified = __stackBase__ + 40;
      var $modified25 = __stackBase__ + 44;
      var $in_str = __stackBase__ + 48;
      var $len = __stackBase__ + 52;
      var $seennl = __stackBase__ + 56;
      var $only_lf = __stackBase__ + 60;
      var $s = __stackBase__ + 64;
      var $end = __stackBase__ + 68;
      var $c = __stackBase__ + 72;
      var $s49 = __stackBase__ + 74;
      var $end50 = __stackBase__ + 78;
      var $c54 = __stackBase__ + 82;
      var $translated = __stackBase__ + 84;
      var $out_str = __stackBase__ + 88;
      var $in = __stackBase__ + 92;
      var $out66 = __stackBase__ + 96;
      var $end67 = __stackBase__ + 100;
      var $c76 = __stackBase__ + 104;
      
      HEAP[$_self_addr] = $_self;
      HEAP[$input_addr] = $input;
      HEAP[$final_addr] = $final;
      
      var $2 = HEAP[$_self_addr];
      HEAP[$self] = $2;
      
      
      
      
      if (HEAP[HEAP[$self] + 8] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $7 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($7, __str12387);
      HEAP[$0] = 0;
      __label__ = 93;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self] + 8] != __Py_NoneStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 3:
      
      
      if (HEAP[$final_addr] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$iftmp_10] = __Py_TrueStruct;
      __label__ = 6;
      break;
     case 5:
      HEAP[$iftmp_10] = __Py_ZeroStruct;
      __label__ = 6;
      break;
     case 6:
      var $14 = HEAP[__PyIO_str_decode];
      
      
      var $17 = HEAP[HEAP[$self] + 8];
      var $18 = HEAP[$input_addr];
      var $19 = HEAP[$iftmp_10];
      var $20 = _PyObject_CallMethodObjArgs($17, $14, allocate([ $18, 0, 0, 0, $19, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$output] = $20;
      __label__ = 8;
      break;
     case 7:
      var $21 = HEAP[$input_addr];
      HEAP[$output] = $21;
      
      
      
      var $25 = HEAP[HEAP[$output]] + 1;
      var $26 = HEAP[$output];
      HEAP[$26] = $25;
      __label__ = 8;
      break;
     case 8:
      
      
      if (HEAP[$output] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 93;
      break;
     case 10:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$output] + 4] + 84] & 268435456) == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $36 = HEAP[_PyExc_TypeError];
      _PyErr_SetString($36, __str13388);
      __label__ = 90;
      break;
     case 12:
      
      
      
      var $40 = HEAP[HEAP[$output] + 8];
      HEAP[$output_len] = $40;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self] + 16] << 7 >> 7 & 1) != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 13:
      
      
      if (HEAP[$final_addr] != 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 14:
      
      
      if (HEAP[$output_len] > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 15:
      
      var $53 = HEAP[$output_len] + 1;
      var $54 = _PyUnicodeUCS2_FromUnicode(0, $53);
      HEAP[$modified] = $54;
      
      
      if (HEAP[$modified] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 16:
      
      
      
      var $60 = HEAP[HEAP[$modified] + 12];
      HEAP[$out] = $60;
      
      var $62 = HEAP[$out];
      HEAP[$62] = 13;
      
      var $64 = HEAP[$output_len] * 2;
      
      
      
      
      
      
      var $71 = HEAP[$out] + 2;
      var $72 = HEAP[HEAP[$output] + 12];
      _llvm_memcpy_p0i8_p0i8_i32($71, $72, $64, 1, 0);
      var $73 = HEAP[$output];
      
      
      var $76 = HEAP[$73] - 1;
      var $77 = $73;
      HEAP[$77] = $76;
      
      
      
      if (HEAP[$73] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $85 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $86 = HEAP[$output];
      FUNCTION_TABLE[$85]($86);
      __label__ = 18;
      break;
     case 18:
      var $87 = HEAP[$modified];
      HEAP[$output] = $87;
      
      var $89 = HEAP[$self] + 16;
      
      var $91 = HEAP[$89] & -2;
      HEAP[$89] = $91;
      
      var $93 = HEAP[$output_len] + 1;
      HEAP[$output_len] = $93;
      __label__ = 19;
      break;
     case 19:
      
      
      if (HEAP[$final_addr] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 20:
      
      
      if (HEAP[$output_len] > 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 21:
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$output] + 12] + 2 * (HEAP[$output_len] - 1)] == 13) {
        __label__ = 22;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 22:
      
      
      
      
      if (HEAP[HEAP[$output]] == 1) {
        __label__ = 23;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 23:
      
      var $112 = HEAP[$output_len] - 1;
      var $113 = _PyUnicodeUCS2_Resize($output, $112);
      
      if ($113 < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      __label__ = 29;
      break;
     case 25:
      
      var $116 = HEAP[$output_len] - 1;
      
      
      
      var $120 = HEAP[HEAP[$output] + 12];
      var $121 = _PyUnicodeUCS2_FromUnicode($120, $116);
      HEAP[$modified25] = $121;
      
      
      if (HEAP[$modified25] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      var $124 = HEAP[$output];
      
      
      var $127 = HEAP[$124] - 1;
      var $128 = $124;
      HEAP[$128] = $127;
      
      
      
      if (HEAP[$124] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $136 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $137 = HEAP[$output];
      FUNCTION_TABLE[$136]($137);
      __label__ = 28;
      break;
     case 28:
      var $138 = HEAP[$modified25];
      HEAP[$output] = $138;
      __label__ = 29;
      break;
     case 29:
      
      var $140 = HEAP[$self] + 16;
      
      var $142 = HEAP[$140] & -2;
      var $143 = $142 | 1;
      HEAP[$140] = $143;
      __label__ = 30;
      break;
     case 30:
      
      
      
      
      
      
      var $150 = HEAP[HEAP[$self] + 16] << 3 >>> 5 & 7;
      HEAP[$seennl] = $150;
      HEAP[$only_lf] = 0;
      
      
      
      var $154 = HEAP[HEAP[$output] + 12];
      HEAP[$in_str] = $154;
      
      
      
      var $158 = HEAP[HEAP[$output] + 8];
      HEAP[$len] = $158;
      
      
      if (HEAP[$len] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      var $161 = HEAP[$output];
      HEAP[$0] = $161;
      __label__ = 93;
      break;
     case 32:
      
      
      if (HEAP[$seennl] == 2) {
        __label__ = 34;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 33:
      
      
      if (HEAP[$seennl] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      
      var $167 = HEAP[$len] * 2;
      
      var $169 = HEAP[$in_str];
      var $170 = _memchr($169, 13, $167);
      
      var $172 = $170 == 0;
      HEAP[$only_lf] = $172;
      __label__ = 35;
      break;
     case 35:
      
      
      if (HEAP[$only_lf] != 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 36:
      
      
      if (HEAP[$seennl] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 37:
      
      var $178 = HEAP[$len] * 2;
      
      var $180 = HEAP[$in_str];
      var $181 = _memchr($180, 10, $178);
      
      if ($181 != 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 38:
      var $183 = HEAP[$in_str];
      HEAP[$s] = $183;
      
      
      var $186 = HEAP[$in_str] + 2 * HEAP[$len];
      HEAP[$end] = $186;
      __label__ = 39;
      break;
     case 39:
      __label__ = 41;
      break;
     case 40:
      
      var $188 = HEAP[$s] + 2;
      HEAP[$s] = $188;
      __label__ = 41;
      break;
     case 41:
      
      
      
      if (HEAP[HEAP[$s]] > 10) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 42:
      
      var $193 = HEAP[HEAP[$s]];
      HEAP[$c] = $193;
      
      var $195 = HEAP[$s] + 2;
      HEAP[$s] = $195;
      
      
      if (HEAP[$c] == 10) {
        __label__ = 43;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 43:
      
      var $199 = HEAP[$seennl] | 2;
      HEAP[$seennl] = $199;
      __label__ = 46;
      break;
     case 44:
      
      
      
      if (HEAP[$s] > HEAP[$end]) {
        __label__ = 46;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      __label__ = 39;
      break;
     case 46:
      __label__ = 89;
      break;
     case 47:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self] + 16] << 6 >> 7 & 1) == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 48:
      
      
      if (HEAP[$seennl] == 7) {
        __label__ = 62;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      var $212 = HEAP[$in_str];
      HEAP[$s49] = $212;
      
      
      var $215 = HEAP[$in_str] + 2 * HEAP[$len];
      HEAP[$end50] = $215;
      __label__ = 50;
      break;
     case 50:
      __label__ = 52;
      break;
     case 51:
      
      var $217 = HEAP[$s49] + 2;
      HEAP[$s49] = $217;
      __label__ = 52;
      break;
     case 52:
      
      
      
      if (HEAP[HEAP[$s49]] > 13) {
        __label__ = 51;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 53:
      
      var $222 = HEAP[HEAP[$s49]];
      HEAP[$c54] = $222;
      
      var $224 = HEAP[$s49] + 2;
      HEAP[$s49] = $224;
      
      
      if (HEAP[$c54] == 10) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      var $228 = HEAP[$seennl] | 2;
      HEAP[$seennl] = $228;
      __label__ = 59;
      break;
     case 55:
      
      
      if (HEAP[$c54] == 13) {
        __label__ = 56;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 56:
      
      
      
      if (HEAP[HEAP[$s49]] == 10) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      
      var $235 = HEAP[$seennl] | 4;
      HEAP[$seennl] = $235;
      
      var $237 = HEAP[$s49] + 2;
      HEAP[$s49] = $237;
      __label__ = 59;
      break;
     case 58:
      
      var $239 = HEAP[$seennl] | 1;
      HEAP[$seennl] = $239;
      __label__ = 59;
      break;
     case 59:
      
      
      
      if (HEAP[$s49] > HEAP[$end50]) {
        __label__ = 62;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      
      if (HEAP[$seennl] == 7) {
        __label__ = 62;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      __label__ = 50;
      break;
     case 62:
      __label__ = 89;
      break;
     case 63:
      HEAP[$translated] = 0;
      
      
      
      
      if (HEAP[HEAP[$output]] != 1) {
        __label__ = 64;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 64:
      var $249 = HEAP[$len];
      var $250 = _PyUnicodeUCS2_FromUnicode(0, $249);
      HEAP[$translated] = $250;
      
      
      if (HEAP[$translated] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      
      
      
      
      if (HEAP[HEAP[$translated]] != 1) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      ___assert_fail(__str14389, __str15390, 407, ___PRETTY_FUNCTION___8544);
      throw "Reached an unreachable!";
     case 67:
      
      var $258 = HEAP[$len] * 2;
      
      
      
      
      
      
      
      
      var $267 = HEAP[HEAP[$translated] + 12];
      var $268 = HEAP[HEAP[$output] + 12];
      _llvm_memcpy_p0i8_p0i8_i32($267, $268, $258, 1, 0);
      __label__ = 69;
      break;
     case 68:
      var $269 = HEAP[$output];
      HEAP[$translated] = $269;
      __label__ = 69;
      break;
     case 69:
      
      
      
      var $273 = HEAP[HEAP[$translated] + 12];
      HEAP[$out_str] = $273;
      var $274 = HEAP[$in_str];
      HEAP[$in] = $274;
      var $275 = HEAP[$out_str];
      HEAP[$out66] = $275;
      
      
      var $278 = HEAP[$in_str] + 2 * HEAP[$len];
      HEAP[$end67] = $278;
      __label__ = 70;
      break;
     case 70:
      __label__ = 72;
      break;
     case 71:
      var $279 = HEAP[$out66];
      var $280 = HEAP[$c76];
      HEAP[$279] = $280;
      
      var $282 = HEAP[$out66] + 2;
      HEAP[$out66] = $282;
      __label__ = 72;
      break;
     case 72:
      
      var $284 = HEAP[HEAP[$in]];
      HEAP[$c76] = $284;
      
      
      var $287 = HEAP[$c76] > 13;
      
      var $289 = HEAP[$in] + 2;
      HEAP[$in] = $289;
      
      if ($287 != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 73;
        break;
      }
     case 73:
      
      
      if (HEAP[$c76] == 10) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      var $292 = HEAP[$out66];
      var $293 = HEAP[$c76];
      HEAP[$292] = $293;
      
      var $295 = HEAP[$out66] + 2;
      HEAP[$out66] = $295;
      
      var $297 = HEAP[$seennl] | 2;
      HEAP[$seennl] = $297;
      __label__ = 82;
      break;
     case 75:
      
      
      if (HEAP[$c76] == 13) {
        __label__ = 76;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 76:
      
      
      
      if (HEAP[HEAP[$in]] == 10) {
        __label__ = 77;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 77:
      
      var $304 = HEAP[$in] + 2;
      HEAP[$in] = $304;
      
      var $306 = HEAP[$seennl] | 4;
      HEAP[$seennl] = $306;
      __label__ = 79;
      break;
     case 78:
      
      var $308 = HEAP[$seennl] | 1;
      HEAP[$seennl] = $308;
      __label__ = 79;
      break;
     case 79:
      var $309 = HEAP[$out66];
      HEAP[$309] = 10;
      
      var $311 = HEAP[$out66] + 2;
      HEAP[$out66] = $311;
      __label__ = 82;
      break;
     case 80:
      
      
      
      if (HEAP[$in] > HEAP[$end67]) {
        __label__ = 83;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      var $315 = HEAP[$out66];
      var $316 = HEAP[$c76];
      HEAP[$315] = $316;
      
      var $318 = HEAP[$out66] + 2;
      HEAP[$out66] = $318;
      __label__ = 82;
      break;
     case 82:
      __label__ = 70;
      break;
     case 83:
      
      
      
      if (HEAP[$translated] != HEAP[$output]) {
        __label__ = 84;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 84:
      var $322 = HEAP[$output];
      
      
      var $325 = HEAP[$322] - 1;
      var $326 = $322;
      HEAP[$326] = $325;
      
      
      
      if (HEAP[$322] == 0) {
        __label__ = 85;
        break;
      } else {
        __label__ = 86;
        break;
      }
     case 85:
      
      
      
      
      var $334 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $335 = HEAP[$output];
      FUNCTION_TABLE[$334]($335);
      __label__ = 86;
      break;
     case 86:
      var $336 = HEAP[$translated];
      HEAP[$output] = $336;
      __label__ = 87;
      break;
     case 87:
      
      
      
      
      
      
      
      
      if (((HEAP[$out66] - HEAP[$out_str]) / 2 | 0) != HEAP[$len]) {
        __label__ = 88;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 88:
      
      
      
      
      
      var $350 = (HEAP[$out66] - HEAP[$out_str]) / 2 | 0;
      var $351 = _PyUnicodeUCS2_Resize($output, $350);
      
      if ($351 < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 89:
      
      
      
      
      
      
      
      
      
      
      
      
      var $365 = HEAP[$self] + 16;
      
      
      
      
      var $370 = HEAP[$365] & -29;
      var $371 = $370 | ((HEAP[HEAP[$self] + 16] << 3 >>> 5 & 7 | HEAP[$seennl] & 255) & 7) << 2 & 28;
      HEAP[$365] = $371;
      var $372 = HEAP[$output];
      HEAP[$0] = $372;
      __label__ = 93;
      break;
     case 90:
      var $373 = HEAP[$output];
      
      
      var $376 = HEAP[$373] - 1;
      var $377 = $373;
      HEAP[$377] = $376;
      
      
      
      if (HEAP[$373] == 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 91:
      
      
      
      
      var $385 = HEAP[HEAP[HEAP[$output] + 4] + 24];
      var $386 = HEAP[$output];
      FUNCTION_TABLE[$385]($386);
      __label__ = 92;
      break;
     case 92:
      HEAP[$0] = 0;
      __label__ = 93;
      break;
     case 93:
      var $387 = HEAP[$0];
      HEAP[$retval] = $387;
      __label__ = 94;
      break;
     case 94:
      var $retval98 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval98;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_decode($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 40;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 40);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $kwlist = __stackBase__ + 20;
      var $input = __stackBase__ + 32;
      var $final = __stackBase__ + 36;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_56_8766];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_56_8766 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_56_8766 + 8];
      HEAP[$kwlist + 8] = $6;
      HEAP[$final] = 0;
      var $7 = HEAP[$args_addr];
      var $8 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $9 = __PyArg_ParseTupleAndKeywords_SizeT($7, $8, __str18393, $kwlist1, allocate([ $input, 0, 0, 0, $final, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($9 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 3;
      break;
     case 2:
      var $11 = HEAP[$final];
      var $12 = HEAP[$input];
      
      var $14 = HEAP[$self_addr];
      var $15 = __PyIncrementalNewlineDecoder_decode($14, $12, $11);
      HEAP[$0] = $15;
      __label__ = 3;
      break;
     case 3:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 4;
      break;
     case 4:
      var $retval4 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval4;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_getstate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 32;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 32);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buffer = __stackBase__ + 16;
      var $flag = __stackBase__ + 20;
      var $state = __stackBase__ + 28;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 1:
      var $5 = HEAP[__PyIO_str_getstate];
      
      
      var $8 = HEAP[HEAP[$self_addr] + 8];
      var $9 = _PyObject_CallMethodObjArgs($8, $5, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$state] = $9;
      
      
      if (HEAP[$state] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 3:
      var $12 = HEAP[$state];
      var $13 = __PyArg_Parse_SizeT($12, __str19394, allocate([ $buffer, 0, 0, 0, $flag, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i64*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($13 == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 4:
      
      
      
      var $18 = HEAP[HEAP[$state]] - 1;
      
      var $20 = HEAP[$state];
      HEAP[$20] = $18;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $29 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $30 = HEAP[$state];
      FUNCTION_TABLE[$29]($30);
      __label__ = 6;
      break;
     case 6:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 7:
      
      
      
      var $34 = HEAP[HEAP[$buffer]] + 1;
      var $35 = HEAP[$buffer];
      HEAP[$35] = $34;
      
      
      
      var $39 = HEAP[HEAP[$state]] - 1;
      
      var $41 = HEAP[$state];
      HEAP[$41] = $39;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $50 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $51 = HEAP[$state];
      FUNCTION_TABLE[$50]($51);
      __label__ = 9;
      break;
     case 9:
      __label__ = 11;
      break;
     case 10:
      var $52 = _PyString_FromString(__str20395);
      HEAP[$buffer] = $52;
      HEAP[$flag] = 0;
      __label__ = 11;
      break;
     case 11:
      
      var $54 = HEAP[$flag] * Math.pow(2, 1);
      HEAP[$flag] = $54;
      
      
      
      
      
      
      
      if ((HEAP[HEAP[$self_addr] + 16] << 7 >> 7 & 1) != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      var $62 = HEAP[$flag];
      var $63 = Runtime.or64($62, 1);
      HEAP[$flag] = $63;
      __label__ = 13;
      break;
     case 13:
      var $64 = HEAP[$flag];
      var $65 = HEAP[$buffer];
      var $66 = __Py_BuildValue_SizeT(__str21396, allocate([ $65, 0, 0, 0, $64, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $66;
      __label__ = 14;
      break;
     case 14:
      var $67 = HEAP[$0];
      HEAP[$retval] = $67;
      __label__ = 15;
      break;
     case 15:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_setstate($self, $state) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $state_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buffer = __stackBase__ + 16;
      var $flag = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$state_addr] = $state;
      var $1 = HEAP[$state_addr];
      var $2 = __PyArg_Parse_SizeT($1, __str19394, allocate([ $buffer, 0, 0, 0, $flag, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i64*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($2 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 5;
      break;
     case 2:
      
      
      
      
      var $8 = HEAP[$self_addr] + 16;
      
      
      
      var $12 = HEAP[$8] & -2;
      var $13 = $12 | HEAP[$flag] & 255 & 1 & 1;
      HEAP[$8] = $13;
      
      var $15 = HEAP[$flag] / Math.pow(2, 1);
      HEAP[$flag] = $15;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != __Py_NoneStruct) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      var $20 = HEAP[$flag];
      var $21 = HEAP[$buffer];
      
      
      var $24 = HEAP[HEAP[$self_addr] + 8];
      var $25 = __PyObject_CallMethod_SizeT($24, __str22397, __str23398, allocate([ $21, 0, 0, 0, $20, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i64", 0, 0, 0, 0, 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $25;
      __label__ = 5;
      break;
     case 4:
      
      var $27 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $27;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 5;
      break;
     case 5:
      var $28 = HEAP[$0];
      HEAP[$retval] = $28;
      __label__ = 6;
      break;
     case 6:
      var $retval5 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval5;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_reset($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      var $2 = HEAP[$self_addr] + 16;
      
      var $4 = HEAP[$2] & -29;
      HEAP[$2] = $4;
      
      var $6 = HEAP[$self_addr] + 16;
      
      var $8 = HEAP[$6] & -2;
      HEAP[$6] = $8;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != __Py_NoneStruct) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $13 = HEAP[__PyIO_str_reset];
      
      
      var $16 = HEAP[HEAP[$self_addr] + 8];
      var $17 = _PyObject_CallMethodObjArgs($16, $13, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$0] = $17;
      __label__ = 3;
      break;
     case 2:
      
      var $19 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $19;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 3;
      break;
     case 3:
      var $20 = HEAP[$0];
      HEAP[$retval] = $20;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _incrementalnewlinedecoder_newlines_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      
      
      var $7 = HEAP[HEAP[$self_addr] + 16] << 3 >>> 5 & 7;
      if ($7 == 1) {
        __label__ = 1;
        break;
      } else if ($7 == 2) {
        __label__ = 2;
        break;
      } else if ($7 == 3) {
        __label__ = 4;
        break;
      } else if ($7 == 4) {
        __label__ = 3;
        break;
      } else if ($7 == 5) {
        __label__ = 5;
        break;
      } else if ($7 == 6) {
        __label__ = 6;
        break;
      } else if ($7 == 7) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 1:
      var $8 = _PyUnicodeUCS2_FromString(__str24399);
      HEAP[$0] = $8;
      __label__ = 9;
      break;
     case 2:
      var $9 = _PyUnicodeUCS2_FromString(__str25400);
      HEAP[$0] = $9;
      __label__ = 9;
      break;
     case 3:
      var $10 = _PyUnicodeUCS2_FromString(__str26401);
      HEAP[$0] = $10;
      __label__ = 9;
      break;
     case 4:
      var $11 = __Py_BuildValue_SizeT(__str27402, allocate([ __str24399, 0, 0, 0, __str25400, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $11;
      __label__ = 9;
      break;
     case 5:
      var $12 = __Py_BuildValue_SizeT(__str27402, allocate([ __str24399, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $12;
      __label__ = 9;
      break;
     case 6:
      var $13 = __Py_BuildValue_SizeT(__str27402, allocate([ __str25400, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $13;
      __label__ = 9;
      break;
     case 7:
      var $14 = __Py_BuildValue_SizeT(__str28403, allocate([ __str24399, 0, 0, 0, __str25400, 0, 0, 0, __str26401, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 9;
      break;
     case 8:
      
      var $16 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $16;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 9;
      break;
     case 9:
      var $17 = HEAP[$0];
      HEAP[$retval] = $17;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _ascii_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeASCII($14, $10, $6);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf16be_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeUTF16($14, $10, $6, 1);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf16le_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeUTF16($14, $10, $6, -1);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf16_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[$self_addr];
      var $6 = HEAP[$text_addr];
      var $7 = _utf16le_encode($5, $6);
      HEAP[$0] = $7;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      var $13 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $17 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $21 = HEAP[HEAP[$text_addr] + 12];
      var $22 = _PyUnicodeUCS2_EncodeUTF16($21, $17, $13, 0);
      HEAP[$0] = $22;
      __label__ = 3;
      break;
     case 3:
      var $23 = HEAP[$0];
      HEAP[$retval] = $23;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf32be_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeUTF32($14, $10, $6, 1);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf32le_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeUTF32($14, $10, $6, -1);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf32_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 60] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[$self_addr];
      var $6 = HEAP[$text_addr];
      var $7 = _utf32le_encode($5, $6);
      HEAP[$0] = $7;
      __label__ = 3;
      break;
     case 2:
      
      
      
      
      
      var $13 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $17 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $21 = HEAP[HEAP[$text_addr] + 12];
      var $22 = _PyUnicodeUCS2_EncodeUTF32($21, $17, $13, 0);
      HEAP[$0] = $22;
      __label__ = 3;
      break;
     case 3:
      var $23 = HEAP[$0];
      HEAP[$retval] = $23;
      __label__ = 4;
      break;
     case 4:
      var $retval3 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval3;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _utf8_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeUTF8($14, $10, $6);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _latin1_encode($self, $text) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $text_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$text_addr] = $text;
      
      
      
      
      
      var $6 = HEAP[HEAP[$self_addr] + 40] + 20;
      
      
      
      var $10 = HEAP[HEAP[$text_addr] + 8];
      
      
      
      var $14 = HEAP[HEAP[$text_addr] + 12];
      var $15 = _PyUnicodeUCS2_EncodeLatin1($14, $10, $6);
      HEAP[$0] = $15;
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 1;
      break;
     case 1:
      var $retval1 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval1;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_init($self, $args, $kwds) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 152;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 152);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $kwds_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $iftmp_118 = __stackBase__ + 16;
      var $iftmp_111 = __stackBase__ + 20;
      var $0 = __stackBase__ + 24;
      var $kwlist = __stackBase__ + 28;
      var $buffer = __stackBase__ + 52;
      var $raw = __stackBase__ + 56;
      var $encoding = __stackBase__ + 60;
      var $errors = __stackBase__ + 64;
      var $newline = __stackBase__ + 68;
      var $line_buffering = __stackBase__ + 72;
      var $res = __stackBase__ + 76;
      var $r = __stackBase__ + 80;
      var $_py_tmp = __stackBase__ + 84;
      var $_py_tmp17 = __stackBase__ + 88;
      var $_py_tmp21 = __stackBase__ + 92;
      var $_py_tmp25 = __stackBase__ + 96;
      var $_py_tmp29 = __stackBase__ + 100;
      var $_py_tmp33 = __stackBase__ + 104;
      var $_py_tmp37 = __stackBase__ + 108;
      var $_py_tmp41 = __stackBase__ + 112;
      var $_py_tmp45 = __stackBase__ + 116;
      var $_py_tmp49 = __stackBase__ + 120;
      var $_py_tmp59 = __stackBase__ + 124;
      var $incrementalDecoder = __stackBase__ + 128;
      var $_py_tmp95 = __stackBase__ + 132;
      var $ci = __stackBase__ + 136;
      var $e = __stackBase__ + 140;
      var $cookieObj = __stackBase__ + 144;
      var $cmp = __stackBase__ + 148;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$kwds_addr] = $kwds;
      
      var $2 = HEAP[_C_89_9102];
      HEAP[$kwlist] = $2;
      
      var $4 = HEAP[_C_89_9102 + 4];
      HEAP[$kwlist + 4] = $4;
      
      var $6 = HEAP[_C_89_9102 + 8];
      HEAP[$kwlist + 8] = $6;
      
      var $8 = HEAP[_C_89_9102 + 12];
      HEAP[$kwlist + 12] = $8;
      
      var $10 = HEAP[_C_89_9102 + 16];
      HEAP[$kwlist + 16] = $10;
      
      var $12 = HEAP[_C_89_9102 + 20];
      HEAP[$kwlist + 20] = $12;
      HEAP[$encoding] = 0;
      HEAP[$errors] = 0;
      HEAP[$newline] = 0;
      HEAP[$line_buffering] = 0;
      
      var $14 = HEAP[$self_addr] + 8;
      HEAP[$14] = 0;
      
      var $16 = HEAP[$self_addr] + 12;
      HEAP[$16] = 0;
      var $17 = HEAP[$args_addr];
      var $18 = HEAP[$kwds_addr];
      var $kwlist1 = $kwlist;
      var $19 = __PyArg_ParseTupleAndKeywords_SizeT($17, $18, __str45421, $kwlist1, allocate([ $buffer, 0, 0, 0, $encoding, 0, 0, 0, $errors, 0, 0, 0, $newline, 0, 0, 0, $line_buffering, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i8**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($19 == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 135;
      break;
     case 2:
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 3:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 4:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 10) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 8;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 7:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 13) {
        __label__ = 11;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      
      if (HEAP[HEAP[$newline] + 1] != 10) {
        __label__ = 11;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 10:
      
      
      
      
      if (HEAP[HEAP[$newline] + 2] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $55 = HEAP[$newline];
      var $56 = HEAP[_PyExc_ValueError];
      var $57 = _PyErr_Format($56, __str46422, allocate([ $55, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = -1;
      __label__ = 135;
      break;
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      var $64 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$_py_tmp] = $64;
      
      var $66 = HEAP[$self_addr] + 20;
      HEAP[$66] = 0;
      
      
      
      var $70 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $72 = HEAP[$_py_tmp];
      HEAP[$72] = $70;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $81 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $82 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$81]($82);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      var $89 = HEAP[HEAP[$self_addr] + 24];
      HEAP[$_py_tmp17] = $89;
      
      var $91 = HEAP[$self_addr] + 24;
      HEAP[$91] = 0;
      
      
      
      var $95 = HEAP[HEAP[$_py_tmp17]] - 1;
      
      var $97 = HEAP[$_py_tmp17];
      HEAP[$97] = $95;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp17]] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $106 = HEAP[HEAP[HEAP[$_py_tmp17] + 4] + 24];
      var $107 = HEAP[$_py_tmp17];
      FUNCTION_TABLE[$106]($107);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      var $114 = HEAP[HEAP[$self_addr] + 28];
      HEAP[$_py_tmp21] = $114;
      
      var $116 = HEAP[$self_addr] + 28;
      HEAP[$116] = 0;
      
      
      
      var $120 = HEAP[HEAP[$_py_tmp21]] - 1;
      
      var $122 = HEAP[$_py_tmp21];
      HEAP[$122] = $120;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp21]] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $131 = HEAP[HEAP[HEAP[$_py_tmp21] + 4] + 24];
      var $132 = HEAP[$_py_tmp21];
      FUNCTION_TABLE[$131]($132);
      __label__ = 21;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      var $139 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp25] = $139;
      
      var $141 = HEAP[$self_addr] + 32;
      HEAP[$141] = 0;
      
      
      
      var $145 = HEAP[HEAP[$_py_tmp25]] - 1;
      
      var $147 = HEAP[$_py_tmp25];
      HEAP[$147] = $145;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp25]] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $156 = HEAP[HEAP[HEAP[$_py_tmp25] + 4] + 24];
      var $157 = HEAP[$_py_tmp25];
      FUNCTION_TABLE[$156]($157);
      __label__ = 24;
      break;
     case 24:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      var $164 = HEAP[HEAP[$self_addr] + 36];
      HEAP[$_py_tmp29] = $164;
      
      var $166 = HEAP[$self_addr] + 36;
      HEAP[$166] = 0;
      
      
      
      var $170 = HEAP[HEAP[$_py_tmp29]] - 1;
      
      var $172 = HEAP[$_py_tmp29];
      HEAP[$172] = $170;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp29]] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $181 = HEAP[HEAP[HEAP[$_py_tmp29] + 4] + 24];
      var $182 = HEAP[$_py_tmp29];
      FUNCTION_TABLE[$181]($182);
      __label__ = 27;
      break;
     case 27:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      var $189 = HEAP[HEAP[$self_addr] + 64];
      HEAP[$_py_tmp33] = $189;
      
      var $191 = HEAP[$self_addr] + 64;
      HEAP[$191] = 0;
      
      
      
      var $195 = HEAP[HEAP[$_py_tmp33]] - 1;
      
      var $197 = HEAP[$_py_tmp33];
      HEAP[$197] = $195;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp33]] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $206 = HEAP[HEAP[HEAP[$_py_tmp33] + 4] + 24];
      var $207 = HEAP[$_py_tmp33];
      FUNCTION_TABLE[$206]($207);
      __label__ = 30;
      break;
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $214 = HEAP[HEAP[$self_addr] + 72];
      HEAP[$_py_tmp37] = $214;
      
      var $216 = HEAP[$self_addr] + 72;
      HEAP[$216] = 0;
      
      
      
      var $220 = HEAP[HEAP[$_py_tmp37]] - 1;
      
      var $222 = HEAP[$_py_tmp37];
      HEAP[$222] = $220;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp37]] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $231 = HEAP[HEAP[HEAP[$_py_tmp37] + 4] + 24];
      var $232 = HEAP[$_py_tmp37];
      FUNCTION_TABLE[$231]($232);
      __label__ = 33;
      break;
     case 33:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 34:
      
      
      var $239 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp41] = $239;
      
      var $241 = HEAP[$self_addr] + 80;
      HEAP[$241] = 0;
      
      
      
      var $245 = HEAP[HEAP[$_py_tmp41]] - 1;
      
      var $247 = HEAP[$_py_tmp41];
      HEAP[$247] = $245;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp41]] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      var $256 = HEAP[HEAP[HEAP[$_py_tmp41] + 4] + 24];
      var $257 = HEAP[$_py_tmp41];
      FUNCTION_TABLE[$256]($257);
      __label__ = 36;
      break;
     case 36:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 37:
      
      
      var $264 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$_py_tmp45] = $264;
      
      var $266 = HEAP[$self_addr] + 40;
      HEAP[$266] = 0;
      
      
      
      var $270 = HEAP[HEAP[$_py_tmp45]] - 1;
      
      var $272 = HEAP[$_py_tmp45];
      HEAP[$272] = $270;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp45]] == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $281 = HEAP[HEAP[HEAP[$_py_tmp45] + 4] + 24];
      var $282 = HEAP[$_py_tmp45];
      FUNCTION_TABLE[$281]($282);
      __label__ = 39;
      break;
     case 39:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      
      var $289 = HEAP[HEAP[$self_addr] + 84];
      HEAP[$_py_tmp49] = $289;
      
      var $291 = HEAP[$self_addr] + 84;
      HEAP[$291] = 0;
      
      
      
      var $295 = HEAP[HEAP[$_py_tmp49]] - 1;
      
      var $297 = HEAP[$_py_tmp49];
      HEAP[$297] = $295;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp49]] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $306 = HEAP[HEAP[HEAP[$_py_tmp49] + 4] + 24];
      var $307 = HEAP[$_py_tmp49];
      FUNCTION_TABLE[$306]($307);
      __label__ = 42;
      break;
     case 42:
      
      var $309 = HEAP[$self_addr] + 68;
      HEAP[$309] = 0;
      
      var $311 = HEAP[$self_addr] + 76;
      HEAP[$311] = 0;
      
      var $313 = HEAP[$self_addr] + 56;
      HEAP[$313] = 0;
      
      var $315 = HEAP[$self_addr] + 44;
      HEAP[$315] = 0;
      
      
      if (HEAP[$encoding] == 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 43:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 44:
      
      
      if (HEAP[__PyIO_locale_module] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      var $324 = _PyImport_ImportModule(__str47423);
      HEAP[__PyIO_locale_module] = $324;
      
      
      if (HEAP[__PyIO_locale_module] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      var $327 = HEAP[__PyIO_locale_module];
      var $328 = __PyObject_CallMethod_SizeT($327, __str48424, 0, allocate(1, "i32", ALLOC_STACK));
      
      var $330 = HEAP[$self_addr] + 24;
      HEAP[$330] = $328;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 47:
      var $335 = HEAP[_PyExc_ImportError];
      var $336 = _PyErr_ExceptionMatches($335);
      
      if ($336 != 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 134;
        break;
      }
     case 48:
      _PyErr_Clear();
      var $338 = _PyString_FromString(__str33409);
      
      var $340 = HEAP[$self_addr] + 24;
      HEAP[$340] = $338;
      __label__ = 53;
      break;
     case 49:
      
      
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[HEAP[$self_addr] + 24] + 4] + 84] & 134217728) == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 50:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 51:
      
      
      var $356 = HEAP[HEAP[$self_addr] + 24];
      HEAP[$_py_tmp59] = $356;
      
      var $358 = HEAP[$self_addr] + 24;
      HEAP[$358] = 0;
      
      
      
      var $362 = HEAP[HEAP[$_py_tmp59]] - 1;
      
      var $364 = HEAP[$_py_tmp59];
      HEAP[$364] = $362;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp59]] == 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 52:
      
      
      
      
      var $373 = HEAP[HEAP[HEAP[$_py_tmp59] + 4] + 24];
      var $374 = HEAP[$_py_tmp59];
      FUNCTION_TABLE[$373]($374);
      __label__ = 53;
      break;
     case 53:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      var $381 = HEAP[HEAP[$self_addr] + 24];
      var $382 = _PyString_AsString($381);
      HEAP[$encoding] = $382;
      __label__ = 59;
      break;
     case 55:
      
      
      if (HEAP[$encoding] != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 56:
      var $385 = HEAP[$encoding];
      var $386 = _PyString_FromString($385);
      
      var $388 = HEAP[$self_addr] + 24;
      HEAP[$388] = $386;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 57:
      __label__ = 59;
      break;
     case 58:
      var $393 = HEAP[_PyExc_IOError];
      _PyErr_SetString($393, __str49425);
      __label__ = 59;
      break;
     case 59:
      
      
      if (HEAP[$errors] == 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      HEAP[$errors] = __str11386;
      __label__ = 61;
      break;
     case 61:
      var $396 = HEAP[$errors];
      var $397 = _PyString_FromString($396);
      
      var $399 = HEAP[$self_addr] + 40;
      HEAP[$399] = $397;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      var $405 = HEAP[$self_addr] + 16;
      HEAP[$405] = 8192;
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      
      
      
      
      if (HEAP[HEAP[$newline]] == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      HEAP[$iftmp_111] = 1;
      __label__ = 66;
      break;
     case 65:
      HEAP[$iftmp_111] = 0;
      __label__ = 66;
      break;
     case 66:
      
      var $413 = HEAP[$iftmp_111] & 255;
      
      var $415 = HEAP[$self_addr] + 49;
      HEAP[$415] = $413;
      
      var $417 = HEAP[$line_buffering] & 255;
      
      var $419 = HEAP[$self_addr] + 48;
      HEAP[$419] = $417;
      
      
      var $422 = HEAP[$newline] == 0;
      
      var $424 = HEAP[$self_addr] + 50;
      HEAP[$424] = $422;
      
      
      if (HEAP[$newline] != 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 67:
      var $427 = HEAP[$newline];
      var $428 = _PyString_FromString($427);
      
      var $430 = HEAP[$self_addr] + 36;
      HEAP[$430] = $428;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      HEAP[$0] = -1;
      __label__ = 135;
      break;
     case 69:
      
      
      if (HEAP[$newline] == 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 70:
      
      
      
      
      if (HEAP[HEAP[$newline]] != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      HEAP[$iftmp_118] = 1;
      __label__ = 73;
      break;
     case 72:
      HEAP[$iftmp_118] = 0;
      __label__ = 73;
      break;
     case 73:
      
      var $442 = HEAP[$iftmp_118] & 255;
      
      var $444 = HEAP[$self_addr] + 51;
      HEAP[$444] = $442;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 49] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 74:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 51] != 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 75:
      
      
      var $455 = HEAP[HEAP[$self_addr] + 36];
      var $456 = _PyString_AsString($455);
      
      var $458 = HEAP[$self_addr] + 44;
      HEAP[$458] = $456;
      
      
      var $461 = HEAP[HEAP[$self_addr] + 44];
      var $462 = _strcmp($461, __str25400);
      
      if ($462 == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      
      var $465 = HEAP[$self_addr] + 44;
      HEAP[$465] = 0;
      __label__ = 77;
      break;
     case 77:
      var $466 = HEAP[$buffer];
      var $467 = __PyObject_CallMethod_SizeT($466, __str50426, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $467;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 78:
      var $470 = HEAP[$res];
      var $471 = _PyObject_IsTrue($470);
      HEAP[$r] = $471;
      
      
      
      var $475 = HEAP[HEAP[$res]] - 1;
      
      var $477 = HEAP[$res];
      HEAP[$477] = $475;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 79;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 79:
      
      
      
      
      var $486 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $487 = HEAP[$res];
      FUNCTION_TABLE[$486]($487);
      __label__ = 80;
      break;
     case 80:
      
      var $489 = HEAP[$r] == -1;
      if ($489) {
        __label__ = 134;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      
      
      if (HEAP[$r] == 1) {
        __label__ = 82;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 82:
      var $492 = HEAP[$errors];
      var $493 = HEAP[$encoding];
      var $494 = _PyCodec_IncrementalDecoder($493, $492);
      
      var $496 = HEAP[$self_addr] + 32;
      HEAP[$496] = $494;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 83:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 49] != 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 84:
      
      
      
      var $508 = HEAP[HEAP[$self_addr] + 50];
      
      
      var $511 = HEAP[HEAP[$self_addr] + 32];
      var $512 = __PyObject_CallFunction_SizeT(_PyIncrementalNewlineDecoder_Type, __str51427, allocate([ $511, 0, 0, 0, $508, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$incrementalDecoder] = $512;
      
      
      if (HEAP[$incrementalDecoder] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 85:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 86:
      
      
      var $521 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp95] = $521;
      
      var $523 = HEAP[$self_addr] + 32;
      HEAP[$523] = 0;
      
      
      
      var $527 = HEAP[HEAP[$_py_tmp95]] - 1;
      
      var $529 = HEAP[$_py_tmp95];
      HEAP[$529] = $527;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp95]] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 87:
      
      
      
      
      var $538 = HEAP[HEAP[HEAP[$_py_tmp95] + 4] + 24];
      var $539 = HEAP[$_py_tmp95];
      FUNCTION_TABLE[$538]($539);
      __label__ = 88;
      break;
     case 88:
      
      var $541 = HEAP[$self_addr] + 32;
      var $542 = HEAP[$incrementalDecoder];
      HEAP[$541] = $542;
      __label__ = 89;
      break;
     case 89:
      var $543 = HEAP[$buffer];
      var $544 = __PyObject_CallMethod_SizeT($543, __str52428, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $544;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 90:
      var $547 = HEAP[$res];
      var $548 = _PyObject_IsTrue($547);
      HEAP[$r] = $548;
      
      
      
      var $552 = HEAP[HEAP[$res]] - 1;
      
      var $554 = HEAP[$res];
      HEAP[$554] = $552;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 91:
      
      
      
      
      var $563 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $564 = HEAP[$res];
      FUNCTION_TABLE[$563]($564);
      __label__ = 92;
      break;
     case 92:
      
      var $566 = HEAP[$r] == -1;
      if ($566) {
        __label__ = 134;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 93:
      
      
      if (HEAP[$r] == 1) {
        __label__ = 94;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 94:
      var $569 = HEAP[$errors];
      var $570 = HEAP[$encoding];
      var $571 = _PyCodec_IncrementalEncoder($570, $569);
      
      var $573 = HEAP[$self_addr] + 28;
      HEAP[$573] = $571;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 95;
        break;
      }
     case 95:
      var $578 = HEAP[$encoding];
      var $579 = __PyCodec_Lookup($578);
      HEAP[$ci] = $579;
      
      
      if (HEAP[$ci] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 96:
      var $582 = HEAP[$ci];
      var $583 = _PyObject_GetAttrString($582, __str53429);
      HEAP[$res] = $583;
      
      
      
      var $587 = HEAP[HEAP[$ci]] - 1;
      
      var $589 = HEAP[$ci];
      HEAP[$589] = $587;
      
      
      
      
      if (HEAP[HEAP[$ci]] == 0) {
        __label__ = 97;
        break;
      } else {
        __label__ = 98;
        break;
      }
     case 97:
      
      
      
      
      var $598 = HEAP[HEAP[HEAP[$ci] + 4] + 24];
      var $599 = HEAP[$ci];
      FUNCTION_TABLE[$598]($599);
      __label__ = 98;
      break;
     case 98:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 99;
        break;
      } else {
        __label__ = 101;
        break;
      }
     case 99:
      var $602 = HEAP[_PyExc_AttributeError];
      var $603 = _PyErr_ExceptionMatches($602);
      
      if ($603 != 0) {
        __label__ = 100;
        break;
      } else {
        __label__ = 134;
        break;
      }
     case 100:
      _PyErr_Clear();
      __label__ = 107;
      break;
     case 101:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$res] + 4] + 84] & 134217728) != 0) {
        __label__ = 102;
        break;
      } else {
        __label__ = 107;
        break;
      }
     case 102:
      HEAP[$e] = _encodefuncs;
      __label__ = 106;
      break;
     case 103:
      
      
      var $614 = HEAP[HEAP[$e]];
      
      
      
      var $618 = HEAP[$res] + 20;
      var $619 = _strcmp($618, $614);
      
      if ($619 == 0) {
        __label__ = 104;
        break;
      } else {
        __label__ = 105;
        break;
      }
     case 104:
      
      
      var $623 = HEAP[HEAP[$e] + 4];
      
      var $625 = HEAP[$self_addr] + 56;
      HEAP[$625] = $623;
      __label__ = 107;
      break;
     case 105:
      
      var $627 = HEAP[$e] + 8;
      HEAP[$e] = $627;
      __label__ = 106;
      break;
     case 106:
      
      
      
      
      if (HEAP[HEAP[$e]] != 0) {
        __label__ = 103;
        break;
      } else {
        __label__ = 107;
        break;
      }
     case 107:
      
      
      if (HEAP[$res] != 0) {
        __label__ = 108;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 108:
      
      
      
      var $637 = HEAP[HEAP[$res]] - 1;
      
      var $639 = HEAP[$res];
      HEAP[$639] = $637;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 109;
        break;
      } else {
        __label__ = 110;
        break;
      }
     case 109:
      
      
      
      
      var $648 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $649 = HEAP[$res];
      FUNCTION_TABLE[$648]($649);
      __label__ = 110;
      break;
     case 110:
      var $650 = HEAP[$buffer];
      
      var $652 = HEAP[$self_addr] + 20;
      HEAP[$652] = $650;
      
      
      
      var $656 = HEAP[HEAP[$buffer]] + 1;
      var $657 = HEAP[$buffer];
      HEAP[$657] = $656;
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedReader_Type) {
        __label__ = 113;
        break;
      } else {
        __label__ = 111;
        break;
      }
     case 111:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedWriter_Type) {
        __label__ = 113;
        break;
      } else {
        __label__ = 112;
        break;
      }
     case 112:
      
      
      
      
      if (HEAP[HEAP[$buffer] + 4] == _PyBufferedRandom_Type) {
        __label__ = 113;
        break;
      } else {
        __label__ = 120;
        break;
      }
     case 113:
      var $670 = HEAP[$buffer];
      var $671 = _PyObject_GetAttrString($670, __str54430);
      HEAP[$raw] = $671;
      
      
      if (HEAP[$raw] == 0) {
        __label__ = 114;
        break;
      } else {
        __label__ = 116;
        break;
      }
     case 114:
      var $674 = HEAP[_PyExc_AttributeError];
      var $675 = _PyErr_ExceptionMatches($674);
      
      if ($675 != 0) {
        __label__ = 115;
        break;
      } else {
        __label__ = 134;
        break;
      }
     case 115:
      _PyErr_Clear();
      __label__ = 120;
      break;
     case 116:
      
      
      
      
      if (HEAP[HEAP[$raw] + 4] == _PyFileIO_Type) {
        __label__ = 117;
        break;
      } else {
        __label__ = 118;
        break;
      }
     case 117:
      
      var $682 = HEAP[$self_addr] + 84;
      var $683 = HEAP[$raw];
      HEAP[$682] = $683;
      __label__ = 120;
      break;
     case 118:
      
      
      
      var $687 = HEAP[HEAP[$raw]] - 1;
      
      var $689 = HEAP[$raw];
      HEAP[$689] = $687;
      
      
      
      
      if (HEAP[HEAP[$raw]] == 0) {
        __label__ = 119;
        break;
      } else {
        __label__ = 120;
        break;
      }
     case 119:
      
      
      
      
      var $698 = HEAP[HEAP[HEAP[$raw] + 4] + 24];
      var $699 = HEAP[$raw];
      FUNCTION_TABLE[$698]($699);
      __label__ = 120;
      break;
     case 120:
      var $700 = HEAP[$buffer];
      var $701 = __PyObject_CallMethod_SizeT($700, __str55431, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $701;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 121;
        break;
      }
     case 121:
      var $704 = HEAP[$res];
      var $705 = _PyObject_IsTrue($704);
      var $706 = $705 & 255;
      
      var $708 = HEAP[$self_addr] + 53;
      HEAP[$708] = $706;
      
      
      var $711 = HEAP[HEAP[$self_addr] + 53];
      
      var $713 = HEAP[$self_addr] + 52;
      HEAP[$713] = $711;
      
      
      
      var $717 = HEAP[HEAP[$res]] - 1;
      
      var $719 = HEAP[$res];
      HEAP[$719] = $717;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 122;
        break;
      } else {
        __label__ = 123;
        break;
      }
     case 122:
      
      
      
      
      var $728 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $729 = HEAP[$res];
      FUNCTION_TABLE[$728]($729);
      __label__ = 123;
      break;
     case 123:
      
      var $731 = HEAP[$self_addr] + 60;
      HEAP[$731] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] != 0) {
        __label__ = 124;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 124:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 125;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 125:
      
      var $741 = HEAP[$self_addr] + 60;
      HEAP[$741] = 1;
      var $742 = HEAP[__PyIO_str_tell];
      var $743 = HEAP[$buffer];
      var $744 = _PyObject_CallMethodObjArgs($743, $742, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$cookieObj] = $744;
      
      
      if (HEAP[$cookieObj] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 126;
        break;
      }
     case 126:
      var $747 = HEAP[__PyIO_zero];
      var $748 = HEAP[$cookieObj];
      var $749 = _PyObject_RichCompareBool($748, $747, 2);
      HEAP[$cmp] = $749;
      
      
      
      var $753 = HEAP[HEAP[$cookieObj]] - 1;
      
      var $755 = HEAP[$cookieObj];
      HEAP[$755] = $753;
      
      
      
      
      if (HEAP[HEAP[$cookieObj]] == 0) {
        __label__ = 127;
        break;
      } else {
        __label__ = 128;
        break;
      }
     case 127:
      
      
      
      
      var $764 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $765 = HEAP[$cookieObj];
      FUNCTION_TABLE[$764]($765);
      __label__ = 128;
      break;
     case 128:
      
      
      if (HEAP[$cmp] < 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 129;
        break;
      }
     case 129:
      
      
      if (HEAP[$cmp] == 0) {
        __label__ = 130;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 130:
      
      var $771 = HEAP[$self_addr] + 60;
      HEAP[$771] = 0;
      var $772 = HEAP[__PyIO_zero];
      var $773 = HEAP[__PyIO_str_setstate];
      
      
      var $776 = HEAP[HEAP[$self_addr] + 28];
      var $777 = _PyObject_CallMethodObjArgs($776, $773, allocate([ $772, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $777;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 134;
        break;
      } else {
        __label__ = 131;
        break;
      }
     case 131:
      
      
      
      var $783 = HEAP[HEAP[$res]] - 1;
      
      var $785 = HEAP[$res];
      HEAP[$785] = $783;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 132;
        break;
      } else {
        __label__ = 133;
        break;
      }
     case 132:
      
      
      
      
      var $794 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $795 = HEAP[$res];
      FUNCTION_TABLE[$794]($795);
      __label__ = 133;
      break;
     case 133:
      
      var $797 = HEAP[$self_addr] + 8;
      HEAP[$797] = 1;
      HEAP[$0] = 0;
      __label__ = 135;
      break;
     case 134:
      HEAP[$0] = -1;
      __label__ = 135;
      break;
     case 135:
      var $798 = HEAP[$0];
      HEAP[$retval] = $798;
      __label__ = 136;
      break;
     case 136:
      var $retval144 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval144;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      var $_py_tmp7 = __stackBase__ + 16;
      var $_py_tmp11 = __stackBase__ + 20;
      var $_py_tmp15 = __stackBase__ + 24;
      var $_py_tmp19 = __stackBase__ + 28;
      var $_py_tmp23 = __stackBase__ + 32;
      var $_py_tmp27 = __stackBase__ + 36;
      var $_py_tmp31 = __stackBase__ + 40;
      var $_py_tmp35 = __stackBase__ + 44;
      var $_py_tmp39 = __stackBase__ + 48;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      var $6 = HEAP[$self_addr];
      var $7 = __PyIOBase_finalize($6);
      
      if ($7 < 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      HEAP[$0] = -1;
      __label__ = 34;
      break;
     case 3:
      
      var $10 = HEAP[$self_addr] + 8;
      HEAP[$10] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $17 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$_py_tmp] = $17;
      
      var $19 = HEAP[$self_addr] + 20;
      HEAP[$19] = 0;
      
      
      
      var $23 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $25 = HEAP[$_py_tmp];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $35 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$34]($35);
      __label__ = 6;
      break;
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $42 = HEAP[HEAP[$self_addr] + 24];
      HEAP[$_py_tmp7] = $42;
      
      var $44 = HEAP[$self_addr] + 24;
      HEAP[$44] = 0;
      
      
      
      var $48 = HEAP[HEAP[$_py_tmp7]] - 1;
      
      var $50 = HEAP[$_py_tmp7];
      HEAP[$50] = $48;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp7]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $59 = HEAP[HEAP[HEAP[$_py_tmp7] + 4] + 24];
      var $60 = HEAP[$_py_tmp7];
      FUNCTION_TABLE[$59]($60);
      __label__ = 9;
      break;
     case 9:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      var $67 = HEAP[HEAP[$self_addr] + 28];
      HEAP[$_py_tmp11] = $67;
      
      var $69 = HEAP[$self_addr] + 28;
      HEAP[$69] = 0;
      
      
      
      var $73 = HEAP[HEAP[$_py_tmp11]] - 1;
      
      var $75 = HEAP[$_py_tmp11];
      HEAP[$75] = $73;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp11]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $84 = HEAP[HEAP[HEAP[$_py_tmp11] + 4] + 24];
      var $85 = HEAP[$_py_tmp11];
      FUNCTION_TABLE[$84]($85);
      __label__ = 12;
      break;
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      var $92 = HEAP[HEAP[$self_addr] + 32];
      HEAP[$_py_tmp15] = $92;
      
      var $94 = HEAP[$self_addr] + 32;
      HEAP[$94] = 0;
      
      
      
      var $98 = HEAP[HEAP[$_py_tmp15]] - 1;
      
      var $100 = HEAP[$_py_tmp15];
      HEAP[$100] = $98;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp15]] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $109 = HEAP[HEAP[HEAP[$_py_tmp15] + 4] + 24];
      var $110 = HEAP[$_py_tmp15];
      FUNCTION_TABLE[$109]($110);
      __label__ = 15;
      break;
     case 15:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      var $117 = HEAP[HEAP[$self_addr] + 36];
      HEAP[$_py_tmp19] = $117;
      
      var $119 = HEAP[$self_addr] + 36;
      HEAP[$119] = 0;
      
      
      
      var $123 = HEAP[HEAP[$_py_tmp19]] - 1;
      
      var $125 = HEAP[$_py_tmp19];
      HEAP[$125] = $123;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp19]] == 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      
      
      
      
      var $134 = HEAP[HEAP[HEAP[$_py_tmp19] + 4] + 24];
      var $135 = HEAP[$_py_tmp19];
      FUNCTION_TABLE[$134]($135);
      __label__ = 18;
      break;
     case 18:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      var $142 = HEAP[HEAP[$self_addr] + 64];
      HEAP[$_py_tmp23] = $142;
      
      var $144 = HEAP[$self_addr] + 64;
      HEAP[$144] = 0;
      
      
      
      var $148 = HEAP[HEAP[$_py_tmp23]] - 1;
      
      var $150 = HEAP[$_py_tmp23];
      HEAP[$150] = $148;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp23]] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      var $159 = HEAP[HEAP[HEAP[$_py_tmp23] + 4] + 24];
      var $160 = HEAP[$_py_tmp23];
      FUNCTION_TABLE[$159]($160);
      __label__ = 21;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      var $167 = HEAP[HEAP[$self_addr] + 72];
      HEAP[$_py_tmp27] = $167;
      
      var $169 = HEAP[$self_addr] + 72;
      HEAP[$169] = 0;
      
      
      
      var $173 = HEAP[HEAP[$_py_tmp27]] - 1;
      
      var $175 = HEAP[$_py_tmp27];
      HEAP[$175] = $173;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp27]] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      
      
      
      
      var $184 = HEAP[HEAP[HEAP[$_py_tmp27] + 4] + 24];
      var $185 = HEAP[$_py_tmp27];
      FUNCTION_TABLE[$184]($185);
      __label__ = 24;
      break;
     case 24:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      var $192 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp31] = $192;
      
      var $194 = HEAP[$self_addr] + 80;
      HEAP[$194] = 0;
      
      
      
      var $198 = HEAP[HEAP[$_py_tmp31]] - 1;
      
      var $200 = HEAP[$_py_tmp31];
      HEAP[$200] = $198;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp31]] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      
      
      
      
      var $209 = HEAP[HEAP[HEAP[$_py_tmp31] + 4] + 24];
      var $210 = HEAP[$_py_tmp31];
      FUNCTION_TABLE[$209]($210);
      __label__ = 27;
      break;
     case 27:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      var $217 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$_py_tmp35] = $217;
      
      var $219 = HEAP[$self_addr] + 40;
      HEAP[$219] = 0;
      
      
      
      var $223 = HEAP[HEAP[$_py_tmp35]] - 1;
      
      var $225 = HEAP[$_py_tmp35];
      HEAP[$225] = $223;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp35]] == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      
      
      
      
      var $234 = HEAP[HEAP[HEAP[$_py_tmp35] + 4] + 24];
      var $235 = HEAP[$_py_tmp35];
      FUNCTION_TABLE[$234]($235);
      __label__ = 30;
      break;
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $242 = HEAP[HEAP[$self_addr] + 84];
      HEAP[$_py_tmp39] = $242;
      
      var $244 = HEAP[$self_addr] + 84;
      HEAP[$244] = 0;
      
      
      
      var $248 = HEAP[HEAP[$_py_tmp39]] - 1;
      
      var $250 = HEAP[$_py_tmp39];
      HEAP[$250] = $248;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp39]] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $259 = HEAP[HEAP[HEAP[$_py_tmp39] + 4] + 24];
      var $260 = HEAP[$_py_tmp39];
      FUNCTION_TABLE[$259]($260);
      __label__ = 33;
      break;
     case 33:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 34:
      var $261 = HEAP[$0];
      HEAP[$retval] = $261;
      __label__ = 35;
      break;
     case 35:
      var $retval43 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval43;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_dealloc($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $g = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      var $0 = HEAP[$self_addr];
      var $1 = __textiowrapper_clear($0);
      
      if ($1 < 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      var $5 = HEAP[$self_addr] + -12;
      HEAP[$g] = $5;
      
      
      
      
      var $10 = HEAP[HEAP[$g] + 8] == -2;
      if ($10) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      ___assert_fail(__str56432, __str15390, 1070, ___PRETTY_FUNCTION___9643);
      throw "Reached an unreachable!";
     case 3:
      
      
      var $13 = HEAP[$g] + 8;
      HEAP[$13] = -2;
      
      
      
      
      
      
      
      var $21 = HEAP[HEAP[$g]];
      
      var $23 = HEAP[HEAP[$g] + 4];
      HEAP[$23] = $21;
      
      
      
      
      
      
      
      var $31 = HEAP[HEAP[$g] + 4];
      
      var $33 = HEAP[HEAP[$g]] + 4;
      HEAP[$33] = $31;
      
      
      var $36 = HEAP[$g];
      HEAP[$36] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 88] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      var $42 = HEAP[$self_addr];
      _PyObject_ClearWeakRefs($42);
      __label__ = 5;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      
      
      var $49 = HEAP[HEAP[$self_addr] + 92];
      HEAP[$_py_tmp] = $49;
      
      var $51 = HEAP[$self_addr] + 92;
      HEAP[$51] = 0;
      
      
      
      var $55 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $57 = HEAP[$_py_tmp];
      HEAP[$57] = $55;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $66 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $67 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$66]($67);
      __label__ = 8;
      break;
     case 8:
      
      
      
      
      
      var $73 = HEAP[HEAP[HEAP[$self_addr] + 4] + 160];
      
      var $75 = HEAP[$self_addr];
      FUNCTION_TABLE[$73]($75);
      __label__ = 9;
      break;
     case 9:
      __label__ = 10;
      break;
     case 10:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_traverse($self, $visit, $arg) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 64;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 64);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $visit_addr = __stackBase__ + 4;
      var $arg_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $vret = __stackBase__ + 20;
      var $vret4 = __stackBase__ + 24;
      var $vret8 = __stackBase__ + 28;
      var $vret12 = __stackBase__ + 32;
      var $vret16 = __stackBase__ + 36;
      var $vret20 = __stackBase__ + 40;
      var $vret24 = __stackBase__ + 44;
      var $vret28 = __stackBase__ + 48;
      var $vret32 = __stackBase__ + 52;
      var $vret36 = __stackBase__ + 56;
      var $vret40 = __stackBase__ + 60;
      
      HEAP[$self_addr] = $self;
      HEAP[$visit_addr] = $visit;
      HEAP[$arg_addr] = $arg;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 20] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 20];
      var $8 = HEAP[$visit_addr];
      var $9 = HEAP[$arg_addr];
      var $10 = FUNCTION_TABLE[$8]($7, $9);
      HEAP[$vret] = $10;
      
      
      if (HEAP[$vret] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $13 = HEAP[$vret];
      HEAP[$0] = $13;
      __label__ = 34;
      break;
     case 3:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 24] != 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 4:
      
      
      var $20 = HEAP[HEAP[$self_addr] + 24];
      var $21 = HEAP[$visit_addr];
      var $22 = HEAP[$arg_addr];
      var $23 = FUNCTION_TABLE[$21]($20, $22);
      HEAP[$vret4] = $23;
      
      
      if (HEAP[$vret4] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $26 = HEAP[$vret4];
      HEAP[$0] = $26;
      __label__ = 34;
      break;
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 7:
      
      
      var $33 = HEAP[HEAP[$self_addr] + 28];
      var $34 = HEAP[$visit_addr];
      var $35 = HEAP[$arg_addr];
      var $36 = FUNCTION_TABLE[$34]($33, $35);
      HEAP[$vret8] = $36;
      
      
      if (HEAP[$vret8] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      var $39 = HEAP[$vret8];
      HEAP[$0] = $39;
      __label__ = 34;
      break;
     case 9:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 10:
      
      
      var $46 = HEAP[HEAP[$self_addr] + 32];
      var $47 = HEAP[$visit_addr];
      var $48 = HEAP[$arg_addr];
      var $49 = FUNCTION_TABLE[$47]($46, $48);
      HEAP[$vret12] = $49;
      
      
      if (HEAP[$vret12] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      var $52 = HEAP[$vret12];
      HEAP[$0] = $52;
      __label__ = 34;
      break;
     case 12:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 36] != 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 13:
      
      
      var $59 = HEAP[HEAP[$self_addr] + 36];
      var $60 = HEAP[$visit_addr];
      var $61 = HEAP[$arg_addr];
      var $62 = FUNCTION_TABLE[$60]($59, $61);
      HEAP[$vret16] = $62;
      
      
      if (HEAP[$vret16] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      var $65 = HEAP[$vret16];
      HEAP[$0] = $65;
      __label__ = 34;
      break;
     case 15:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] != 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 16:
      
      
      var $72 = HEAP[HEAP[$self_addr] + 64];
      var $73 = HEAP[$visit_addr];
      var $74 = HEAP[$arg_addr];
      var $75 = FUNCTION_TABLE[$73]($72, $74);
      HEAP[$vret20] = $75;
      
      
      if (HEAP[$vret20] != 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $78 = HEAP[$vret20];
      HEAP[$0] = $78;
      __label__ = 34;
      break;
     case 18:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] != 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 19:
      
      
      var $85 = HEAP[HEAP[$self_addr] + 72];
      var $86 = HEAP[$visit_addr];
      var $87 = HEAP[$arg_addr];
      var $88 = FUNCTION_TABLE[$86]($85, $87);
      HEAP[$vret24] = $88;
      
      
      if (HEAP[$vret24] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      var $91 = HEAP[$vret24];
      HEAP[$0] = $91;
      __label__ = 34;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 22:
      
      
      var $98 = HEAP[HEAP[$self_addr] + 80];
      var $99 = HEAP[$visit_addr];
      var $100 = HEAP[$arg_addr];
      var $101 = FUNCTION_TABLE[$99]($98, $100);
      HEAP[$vret28] = $101;
      
      
      if (HEAP[$vret28] != 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      var $104 = HEAP[$vret28];
      HEAP[$0] = $104;
      __label__ = 34;
      break;
     case 24:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 40] != 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 25:
      
      
      var $111 = HEAP[HEAP[$self_addr] + 40];
      var $112 = HEAP[$visit_addr];
      var $113 = HEAP[$arg_addr];
      var $114 = FUNCTION_TABLE[$112]($111, $113);
      HEAP[$vret32] = $114;
      
      
      if (HEAP[$vret32] != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      var $117 = HEAP[$vret32];
      HEAP[$0] = $117;
      __label__ = 34;
      break;
     case 27:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 28:
      
      
      var $124 = HEAP[HEAP[$self_addr] + 84];
      var $125 = HEAP[$visit_addr];
      var $126 = HEAP[$arg_addr];
      var $127 = FUNCTION_TABLE[$125]($124, $126);
      HEAP[$vret36] = $127;
      
      
      if (HEAP[$vret36] != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      var $130 = HEAP[$vret36];
      HEAP[$0] = $130;
      __label__ = 34;
      break;
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 31:
      
      
      var $137 = HEAP[HEAP[$self_addr] + 92];
      var $138 = HEAP[$visit_addr];
      var $139 = HEAP[$arg_addr];
      var $140 = FUNCTION_TABLE[$138]($137, $139);
      HEAP[$vret40] = $140;
      
      
      if (HEAP[$vret40] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      var $143 = HEAP[$vret40];
      HEAP[$0] = $143;
      __label__ = 34;
      break;
     case 33:
      HEAP[$0] = 0;
      __label__ = 34;
      break;
     case 34:
      var $144 = HEAP[$0];
      HEAP[$retval] = $144;
      __label__ = 35;
      break;
     case 35:
      var $retval44 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval44;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_clear($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $_py_tmp = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      var $1 = HEAP[$self_addr];
      var $2 = __textiowrapper_clear($1);
      
      if ($2 < 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 6;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 92] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      var $10 = HEAP[HEAP[$self_addr] + 92];
      HEAP[$_py_tmp] = $10;
      
      var $12 = HEAP[$self_addr] + 92;
      HEAP[$12] = 0;
      
      
      
      var $16 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $18 = HEAP[$_py_tmp];
      HEAP[$18] = $16;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $27 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $28 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$27]($28);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 6:
      var $29 = HEAP[$0];
      HEAP[$retval] = $29;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_detach($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $buffer = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_flush];
      
      var $13 = HEAP[$self_addr];
      var $14 = _PyObject_CallMethodObjArgs($13, $11, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $14;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 10;
      break;
     case 7:
      
      
      
      var $20 = HEAP[HEAP[$res]] - 1;
      
      var $22 = HEAP[$res];
      HEAP[$22] = $20;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $31 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $32 = HEAP[$res];
      FUNCTION_TABLE[$31]($32);
      __label__ = 9;
      break;
     case 9:
      
      
      var $35 = HEAP[HEAP[$self_addr] + 20];
      HEAP[$buffer] = $35;
      
      var $37 = HEAP[$self_addr] + 20;
      HEAP[$37] = 0;
      
      var $39 = HEAP[$self_addr] + 12;
      HEAP[$39] = 1;
      
      var $41 = HEAP[$self_addr] + 8;
      HEAP[$41] = 0;
      var $42 = HEAP[$buffer];
      HEAP[$0] = $42;
      __label__ = 10;
      break;
     case 10:
      var $43 = HEAP[$0];
      HEAP[$retval] = $43;
      __label__ = 11;
      break;
     case 11:
      var $retval10 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval10;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _findchar($s, $size, $ch) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 18;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 18);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $s_addr = __stackBase__;
      var $size_addr = __stackBase__ + 4;
      var $ch_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 10;
      var $0 = __stackBase__ + 14;
      
      HEAP[$s_addr] = $s;
      HEAP[$size_addr] = $size;
      HEAP[$ch_addr] = $ch;
      __label__ = 4;
      break;
     case 1:
      
      
      
      
      if (HEAP[HEAP[$s_addr]] == HEAP[$ch_addr]) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $5 = HEAP[$s_addr];
      HEAP[$0] = $5;
      __label__ = 6;
      break;
     case 3:
      
      var $7 = HEAP[$s_addr] + 2;
      HEAP[$s_addr] = $7;
      __label__ = 4;
      break;
     case 4:
      
      
      var $10 = HEAP[$size_addr] > 0;
      
      var $12 = HEAP[$size_addr] - 1;
      HEAP[$size_addr] = $12;
      
      if ($10 != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 6:
      var $13 = HEAP[$0];
      HEAP[$retval] = $13;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_writeflush($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $pending = __stackBase__ + 12;
      var $b = __stackBase__ + 16;
      var $ret = __stackBase__ + 20;
      var $_py_tmp = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 2:
      
      
      var $7 = HEAP[HEAP[$self_addr] + 72];
      HEAP[$pending] = $7;
      
      
      
      var $11 = HEAP[HEAP[$pending]] + 1;
      
      var $13 = HEAP[$pending];
      HEAP[$13] = $11;
      
      var $15 = HEAP[$self_addr] + 76;
      HEAP[$15] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 3:
      
      
      var $22 = HEAP[HEAP[$self_addr] + 72];
      HEAP[$_py_tmp] = $22;
      
      var $24 = HEAP[$self_addr] + 72;
      HEAP[$24] = 0;
      
      
      
      var $28 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $30 = HEAP[$_py_tmp];
      HEAP[$30] = $28;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      var $39 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $40 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$39]($40);
      __label__ = 5;
      break;
     case 5:
      var $41 = HEAP[__PyIO_empty_bytes];
      var $42 = HEAP[$pending];
      var $43 = __PyString_Join($41, $42);
      HEAP[$b] = $43;
      
      
      
      var $47 = HEAP[HEAP[$pending]] - 1;
      
      var $49 = HEAP[$pending];
      HEAP[$49] = $47;
      
      
      
      
      if (HEAP[HEAP[$pending]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $58 = HEAP[HEAP[HEAP[$pending] + 4] + 24];
      var $59 = HEAP[$pending];
      FUNCTION_TABLE[$58]($59);
      __label__ = 7;
      break;
     case 7:
      
      
      if (HEAP[$b] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = -1;
      __label__ = 16;
      break;
     case 9:
      var $62 = HEAP[__PyIO_str_write];
      
      
      var $65 = HEAP[HEAP[$self_addr] + 20];
      var $66 = HEAP[$b];
      var $67 = _PyObject_CallMethodObjArgs($65, $62, allocate([ $66, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$ret] = $67;
      
      
      
      var $71 = HEAP[HEAP[$b]] - 1;
      
      var $73 = HEAP[$b];
      HEAP[$73] = $71;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $82 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $83 = HEAP[$b];
      FUNCTION_TABLE[$82]($83);
      __label__ = 11;
      break;
     case 11:
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      HEAP[$0] = -1;
      __label__ = 16;
      break;
     case 13:
      
      
      
      var $89 = HEAP[HEAP[$ret]] - 1;
      
      var $91 = HEAP[$ret];
      HEAP[$91] = $89;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      
      
      
      
      var $100 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $101 = HEAP[$ret];
      FUNCTION_TABLE[$100]($101);
      __label__ = 15;
      break;
     case 15:
      HEAP[$0] = 0;
      __label__ = 16;
      break;
     case 16:
      var $102 = HEAP[$0];
      HEAP[$retval] = $102;
      __label__ = 17;
      break;
     case 17:
      var $retval16 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval16;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_write($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 56;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 56);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $ret = __stackBase__ + 16;
      var $text = __stackBase__ + 20;
      var $b = __stackBase__ + 24;
      var $textlen = __stackBase__ + 28;
      var $haslf = __stackBase__ + 32;
      var $needflush = __stackBase__ + 36;
      var $r = __stackBase__ + 40;
      var $_res = __stackBase__ + 44;
      var $newtext = __stackBase__ + 48;
      var $_py_tmp = __stackBase__ + 52;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$haslf] = 0;
      HEAP[$needflush] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str59435, allocate([ $text, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 7:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      var $25 = HEAP[HEAP[$self_addr] + 84];
      var $26 = __PyFileIO_closed($25);
      HEAP[$r] = $26;
      __label__ = 16;
      break;
     case 10:
      var $27 = HEAP[$self_addr];
      var $28 = _textiowrapper_closed_get($27, 0);
      HEAP[$_res] = $28;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 12:
      var $31 = HEAP[$_res];
      var $32 = _PyObject_IsTrue($31);
      HEAP[$r] = $32;
      
      
      
      var $36 = HEAP[HEAP[$_res]] - 1;
      
      var $38 = HEAP[$_res];
      HEAP[$38] = $36;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $48 = HEAP[$_res];
      FUNCTION_TABLE[$47]($48);
      __label__ = 14;
      break;
     case 14:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 16:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $53 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($53, __str60436);
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 18:
      __label__ = 21;
      break;
     case 19:
      
      var $55 = HEAP[$self_addr];
      var $56 = __PyIOBase_check_closed($55, __Py_TrueStruct);
      
      if ($56 == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      var $62 = HEAP[_PyExc_IOError];
      _PyErr_SetString($62, __str61437);
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 23:
      
      
      
      var $66 = HEAP[HEAP[$text]] + 1;
      var $67 = HEAP[$text];
      HEAP[$67] = $66;
      var $68 = HEAP[$text];
      var $69 = _PyUnicodeUCS2_GetSize($68);
      HEAP[$textlen] = $69;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 51] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 44] != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 48] != 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 26:
      
      
      
      var $85 = HEAP[HEAP[$text] + 8];
      
      
      
      var $89 = HEAP[HEAP[$text] + 12];
      var $90 = _findchar($89, $85, 10);
      
      if ($90 != 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      HEAP[$haslf] = 1;
      __label__ = 28;
      break;
     case 28:
      
      
      if (HEAP[$haslf] != 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 29:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 51] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 44] != 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 31:
      
      
      var $104 = HEAP[HEAP[$self_addr] + 44];
      var $105 = HEAP[$text];
      var $106 = __PyObject_CallMethod_SizeT($105, __str62438, __str27402, allocate([ __str25400, 0, 0, 0, $104, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$newtext] = $106;
      var $107 = HEAP[$text];
      
      
      var $110 = HEAP[$107] - 1;
      var $111 = $107;
      HEAP[$111] = $110;
      
      
      
      if (HEAP[$107] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $119 = HEAP[HEAP[HEAP[$text] + 4] + 24];
      var $120 = HEAP[$text];
      FUNCTION_TABLE[$119]($120);
      __label__ = 33;
      break;
     case 33:
      
      
      if (HEAP[$newtext] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 35:
      var $123 = HEAP[$newtext];
      HEAP[$text] = $123;
      __label__ = 36;
      break;
     case 36:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 48] != 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 37:
      
      
      if (HEAP[$haslf] != 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 38:
      
      
      
      var $133 = HEAP[HEAP[$text] + 8];
      
      
      
      var $137 = HEAP[HEAP[$text] + 12];
      var $138 = _findchar($137, $133, 13);
      
      if ($138 != 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 39:
      HEAP[$needflush] = 1;
      __label__ = 40;
      break;
     case 40:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 56] != 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      var $146 = HEAP[HEAP[$self_addr] + 56];
      var $147 = HEAP[$text];
      
      var $149 = HEAP[$self_addr];
      var $150 = FUNCTION_TABLE[$146]($149, $147);
      HEAP[$b] = $150;
      
      var $152 = HEAP[$self_addr] + 60;
      HEAP[$152] = 0;
      __label__ = 43;
      break;
     case 42:
      var $153 = HEAP[$text];
      var $154 = HEAP[__PyIO_str_encode];
      
      
      var $157 = HEAP[HEAP[$self_addr] + 28];
      var $158 = _PyObject_CallMethodObjArgs($157, $154, allocate([ $153, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$b] = $158;
      __label__ = 43;
      break;
     case 43:
      var $159 = HEAP[$text];
      
      
      var $162 = HEAP[$159] - 1;
      var $163 = $159;
      HEAP[$163] = $162;
      
      
      
      if (HEAP[$159] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $171 = HEAP[HEAP[HEAP[$text] + 4] + 24];
      var $172 = HEAP[$text];
      FUNCTION_TABLE[$171]($172);
      __label__ = 45;
      break;
     case 45:
      
      
      if (HEAP[$b] == 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 46:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 47:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 48:
      var $179 = _PyList_New(0);
      
      var $181 = HEAP[$self_addr] + 72;
      HEAP[$181] = $179;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 72] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 49:
      
      
      
      var $189 = HEAP[HEAP[$b]] - 1;
      
      var $191 = HEAP[$b];
      HEAP[$191] = $189;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      
      
      
      var $200 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $201 = HEAP[$b];
      FUNCTION_TABLE[$200]($201);
      __label__ = 51;
      break;
     case 51:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 52:
      
      var $203 = HEAP[$self_addr] + 76;
      HEAP[$203] = 0;
      __label__ = 53;
      break;
     case 53:
      
      
      var $206 = HEAP[HEAP[$self_addr] + 72];
      var $207 = HEAP[$b];
      var $208 = _PyList_Append($206, $207);
      
      if ($208 < 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 54:
      
      
      
      var $213 = HEAP[HEAP[$b]] - 1;
      
      var $215 = HEAP[$b];
      HEAP[$215] = $213;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $224 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $225 = HEAP[$b];
      FUNCTION_TABLE[$224]($225);
      __label__ = 56;
      break;
     case 56:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 57:
      
      
      
      
      
      
      
      var $233 = HEAP[HEAP[$self_addr] + 76] + HEAP[HEAP[$b] + 8];
      
      var $235 = HEAP[$self_addr] + 76;
      HEAP[$235] = $233;
      
      
      
      var $239 = HEAP[HEAP[$b]] - 1;
      
      var $241 = HEAP[$b];
      HEAP[$241] = $239;
      
      
      
      
      if (HEAP[HEAP[$b]] == 0) {
        __label__ = 58;
        break;
      } else {
        __label__ = 59;
        break;
      }
     case 58:
      
      
      
      
      var $250 = HEAP[HEAP[HEAP[$b] + 4] + 24];
      var $251 = HEAP[$b];
      FUNCTION_TABLE[$250]($251);
      __label__ = 59;
      break;
     case 59:
      
      
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 76] > HEAP[HEAP[$self_addr] + 16]) {
        __label__ = 61;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 60:
      
      
      if (HEAP[$needflush] != 0) {
        __label__ = 61;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 61:
      var $261 = HEAP[$self_addr];
      var $262 = __textiowrapper_writeflush($261);
      
      if ($262 < 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 62:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 63:
      
      
      if (HEAP[$needflush] != 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 64:
      var $266 = HEAP[__PyIO_str_flush];
      
      
      var $269 = HEAP[HEAP[$self_addr] + 20];
      var $270 = _PyObject_CallMethodObjArgs($269, $266, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$ret] = $270;
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 65;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 65:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 66:
      
      
      
      var $276 = HEAP[HEAP[$ret]] - 1;
      
      var $278 = HEAP[$ret];
      HEAP[$278] = $276;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      
      
      
      
      var $287 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $288 = HEAP[$ret];
      FUNCTION_TABLE[$287]($288);
      __label__ = 68;
      break;
     case 68:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 69:
      
      
      var $295 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $295;
      
      var $297 = HEAP[$self_addr] + 80;
      HEAP[$297] = 0;
      
      
      
      var $301 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $303 = HEAP[$_py_tmp];
      HEAP[$303] = $301;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 70:
      
      
      
      
      var $312 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $313 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$312]($313);
      __label__ = 71;
      break;
     case 71:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 72:
      
      
      var $320 = HEAP[HEAP[$self_addr] + 32];
      var $321 = __PyObject_CallMethod_SizeT($320, __str31406, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$ret] = $321;
      
      
      if (HEAP[$ret] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 73:
      HEAP[$0] = 0;
      __label__ = 77;
      break;
     case 74:
      
      
      
      var $327 = HEAP[HEAP[$ret]] - 1;
      
      var $329 = HEAP[$ret];
      HEAP[$329] = $327;
      
      
      
      
      if (HEAP[HEAP[$ret]] == 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 75:
      
      
      
      
      var $338 = HEAP[HEAP[HEAP[$ret] + 4] + 24];
      var $339 = HEAP[$ret];
      FUNCTION_TABLE[$338]($339);
      __label__ = 76;
      break;
     case 76:
      var $340 = HEAP[$textlen];
      var $341 = _PyLong_FromSsize_t($340);
      HEAP[$0] = $341;
      __label__ = 77;
      break;
     case 77:
      var $342 = HEAP[$0];
      HEAP[$retval] = $342;
      __label__ = 78;
      break;
     case 78:
      var $retval77 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval77;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_set_decoded_chars($self, $chars) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 12;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 12);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $chars_addr = __stackBase__ + 4;
      var $_py_tmp = __stackBase__ + 8;
      
      HEAP[$self_addr] = $self;
      HEAP[$chars_addr] = $chars;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 1:
      
      
      var $6 = HEAP[HEAP[$self_addr] + 64];
      HEAP[$_py_tmp] = $6;
      
      var $8 = HEAP[$self_addr] + 64;
      HEAP[$8] = 0;
      
      
      
      var $12 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $14 = HEAP[$_py_tmp];
      HEAP[$14] = $12;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $24 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$23]($24);
      __label__ = 3;
      break;
     case 3:
      
      var $26 = HEAP[$self_addr] + 64;
      var $27 = HEAP[$chars_addr];
      HEAP[$26] = $27;
      
      var $29 = HEAP[$self_addr] + 68;
      HEAP[$29] = 0;
      __label__ = 4;
      break;
     case 4:
      STACKTOP = __stackBase__;
      return;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_get_decoded_chars($self, $n) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $n_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $chars = __stackBase__ + 16;
      var $avail = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$n_addr] = $n;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      HEAP[$0] = $5;
      __label__ = 14;
      break;
     case 2:
      
      
      
      
      
      
      
      
      
      var $15 = HEAP[HEAP[HEAP[$self_addr] + 64] + 8] - HEAP[HEAP[$self_addr] + 68];
      HEAP[$avail] = $15;
      
      
      if (HEAP[$avail] < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 3:
      ___assert_fail(__str63439, __str15390, 1334, ___PRETTY_FUNCTION___10137);
      throw "Reached an unreachable!";
     case 4:
      
      
      if (HEAP[$n_addr] < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 5:
      
      
      
      if (HEAP[$n_addr] > HEAP[$avail]) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $23 = HEAP[$avail];
      HEAP[$n_addr] = $23;
      __label__ = 7;
      break;
     case 7:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] > 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 8:
      
      
      
      if (HEAP[$n_addr] < HEAP[$avail]) {
        __label__ = 9;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 9:
      
      
      
      
      
      
      
      
      
      var $40 = HEAP[HEAP[HEAP[$self_addr] + 64] + 12] + 2 * HEAP[HEAP[$self_addr] + 68];
      var $41 = HEAP[$n_addr];
      var $42 = _PyUnicodeUCS2_FromUnicode($40, $41);
      HEAP[$chars] = $42;
      
      
      if (HEAP[$chars] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 11:
      __label__ = 13;
      break;
     case 12:
      
      
      var $47 = HEAP[HEAP[$self_addr] + 64];
      HEAP[$chars] = $47;
      
      
      
      var $51 = HEAP[HEAP[$chars]] + 1;
      
      var $53 = HEAP[$chars];
      HEAP[$53] = $51;
      __label__ = 13;
      break;
     case 13:
      
      
      
      
      var $58 = HEAP[HEAP[$self_addr] + 68] + HEAP[$n_addr];
      
      var $60 = HEAP[$self_addr] + 68;
      HEAP[$60] = $58;
      var $61 = HEAP[$chars];
      HEAP[$0] = $61;
      __label__ = 14;
      break;
     case 14:
      var $62 = HEAP[$0];
      HEAP[$retval] = $62;
      __label__ = 15;
      break;
     case 15:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_read_chunk($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 52;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 52);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $iftmp_189 = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $dec_buffer = __stackBase__ + 16;
      var $dec_flags = __stackBase__ + 20;
      var $input_chunk = __stackBase__ + 24;
      var $decoded_chars = __stackBase__ + 28;
      var $chunk_size = __stackBase__ + 32;
      var $eof = __stackBase__ + 36;
      var $state = __stackBase__ + 40;
      var $next_input = __stackBase__ + 44;
      var $_py_tmp = __stackBase__ + 48;
      
      HEAP[$self_addr] = $self;
      HEAP[$dec_buffer] = 0;
      HEAP[$dec_flags] = 0;
      HEAP[$input_chunk] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      var $5 = HEAP[_PyExc_IOError];
      _PyErr_SetString($5, __str64440);
      HEAP[$0] = -1;
      __label__ = 49;
      break;
     case 2:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 53] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 3:
      var $10 = HEAP[__PyIO_str_getstate];
      
      
      var $13 = HEAP[HEAP[$self_addr] + 32];
      var $14 = _PyObject_CallMethodObjArgs($13, $10, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$state] = $14;
      
      
      if (HEAP[$state] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = -1;
      __label__ = 49;
      break;
     case 5:
      var $17 = HEAP[$state];
      var $18 = __PyArg_Parse_SizeT($17, __str65441, allocate([ $dec_buffer, 0, 0, 0, $dec_flags, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($18 < 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 6:
      
      
      
      var $23 = HEAP[HEAP[$state]] - 1;
      
      var $25 = HEAP[$state];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $35 = HEAP[$state];
      FUNCTION_TABLE[$34]($35);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = -1;
      __label__ = 49;
      break;
     case 9:
      
      
      
      var $39 = HEAP[HEAP[$dec_buffer]] + 1;
      var $40 = HEAP[$dec_buffer];
      HEAP[$40] = $39;
      
      
      
      var $44 = HEAP[HEAP[$dec_flags]] + 1;
      var $45 = HEAP[$dec_flags];
      HEAP[$45] = $44;
      
      
      
      var $49 = HEAP[HEAP[$state]] - 1;
      
      var $51 = HEAP[$state];
      HEAP[$51] = $49;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $60 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $61 = HEAP[$state];
      FUNCTION_TABLE[$60]($61);
      __label__ = 11;
      break;
     case 11:
      
      
      var $64 = HEAP[HEAP[$self_addr] + 16];
      var $65 = _PyLong_FromSsize_t($64);
      HEAP[$chunk_size] = $65;
      
      
      if (HEAP[$chunk_size] == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 12:
      var $68 = HEAP[__PyIO_str_read1];
      
      
      var $71 = HEAP[HEAP[$self_addr] + 20];
      var $72 = HEAP[$chunk_size];
      var $73 = _PyObject_CallMethodObjArgs($71, $68, allocate([ $72, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$input_chunk] = $73;
      
      
      
      var $77 = HEAP[HEAP[$chunk_size]] - 1;
      
      var $79 = HEAP[$chunk_size];
      HEAP[$79] = $77;
      
      
      
      
      if (HEAP[HEAP[$chunk_size]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $88 = HEAP[HEAP[HEAP[$chunk_size] + 4] + 24];
      var $89 = HEAP[$chunk_size];
      FUNCTION_TABLE[$88]($89);
      __label__ = 14;
      break;
     case 14:
      
      
      if (HEAP[$input_chunk] == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 15:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$input_chunk] + 4] + 84] & 134217728) == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      ___assert_fail(__str66442, __str15390, 1407, ___PRETTY_FUNCTION___10181);
      throw "Reached an unreachable!";
     case 17:
      var $99 = HEAP[$input_chunk];
      var $100 = _PyString_Size($99);
      
      var $102 = $100 == 0;
      HEAP[$eof] = $102;
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$self_addr] + 32] + 4] == _PyIncrementalNewlineDecoder_Type) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      
      
      var $111 = HEAP[HEAP[$self_addr] + 32];
      var $112 = HEAP[$input_chunk];
      var $113 = HEAP[$eof];
      var $114 = __PyIncrementalNewlineDecoder_decode($111, $112, $113);
      HEAP[$decoded_chars] = $114;
      __label__ = 23;
      break;
     case 19:
      
      
      if (HEAP[$eof] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$iftmp_189] = __Py_TrueStruct;
      __label__ = 22;
      break;
     case 21:
      HEAP[$iftmp_189] = __Py_ZeroStruct;
      __label__ = 22;
      break;
     case 22:
      var $117 = HEAP[__PyIO_str_decode];
      
      
      var $120 = HEAP[HEAP[$self_addr] + 32];
      var $121 = HEAP[$input_chunk];
      var $122 = HEAP[$iftmp_189];
      var $123 = _PyObject_CallMethodObjArgs($120, $117, allocate([ $121, 0, 0, 0, $122, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$decoded_chars] = $123;
      __label__ = 23;
      break;
     case 23:
      
      
      if (HEAP[$decoded_chars] == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 24:
      var $126 = HEAP[$self_addr];
      var $127 = HEAP[$decoded_chars];
      _textiowrapper_set_decoded_chars($126, $127);
      
      
      
      
      
      if (HEAP[HEAP[$decoded_chars] + 8] > 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      HEAP[$eof] = 0;
      __label__ = 26;
      break;
     case 26:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 53] != 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 27:
      var $137 = HEAP[$dec_buffer];
      var $138 = HEAP[$input_chunk];
      var $139 = _PyNumber_Add($137, $138);
      HEAP[$next_input] = $139;
      
      
      if (HEAP[$next_input] == 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 28:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$next_input] + 4] + 84] & 134217728) == 0) {
        __label__ = 29;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 29:
      ___assert_fail(__str67443, __str15390, 1434, ___PRETTY_FUNCTION___10181);
      throw "Reached an unreachable!";
     case 30:
      var $149 = HEAP[$dec_buffer];
      
      
      var $152 = HEAP[$149] - 1;
      var $153 = $149;
      HEAP[$153] = $152;
      
      
      
      if (HEAP[$149] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 32;
        break;
      }
     case 31:
      
      
      
      
      var $161 = HEAP[HEAP[HEAP[$dec_buffer] + 4] + 24];
      var $162 = HEAP[$dec_buffer];
      FUNCTION_TABLE[$161]($162);
      __label__ = 32;
      break;
     case 32:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 33:
      
      
      var $169 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $169;
      
      var $171 = HEAP[$self_addr] + 80;
      HEAP[$171] = 0;
      
      
      
      var $175 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $177 = HEAP[$_py_tmp];
      HEAP[$177] = $175;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      
      
      
      
      var $186 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $187 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$186]($187);
      __label__ = 35;
      break;
     case 35:
      var $188 = HEAP[$dec_flags];
      var $189 = HEAP[$next_input];
      var $190 = __Py_BuildValue_SizeT(__str68444, allocate([ $188, 0, 0, 0, $189, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      
      var $192 = HEAP[$self_addr] + 80;
      HEAP[$192] = $190;
      __label__ = 36;
      break;
     case 36:
      
      
      
      var $196 = HEAP[HEAP[$input_chunk]] - 1;
      
      var $198 = HEAP[$input_chunk];
      HEAP[$198] = $196;
      
      
      
      
      if (HEAP[HEAP[$input_chunk]] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      
      
      
      
      var $207 = HEAP[HEAP[HEAP[$input_chunk] + 4] + 24];
      var $208 = HEAP[$input_chunk];
      FUNCTION_TABLE[$207]($208);
      __label__ = 38;
      break;
     case 38:
      
      
      var $211 = HEAP[$eof] == 0;
      HEAP[$0] = $211;
      __label__ = 49;
      break;
     case 39:
      
      
      if (HEAP[$dec_buffer] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      var $214 = HEAP[$dec_buffer];
      
      
      var $217 = HEAP[$214] - 1;
      var $218 = $214;
      HEAP[$218] = $217;
      
      
      
      if (HEAP[$214] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $226 = HEAP[HEAP[HEAP[$dec_buffer] + 4] + 24];
      var $227 = HEAP[$dec_buffer];
      FUNCTION_TABLE[$226]($227);
      __label__ = 42;
      break;
     case 42:
      
      
      if (HEAP[$dec_flags] != 0) {
        __label__ = 43;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 43:
      var $230 = HEAP[$dec_flags];
      
      
      var $233 = HEAP[$230] - 1;
      var $234 = $230;
      HEAP[$234] = $233;
      
      
      
      if (HEAP[$230] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $242 = HEAP[HEAP[HEAP[$dec_flags] + 4] + 24];
      var $243 = HEAP[$dec_flags];
      FUNCTION_TABLE[$242]($243);
      __label__ = 45;
      break;
     case 45:
      
      
      if (HEAP[$input_chunk] != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      
      
      
      var $249 = HEAP[HEAP[$input_chunk]] - 1;
      
      var $251 = HEAP[$input_chunk];
      HEAP[$251] = $249;
      
      
      
      
      if (HEAP[HEAP[$input_chunk]] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      
      
      
      
      var $260 = HEAP[HEAP[HEAP[$input_chunk] + 4] + 24];
      var $261 = HEAP[$input_chunk];
      FUNCTION_TABLE[$260]($261);
      __label__ = 48;
      break;
     case 48:
      HEAP[$0] = -1;
      __label__ = 49;
      break;
     case 49:
      var $262 = HEAP[$0];
      HEAP[$retval] = $262;
      __label__ = 50;
      break;
     case 50:
      var $retval48 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval48;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_read($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 68;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 68);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $n = __stackBase__ + 16;
      var $result = __stackBase__ + 20;
      var $chunks = __stackBase__ + 24;
      var $r = __stackBase__ + 28;
      var $_res = __stackBase__ + 32;
      var $bytes = __stackBase__ + 36;
      var $decoded = __stackBase__ + 40;
      var $final = __stackBase__ + 44;
      var $_py_tmp = __stackBase__ + 48;
      var $res = __stackBase__ + 52;
      var $remaining = __stackBase__ + 56;
      var $_py_tmp59 = __stackBase__ + 60;
      var $_py_tmp64 = __stackBase__ + 64;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$n] = -1;
      HEAP[$result] = 0;
      HEAP[$chunks] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str69445, allocate([ FUNCTION_TABLE_OFFSET + 2, 0, 0, 0, $n, 0, 0, 0 ], [ "i32 (%struct.PyObject*, i8*)*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 7:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      var $25 = HEAP[HEAP[$self_addr] + 84];
      var $26 = __PyFileIO_closed($25);
      HEAP[$r] = $26;
      __label__ = 16;
      break;
     case 10:
      var $27 = HEAP[$self_addr];
      var $28 = _textiowrapper_closed_get($27, 0);
      HEAP[$_res] = $28;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 12:
      var $31 = HEAP[$_res];
      var $32 = _PyObject_IsTrue($31);
      HEAP[$r] = $32;
      
      
      
      var $36 = HEAP[HEAP[$_res]] - 1;
      
      var $38 = HEAP[$_res];
      HEAP[$38] = $36;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $48 = HEAP[$_res];
      FUNCTION_TABLE[$47]($48);
      __label__ = 14;
      break;
     case 14:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 16:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $53 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($53, __str60436);
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 18:
      __label__ = 21;
      break;
     case 19:
      
      var $55 = HEAP[$self_addr];
      var $56 = __PyIOBase_check_closed($55, __Py_TrueStruct);
      
      if ($56 == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      var $62 = HEAP[_PyExc_IOError];
      _PyErr_SetString($62, __str64440);
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 23:
      var $63 = HEAP[$self_addr];
      var $64 = __textiowrapper_writeflush($63);
      
      if ($64 < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 25:
      
      
      if (HEAP[$n] < 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 26:
      
      
      var $70 = HEAP[HEAP[$self_addr] + 20];
      var $71 = __PyObject_CallMethod_SizeT($70, __str1375, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$bytes] = $71;
      
      
      if (HEAP[$bytes] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      var $74 = HEAP[__PyIO_str_decode];
      
      
      var $77 = HEAP[HEAP[$self_addr] + 32];
      var $78 = HEAP[$bytes];
      var $79 = _PyObject_CallMethodObjArgs($77, $74, allocate([ $78, 0, 0, 0, __Py_TrueStruct, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$decoded] = $79;
      
      
      
      var $83 = HEAP[HEAP[$bytes]] - 1;
      
      var $85 = HEAP[$bytes];
      HEAP[$85] = $83;
      
      
      
      
      if (HEAP[HEAP[$bytes]] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      
      var $94 = HEAP[HEAP[HEAP[$bytes] + 4] + 24];
      var $95 = HEAP[$bytes];
      FUNCTION_TABLE[$94]($95);
      __label__ = 29;
      break;
     case 29:
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      var $98 = HEAP[$self_addr];
      var $99 = _textiowrapper_get_decoded_chars($98, -1);
      HEAP[$result] = $99;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 31:
      
      
      
      var $105 = HEAP[HEAP[$decoded]] - 1;
      
      var $107 = HEAP[$decoded];
      HEAP[$107] = $105;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      var $116 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $117 = HEAP[$decoded];
      FUNCTION_TABLE[$116]($117);
      __label__ = 33;
      break;
     case 33:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 34:
      var $118 = HEAP[$result];
      var $119 = HEAP[$decoded];
      var $120 = _PyUnicodeUCS2_Concat($118, $119);
      HEAP[$final] = $120;
      
      
      
      var $124 = HEAP[HEAP[$result]] - 1;
      
      var $126 = HEAP[$result];
      HEAP[$126] = $124;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 35:
      
      
      
      
      var $135 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $136 = HEAP[$result];
      FUNCTION_TABLE[$135]($136);
      __label__ = 36;
      break;
     case 36:
      
      
      
      var $140 = HEAP[HEAP[$decoded]] - 1;
      
      var $142 = HEAP[$decoded];
      HEAP[$142] = $140;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      
      
      
      
      var $151 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $152 = HEAP[$decoded];
      FUNCTION_TABLE[$151]($152);
      __label__ = 38;
      break;
     case 38:
      
      
      if (HEAP[$final] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 39:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 40:
      
      
      var $161 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $161;
      
      var $163 = HEAP[$self_addr] + 80;
      HEAP[$163] = 0;
      
      
      
      var $167 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $169 = HEAP[$_py_tmp];
      HEAP[$169] = $167;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $178 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $179 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$178]($179);
      __label__ = 42;
      break;
     case 42:
      var $180 = HEAP[$final];
      HEAP[$0] = $180;
      __label__ = 73;
      break;
     case 43:
      HEAP[$res] = 1;
      var $181 = HEAP[$n];
      HEAP[$remaining] = $181;
      var $182 = HEAP[$n];
      var $183 = HEAP[$self_addr];
      var $184 = _textiowrapper_get_decoded_chars($183, $182);
      HEAP[$result] = $184;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      
      
      
      
      
      var $192 = HEAP[$remaining] - HEAP[HEAP[$result] + 8];
      HEAP[$remaining] = $192;
      __label__ = 54;
      break;
     case 45:
      var $193 = HEAP[$self_addr];
      var $194 = _textiowrapper_read_chunk($193);
      HEAP[$res] = $194;
      
      
      if (HEAP[$res] < 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      var $201 = _PyList_New(0);
      HEAP[$chunks] = $201;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 49:
      var $204 = HEAP[$chunks];
      var $205 = HEAP[$result];
      var $206 = _PyList_Append($204, $205);
      
      if ($206 < 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 50:
      
      
      
      var $211 = HEAP[HEAP[$result]] - 1;
      
      var $213 = HEAP[$result];
      HEAP[$213] = $211;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 51;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 51:
      
      
      
      
      var $222 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $223 = HEAP[$result];
      FUNCTION_TABLE[$222]($223);
      __label__ = 52;
      break;
     case 52:
      var $224 = HEAP[$self_addr];
      var $225 = HEAP[$remaining];
      var $226 = _textiowrapper_get_decoded_chars($224, $225);
      HEAP[$result] = $226;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 53:
      
      
      
      
      
      var $234 = HEAP[$remaining] - HEAP[HEAP[$result] + 8];
      HEAP[$remaining] = $234;
      __label__ = 54;
      break;
     case 54:
      
      
      if (HEAP[$remaining] > 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 55:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 56:
      
      
      if (HEAP[$result] != 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      var $241 = HEAP[$chunks];
      var $242 = HEAP[$result];
      var $243 = _PyList_Append($241, $242);
      
      if ($243 < 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      if (HEAP[$result] != 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 59:
      var $247 = HEAP[$result];
      HEAP[$_py_tmp59] = $247;
      HEAP[$result] = 0;
      
      
      
      var $251 = HEAP[HEAP[$_py_tmp59]] - 1;
      
      var $253 = HEAP[$_py_tmp59];
      HEAP[$253] = $251;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp59]] == 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      
      
      
      
      var $262 = HEAP[HEAP[HEAP[$_py_tmp59] + 4] + 24];
      var $263 = HEAP[$_py_tmp59];
      FUNCTION_TABLE[$262]($263);
      __label__ = 61;
      break;
     case 61:
      var $264 = HEAP[__PyIO_empty_str];
      var $265 = HEAP[$chunks];
      var $266 = _PyUnicodeUCS2_Join($264, $265);
      HEAP[$result] = $266;
      
      
      if (HEAP[$result] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 63:
      var $271 = HEAP[$chunks];
      HEAP[$_py_tmp64] = $271;
      HEAP[$chunks] = 0;
      
      
      
      var $275 = HEAP[HEAP[$_py_tmp64]] - 1;
      
      var $277 = HEAP[$_py_tmp64];
      HEAP[$277] = $275;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp64]] == 0) {
        __label__ = 64;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 64:
      
      
      
      
      var $286 = HEAP[HEAP[HEAP[$_py_tmp64] + 4] + 24];
      var $287 = HEAP[$_py_tmp64];
      FUNCTION_TABLE[$286]($287);
      __label__ = 65;
      break;
     case 65:
      var $288 = HEAP[$result];
      HEAP[$0] = $288;
      __label__ = 73;
      break;
     case 66:
      
      
      if (HEAP[$result] != 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 67:
      
      
      
      var $294 = HEAP[HEAP[$result]] - 1;
      
      var $296 = HEAP[$result];
      HEAP[$296] = $294;
      
      
      
      
      if (HEAP[HEAP[$result]] == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      
      
      
      
      var $305 = HEAP[HEAP[HEAP[$result] + 4] + 24];
      var $306 = HEAP[$result];
      FUNCTION_TABLE[$305]($306);
      __label__ = 69;
      break;
     case 69:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 70;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 70:
      
      
      
      var $312 = HEAP[HEAP[$chunks]] - 1;
      
      var $314 = HEAP[$chunks];
      HEAP[$314] = $312;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      
      
      
      
      var $323 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $324 = HEAP[$chunks];
      FUNCTION_TABLE[$323]($324);
      __label__ = 72;
      break;
     case 72:
      HEAP[$0] = 0;
      __label__ = 73;
      break;
     case 73:
      var $325 = HEAP[$0];
      HEAP[$retval] = $325;
      __label__ = 74;
      break;
     case 74:
      var $retval74 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval74;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _find_control_char($start, $end, $ch) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 22;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 22);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $start_addr = __stackBase__;
      var $end_addr = __stackBase__ + 4;
      var $ch_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 10;
      var $0 = __stackBase__ + 14;
      var $s = __stackBase__ + 18;
      
      HEAP[$start_addr] = $start;
      HEAP[$end_addr] = $end;
      HEAP[$ch_addr] = $ch;
      var $1 = HEAP[$start_addr];
      HEAP[$s] = $1;
      __label__ = 1;
      break;
     case 1:
      __label__ = 3;
      break;
     case 2:
      
      var $3 = HEAP[$s] + 2;
      HEAP[$s] = $3;
      __label__ = 3;
      break;
     case 3:
      
      
      
      
      if (HEAP[HEAP[$s]] > HEAP[$ch_addr]) {
        __label__ = 2;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 4:
      
      
      
      
      if (HEAP[HEAP[$s]] == HEAP[$ch_addr]) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      var $12 = HEAP[$s];
      HEAP[$0] = $12;
      __label__ = 9;
      break;
     case 6:
      
      
      
      if (HEAP[$s] == HEAP[$end_addr]) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 8:
      
      var $17 = HEAP[$s] + 2;
      HEAP[$s] = $17;
      __label__ = 1;
      break;
     case 9:
      var $18 = HEAP[$0];
      HEAP[$retval] = $18;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __PyIO_find_line_ending($translated, $universal, $readnl, $start, $end, $consumed) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 78;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 78);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $translated_addr = __stackBase__;
      var $universal_addr = __stackBase__ + 4;
      var $readnl_addr = __stackBase__ + 8;
      var $start_addr = __stackBase__ + 12;
      var $end_addr = __stackBase__ + 16;
      var $consumed_addr = __stackBase__ + 20;
      var $retval = __stackBase__ + 24;
      var $0 = __stackBase__ + 28;
      var $len = __stackBase__ + 32;
      var $pos = __stackBase__ + 36;
      var $s = __stackBase__ + 40;
      var $ch = __stackBase__ + 44;
      var $readnl_len = __stackBase__ + 46;
      var $nl = __stackBase__ + 50;
      var $pos19 = __stackBase__ + 54;
      var $s23 = __stackBase__ + 58;
      var $e = __stackBase__ + 62;
      var $pos24 = __stackBase__ + 66;
      var $i = __stackBase__ + 70;
      var $pos28 = __stackBase__ + 74;
      
      HEAP[$translated_addr] = $translated;
      HEAP[$universal_addr] = $universal;
      HEAP[$readnl_addr] = $readnl;
      HEAP[$start_addr] = $start;
      HEAP[$end_addr] = $end;
      HEAP[$consumed_addr] = $consumed;
      
      
      
      
      
      var $6 = (HEAP[$end_addr] - HEAP[$start_addr]) / 2 | 0;
      HEAP[$len] = $6;
      
      
      if (HEAP[$translated_addr] != 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 4;
        break;
      }
     case 1:
      var $9 = HEAP[$start_addr];
      var $10 = HEAP[$end_addr];
      var $11 = _find_control_char($9, $10, 10);
      HEAP[$pos] = $11;
      
      
      if (HEAP[$pos] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      
      
      
      
      var $20 = ((HEAP[$pos] - HEAP[$start_addr]) / 2 | 0) + 1;
      HEAP[$0] = $20;
      __label__ = 39;
      break;
     case 3:
      var $21 = HEAP[$consumed_addr];
      var $22 = HEAP[$len];
      HEAP[$21] = $22;
      HEAP[$0] = -1;
      __label__ = 39;
      break;
     case 4:
      
      
      if (HEAP[$universal_addr] != 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 5:
      var $25 = HEAP[$start_addr];
      HEAP[$s] = $25;
      __label__ = 6;
      break;
     case 6:
      __label__ = 8;
      break;
     case 7:
      
      var $27 = HEAP[$s] + 2;
      HEAP[$s] = $27;
      __label__ = 8;
      break;
     case 8:
      
      
      
      if (HEAP[HEAP[$s]] > 13) {
        __label__ = 7;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 9:
      
      
      
      if (HEAP[$s] >= HEAP[$end_addr]) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $34 = HEAP[$consumed_addr];
      var $35 = HEAP[$len];
      HEAP[$34] = $35;
      HEAP[$0] = -1;
      __label__ = 39;
      break;
     case 11:
      
      var $37 = HEAP[HEAP[$s]];
      HEAP[$ch] = $37;
      
      var $39 = HEAP[$s] + 2;
      HEAP[$s] = $39;
      
      
      if (HEAP[$ch] == 10) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      
      var $47 = (HEAP[$s] - HEAP[$start_addr]) / 2 | 0;
      HEAP[$0] = $47;
      __label__ = 39;
      break;
     case 13:
      
      
      if (HEAP[$ch] == 13) {
        __label__ = 14;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 14:
      
      
      
      if (HEAP[HEAP[$s]] == 10) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      
      
      var $59 = ((HEAP[$s] - HEAP[$start_addr]) / 2 | 0) + 1;
      HEAP[$0] = $59;
      __label__ = 39;
      break;
     case 16:
      
      
      
      
      
      var $65 = (HEAP[$s] - HEAP[$start_addr]) / 2 | 0;
      HEAP[$0] = $65;
      __label__ = 39;
      break;
     case 17:
      __label__ = 6;
      break;
     case 18:
      
      
      
      var $69 = HEAP[HEAP[$readnl_addr] + 8];
      HEAP[$readnl_len] = $69;
      
      
      
      var $73 = HEAP[$readnl_addr] + 20;
      HEAP[$nl] = $73;
      
      
      if (HEAP[$readnl_len] == 1) {
        __label__ = 19;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 19:
      
      
      
      
      var $80 = HEAP[$start_addr];
      var $81 = HEAP[$end_addr];
      var $82 = HEAP[HEAP[$nl]] & 65535;
      var $83 = _find_control_char($80, $81, $82);
      HEAP[$pos19] = $83;
      
      
      if (HEAP[$pos19] != 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      
      
      
      
      
      
      var $92 = ((HEAP[$pos19] - HEAP[$start_addr]) / 2 | 0) + 1;
      HEAP[$0] = $92;
      __label__ = 39;
      break;
     case 21:
      var $93 = HEAP[$consumed_addr];
      var $94 = HEAP[$len];
      HEAP[$93] = $94;
      HEAP[$0] = -1;
      __label__ = 39;
      break;
     case 22:
      var $95 = HEAP[$start_addr];
      HEAP[$s23] = $95;
      
      
      
      
      var $100 = HEAP[$end_addr] + 2 * (0 - HEAP[$readnl_len]) + 2;
      HEAP[$e] = $100;
      
      
      
      if (HEAP[$e] < HEAP[$s23]) {
        __label__ = 23;
        break;
      } else {
        __label__ = 24;
        break;
      }
     case 23:
      var $104 = HEAP[$s23];
      HEAP[$e] = $104;
      __label__ = 24;
      break;
     case 24:
      __label__ = 34;
      break;
     case 25:
      
      
      
      
      var $109 = HEAP[$s23];
      var $110 = HEAP[$end_addr];
      var $111 = HEAP[HEAP[$nl]] & 65535;
      var $112 = _find_control_char($109, $110, $111);
      HEAP[$pos28] = $112;
      
      
      if (HEAP[$pos28] == 0) {
        __label__ = 35;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      
      
      if (HEAP[$pos28] >= HEAP[$e]) {
        __label__ = 35;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 27:
      HEAP[$i] = 1;
      __label__ = 30;
      break;
     case 28:
      
      
      
      
      
      
      
      
      
      
      if (HEAP[HEAP[$pos28] + 2 * HEAP[$i]] != HEAP[HEAP[$nl] + HEAP[$i]]) {
        __label__ = 31;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      var $129 = HEAP[$i] + 1;
      HEAP[$i] = $129;
      __label__ = 30;
      break;
     case 30:
      
      
      
      if (HEAP[$i] < HEAP[$readnl_len]) {
        __label__ = 28;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 31:
      
      
      
      if (HEAP[$i] == HEAP[$readnl_len]) {
        __label__ = 32;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 32:
      
      
      
      
      
      
      
      var $143 = ((HEAP[$pos28] - HEAP[$start_addr]) / 2 | 0) + HEAP[$readnl_len];
      HEAP[$0] = $143;
      __label__ = 39;
      break;
     case 33:
      
      var $145 = HEAP[$pos28] + 2;
      HEAP[$s23] = $145;
      __label__ = 34;
      break;
     case 34:
      
      
      
      if (HEAP[$s23] < HEAP[$e]) {
        __label__ = 25;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 35:
      
      
      
      
      var $153 = HEAP[$e];
      var $154 = HEAP[$end_addr];
      var $155 = HEAP[HEAP[$nl]] & 65535;
      var $156 = _find_control_char($153, $154, $155);
      HEAP[$pos24] = $156;
      
      
      if (HEAP[$pos24] == 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 36:
      var $159 = HEAP[$consumed_addr];
      var $160 = HEAP[$len];
      HEAP[$159] = $160;
      __label__ = 38;
      break;
     case 37:
      
      
      
      
      
      var $166 = (HEAP[$pos24] - HEAP[$start_addr]) / 2 | 0;
      var $167 = HEAP[$consumed_addr];
      HEAP[$167] = $166;
      __label__ = 38;
      break;
     case 38:
      HEAP[$0] = -1;
      __label__ = 39;
      break;
     case 39:
      var $168 = HEAP[$0];
      HEAP[$retval] = $168;
      __label__ = 40;
      break;
     case 40:
      var $retval43 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval43;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_readline($self, $limit) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 100;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 100);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $limit_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $line = __stackBase__ + 16;
      var $chunks = __stackBase__ + 20;
      var $remaining = __stackBase__ + 24;
      var $start = __stackBase__ + 28;
      var $endpos = __stackBase__ + 32;
      var $chunked = __stackBase__ + 36;
      var $offset_to_buffer = __stackBase__ + 40;
      var $res = __stackBase__ + 44;
      var $r = __stackBase__ + 48;
      var $_res = __stackBase__ + 52;
      var $ptr = __stackBase__ + 56;
      var $line_len = __stackBase__ + 60;
      var $consumed = __stackBase__ + 64;
      var $_py_tmp = __stackBase__ + 68;
      var $_py_tmp32 = __stackBase__ + 72;
      var $s = __stackBase__ + 76;
      var $_py_tmp57 = __stackBase__ + 80;
      var $s68 = __stackBase__ + 84;
      var $_py_tmp70 = __stackBase__ + 88;
      var $_py_tmp80 = __stackBase__ + 92;
      var $_py_tmp87 = __stackBase__ + 96;
      
      HEAP[$self_addr] = $self;
      HEAP[$limit_addr] = $limit;
      HEAP[$line] = 0;
      HEAP[$chunks] = 0;
      HEAP[$remaining] = 0;
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 1;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      
      
      var $12 = HEAP[HEAP[$self_addr] + 84];
      var $13 = __PyFileIO_closed($12);
      HEAP[$r] = $13;
      __label__ = 9;
      break;
     case 3:
      var $14 = HEAP[$self_addr];
      var $15 = _textiowrapper_closed_get($14, 0);
      HEAP[$_res] = $15;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 5:
      var $18 = HEAP[$_res];
      var $19 = _PyObject_IsTrue($18);
      HEAP[$r] = $19;
      
      
      
      var $23 = HEAP[HEAP[$_res]] - 1;
      
      var $25 = HEAP[$_res];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $35 = HEAP[$_res];
      FUNCTION_TABLE[$34]($35);
      __label__ = 7;
      break;
     case 7:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 9:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      var $40 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($40, __str60436);
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 11:
      __label__ = 14;
      break;
     case 12:
      
      var $42 = HEAP[$self_addr];
      var $43 = __PyIOBase_check_closed($42, __Py_TrueStruct);
      
      if ($43 == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 14:
      var $45 = HEAP[$self_addr];
      var $46 = __textiowrapper_writeflush($45);
      
      if ($46 < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 16:
      HEAP[$chunked] = 0;
      __label__ = 17;
      break;
     case 17:
      HEAP[$consumed] = 0;
      HEAP[$res] = 1;
      __label__ = 20;
      break;
     case 18:
      var $48 = HEAP[$self_addr];
      var $49 = _textiowrapper_read_chunk($48);
      HEAP[$res] = $49;
      
      
      if (HEAP[$res] < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 19:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 20:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 21:
      
      
      
      
      
      
      
      if (HEAP[HEAP[HEAP[$self_addr] + 64] + 8] == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 22;
        break;
      }
     case 22:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 23;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 23:
      var $67 = HEAP[$self_addr];
      _textiowrapper_set_decoded_chars($67, 0);
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 24:
      
      
      var $74 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $74;
      
      var $76 = HEAP[$self_addr] + 80;
      HEAP[$76] = 0;
      
      
      
      var $80 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $82 = HEAP[$_py_tmp];
      HEAP[$82] = $80;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 25;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 25:
      
      
      
      
      var $91 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $92 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$91]($92);
      __label__ = 26;
      break;
     case 26:
      HEAP[$offset_to_buffer] = 0;
      var $93 = HEAP[$offset_to_buffer];
      HEAP[$endpos] = $93;
      var $94 = HEAP[$endpos];
      HEAP[$start] = $94;
      __label__ = 59;
      break;
     case 27:
      
      
      if (HEAP[$remaining] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      var $99 = HEAP[HEAP[$self_addr] + 64];
      HEAP[$line] = $99;
      
      
      var $102 = HEAP[HEAP[$self_addr] + 68];
      HEAP[$start] = $102;
      HEAP[$offset_to_buffer] = 0;
      
      
      
      var $106 = HEAP[HEAP[$line]] + 1;
      var $107 = HEAP[$line];
      HEAP[$107] = $106;
      __label__ = 35;
      break;
     case 29:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] != 0) {
        __label__ = 30;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 30:
      ___assert_fail(__str70446, __str15390, 1691, ___PRETTY_FUNCTION___10683);
      throw "Reached an unreachable!";
     case 31:
      
      
      var $114 = HEAP[HEAP[$self_addr] + 64];
      var $115 = HEAP[$remaining];
      var $116 = _PyUnicodeUCS2_Concat($115, $114);
      HEAP[$line] = $116;
      HEAP[$start] = 0;
      
      
      
      var $120 = HEAP[HEAP[$remaining] + 8];
      HEAP[$offset_to_buffer] = $120;
      
      
      if (HEAP[$remaining] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      var $123 = HEAP[$remaining];
      HEAP[$_py_tmp32] = $123;
      HEAP[$remaining] = 0;
      
      
      
      var $127 = HEAP[HEAP[$_py_tmp32]] - 1;
      
      var $129 = HEAP[$_py_tmp32];
      HEAP[$129] = $127;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp32]] == 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      
      
      
      
      var $138 = HEAP[HEAP[HEAP[$_py_tmp32] + 4] + 24];
      var $139 = HEAP[$_py_tmp32];
      FUNCTION_TABLE[$138]($139);
      __label__ = 34;
      break;
     case 34:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 35:
      
      
      
      var $145 = HEAP[HEAP[$line] + 12];
      HEAP[$ptr] = $145;
      
      
      
      var $149 = HEAP[HEAP[$line] + 8];
      HEAP[$line_len] = $149;
      
      
      var $152 = HEAP[$ptr] + 2 * HEAP[$line_len];
      
      
      var $155 = HEAP[$ptr] + 2 * HEAP[$start];
      
      
      var $158 = HEAP[HEAP[$self_addr] + 36];
      
      
      
      var $162 = HEAP[HEAP[$self_addr] + 49];
      
      
      
      var $166 = HEAP[HEAP[$self_addr] + 50];
      var $167 = __PyIO_find_line_ending($166, $162, $158, $155, $152, $consumed);
      HEAP[$endpos] = $167;
      
      
      if (HEAP[$endpos] >= 0) {
        __label__ = 36;
        break;
      } else {
        __label__ = 40;
        break;
      }
     case 36:
      
      
      var $172 = HEAP[$endpos] + HEAP[$start];
      HEAP[$endpos] = $172;
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 37:
      
      
      
      
      
      
      
      if (HEAP[$endpos] - HEAP[$start] + HEAP[$chunked] >= HEAP[$limit_addr]) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      
      
      
      
      var $186 = HEAP[$start] + HEAP[$limit_addr] - HEAP[$chunked];
      HEAP[$endpos] = $186;
      __label__ = 39;
      break;
     case 39:
      __label__ = 59;
      break;
     case 40:
      
      
      var $189 = HEAP[$consumed] + HEAP[$start];
      HEAP[$endpos] = $189;
      
      
      if (HEAP[$limit_addr] >= 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 41:
      
      
      
      
      
      
      
      if (HEAP[$endpos] - HEAP[$start] + HEAP[$chunked] >= HEAP[$limit_addr]) {
        __label__ = 42;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 42:
      
      
      
      
      var $203 = HEAP[$start] + HEAP[$limit_addr] - HEAP[$chunked];
      HEAP[$endpos] = $203;
      __label__ = 59;
      break;
     case 43:
      
      
      
      if (HEAP[$endpos] > HEAP[$start]) {
        __label__ = 44;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 44:
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 45;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 45:
      var $209 = _PyList_New(0);
      HEAP[$chunks] = $209;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 46;
        break;
      }
     case 46:
      
      
      var $214 = HEAP[$endpos] - HEAP[$start];
      
      
      var $217 = HEAP[$ptr] + 2 * HEAP[$start];
      var $218 = _PyUnicodeUCS2_FromUnicode($217, $214);
      HEAP[$s] = $218;
      
      
      if (HEAP[$s] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      var $221 = HEAP[$chunks];
      var $222 = HEAP[$s];
      var $223 = _PyList_Append($221, $222);
      
      if ($223 < 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 48:
      
      
      
      var $228 = HEAP[HEAP[$s]] - 1;
      
      var $230 = HEAP[$s];
      HEAP[$230] = $228;
      
      
      
      
      if (HEAP[HEAP[$s]] == 0) {
        __label__ = 49;
        break;
      } else {
        __label__ = 50;
        break;
      }
     case 49:
      
      
      
      
      var $239 = HEAP[HEAP[HEAP[$s] + 4] + 24];
      var $240 = HEAP[$s];
      FUNCTION_TABLE[$239]($240);
      __label__ = 50;
      break;
     case 50:
      __label__ = 90;
      break;
     case 51:
      
      
      
      
      
      var $246 = HEAP[HEAP[$s] + 8] + HEAP[$chunked];
      HEAP[$chunked] = $246;
      
      
      
      var $250 = HEAP[HEAP[$s]] - 1;
      
      var $252 = HEAP[$s];
      HEAP[$252] = $250;
      
      
      
      
      if (HEAP[HEAP[$s]] == 0) {
        __label__ = 52;
        break;
      } else {
        __label__ = 53;
        break;
      }
     case 52:
      
      
      
      
      var $261 = HEAP[HEAP[HEAP[$s] + 4] + 24];
      var $262 = HEAP[$s];
      FUNCTION_TABLE[$261]($262);
      __label__ = 53;
      break;
     case 53:
      
      
      
      if (HEAP[$endpos] < HEAP[$line_len]) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      var $268 = HEAP[$line_len] - HEAP[$endpos];
      
      
      var $271 = HEAP[$ptr] + 2 * HEAP[$endpos];
      var $272 = _PyUnicodeUCS2_FromUnicode($271, $268);
      HEAP[$remaining] = $272;
      
      
      if (HEAP[$remaining] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 55:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 56;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 56:
      var $277 = HEAP[$line];
      HEAP[$_py_tmp57] = $277;
      HEAP[$line] = 0;
      
      
      
      var $281 = HEAP[HEAP[$_py_tmp57]] - 1;
      
      var $283 = HEAP[$_py_tmp57];
      HEAP[$283] = $281;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp57]] == 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      
      
      
      
      var $292 = HEAP[HEAP[HEAP[$_py_tmp57] + 4] + 24];
      var $293 = HEAP[$_py_tmp57];
      FUNCTION_TABLE[$292]($293);
      __label__ = 58;
      break;
     case 58:
      var $294 = HEAP[$self_addr];
      _textiowrapper_set_decoded_chars($294, 0);
      __label__ = 17;
      break;
     case 59:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 60;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 60:
      
      
      var $299 = HEAP[$endpos] - HEAP[$offset_to_buffer];
      
      var $301 = HEAP[$self_addr] + 68;
      HEAP[$301] = $299;
      
      
      if (HEAP[$start] > 0) {
        __label__ = 62;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      
      
      
      
      
      if (HEAP[HEAP[$line] + 8] > HEAP[$endpos]) {
        __label__ = 62;
        break;
      } else {
        __label__ = 71;
        break;
      }
     case 62:
      
      
      if (HEAP[$start] != 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 63;
        break;
      }
     case 63:
      
      
      
      
      if (HEAP[HEAP[$line]] != 1) {
        __label__ = 66;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      var $316 = HEAP[$endpos];
      var $317 = _PyUnicodeUCS2_Resize($line, $316);
      
      if ($317 < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      __label__ = 71;
      break;
     case 66:
      
      
      var $321 = HEAP[$endpos] - HEAP[$start];
      
      
      
      
      
      var $327 = HEAP[HEAP[$line] + 12] + 2 * HEAP[$start];
      var $328 = _PyUnicodeUCS2_FromUnicode($327, $321);
      HEAP[$s68] = $328;
      
      
      if (HEAP[$line] != 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 67:
      var $331 = HEAP[$line];
      HEAP[$_py_tmp70] = $331;
      HEAP[$line] = 0;
      
      
      
      var $335 = HEAP[HEAP[$_py_tmp70]] - 1;
      
      var $337 = HEAP[$_py_tmp70];
      HEAP[$337] = $335;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp70]] == 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 69;
        break;
      }
     case 68:
      
      
      
      
      var $346 = HEAP[HEAP[HEAP[$_py_tmp70] + 4] + 24];
      var $347 = HEAP[$_py_tmp70];
      FUNCTION_TABLE[$346]($347);
      __label__ = 69;
      break;
     case 69:
      
      
      if (HEAP[$s68] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 70:
      var $350 = HEAP[$s68];
      HEAP[$line] = $350;
      __label__ = 71;
      break;
     case 71:
      
      
      if (HEAP[$remaining] != 0) {
        __label__ = 72;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 72:
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 73:
      var $355 = _PyList_New(0);
      HEAP[$chunks] = $355;
      
      
      if (HEAP[$chunks] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 74:
      var $358 = HEAP[$chunks];
      var $359 = HEAP[$remaining];
      var $360 = _PyList_Append($358, $359);
      
      if ($360 < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 75:
      
      
      if (HEAP[$remaining] != 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 76:
      var $364 = HEAP[$remaining];
      HEAP[$_py_tmp80] = $364;
      HEAP[$remaining] = 0;
      
      
      
      var $368 = HEAP[HEAP[$_py_tmp80]] - 1;
      
      var $370 = HEAP[$_py_tmp80];
      HEAP[$370] = $368;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp80]] == 0) {
        __label__ = 77;
        break;
      } else {
        __label__ = 78;
        break;
      }
     case 77:
      
      
      
      
      var $379 = HEAP[HEAP[HEAP[$_py_tmp80] + 4] + 24];
      var $380 = HEAP[$_py_tmp80];
      FUNCTION_TABLE[$379]($380);
      __label__ = 78;
      break;
     case 78:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 79;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 79:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 80:
      var $385 = HEAP[$line];
      var $386 = HEAP[$chunks];
      var $387 = _PyList_Append($386, $385);
      
      if ($387 < 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 82:
      var $391 = HEAP[$line];
      HEAP[$_py_tmp87] = $391;
      HEAP[$line] = 0;
      
      
      
      var $395 = HEAP[HEAP[$_py_tmp87]] - 1;
      
      var $397 = HEAP[$_py_tmp87];
      HEAP[$397] = $395;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp87]] == 0) {
        __label__ = 83;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 83:
      
      
      
      
      var $406 = HEAP[HEAP[HEAP[$_py_tmp87] + 4] + 24];
      var $407 = HEAP[$_py_tmp87];
      FUNCTION_TABLE[$406]($407);
      __label__ = 84;
      break;
     case 84:
      var $408 = HEAP[__PyIO_empty_str];
      var $409 = HEAP[$chunks];
      var $410 = _PyUnicodeUCS2_Join($408, $409);
      HEAP[$line] = $410;
      
      
      if (HEAP[$line] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 85:
      
      
      
      var $416 = HEAP[HEAP[$chunks]] - 1;
      
      var $418 = HEAP[$chunks];
      HEAP[$418] = $416;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 86:
      
      
      
      
      var $427 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $428 = HEAP[$chunks];
      FUNCTION_TABLE[$427]($428);
      __label__ = 87;
      break;
     case 87:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 89;
        break;
      }
     case 88:
      var $431 = _PyUnicodeUCS2_FromStringAndSize(0, 0);
      HEAP[$line] = $431;
      __label__ = 89;
      break;
     case 89:
      var $432 = HEAP[$line];
      HEAP[$0] = $432;
      __label__ = 100;
      break;
     case 90:
      
      
      if (HEAP[$chunks] != 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 91:
      
      
      
      var $438 = HEAP[HEAP[$chunks]] - 1;
      
      var $440 = HEAP[$chunks];
      HEAP[$440] = $438;
      
      
      
      
      if (HEAP[HEAP[$chunks]] == 0) {
        __label__ = 92;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 92:
      
      
      
      
      var $449 = HEAP[HEAP[HEAP[$chunks] + 4] + 24];
      var $450 = HEAP[$chunks];
      FUNCTION_TABLE[$449]($450);
      __label__ = 93;
      break;
     case 93:
      
      
      if (HEAP[$remaining] != 0) {
        __label__ = 94;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 94:
      
      
      
      var $456 = HEAP[HEAP[$remaining]] - 1;
      
      var $458 = HEAP[$remaining];
      HEAP[$458] = $456;
      
      
      
      
      if (HEAP[HEAP[$remaining]] == 0) {
        __label__ = 95;
        break;
      } else {
        __label__ = 96;
        break;
      }
     case 95:
      
      
      
      
      var $467 = HEAP[HEAP[HEAP[$remaining] + 4] + 24];
      var $468 = HEAP[$remaining];
      FUNCTION_TABLE[$467]($468);
      __label__ = 96;
      break;
     case 96:
      
      
      if (HEAP[$line] != 0) {
        __label__ = 97;
        break;
      } else {
        __label__ = 99;
        break;
      }
     case 97:
      var $471 = HEAP[$line];
      
      
      var $474 = HEAP[$471] - 1;
      var $475 = $471;
      HEAP[$475] = $474;
      
      
      
      if (HEAP[$471] == 0) {
        __label__ = 98;
        break;
      } else {
        __label__ = 99;
        break;
      }
     case 98:
      
      
      
      
      var $483 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $484 = HEAP[$line];
      FUNCTION_TABLE[$483]($484);
      __label__ = 99;
      break;
     case 99:
      HEAP[$0] = 0;
      __label__ = 100;
      break;
     case 100:
      var $485 = HEAP[$0];
      HEAP[$retval] = $485;
      __label__ = 101;
      break;
     case 101:
      var $retval105 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval105;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_readline($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $limitobj = __stackBase__ + 16;
      var $limit = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$limitobj] = 0;
      HEAP[$limit] = -1;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str71447, allocate([ $limitobj, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 7:
      
      
      if (HEAP[$limitobj] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 8:
      var $16 = HEAP[$limitobj];
      var $17 = _PyNumber_Check($16);
      
      if ($17 == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$limitobj] + 4] + 12];
      var $24 = HEAP[_PyExc_TypeError];
      var $25 = _PyErr_Format($24, __str72448, allocate([ $23, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 10:
      var $26 = HEAP[_PyExc_OverflowError];
      var $27 = HEAP[$limitobj];
      var $28 = _PyNumber_AsSsize_t($27, $26);
      HEAP[$limit] = $28;
      
      var $30 = HEAP[$limit] == -1;
      if ($30) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      var $31 = _PyErr_Occurred();
      
      if ($31 != 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      HEAP[$0] = 0;
      __label__ = 14;
      break;
     case 13:
      var $33 = HEAP[$self_addr];
      var $34 = HEAP[$limit];
      var $35 = __textiowrapper_readline($33, $34);
      HEAP[$0] = $35;
      __label__ = 14;
      break;
     case 14:
      var $36 = HEAP[$0];
      HEAP[$retval] = $36;
      __label__ = 15;
      break;
     case 15:
      var $retval14 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval14;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_parse_cookie($cookie, $cookieObj) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 41;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 41);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $cookie_addr = __stackBase__;
      var $cookieObj_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $buffer = __stackBase__ + 16;
      var $cookieLong = __stackBase__ + 37;
      
      HEAP[$cookie_addr] = $cookie;
      HEAP[$cookieObj_addr] = $cookieObj;
      var $1 = HEAP[$cookieObj_addr];
      var $2 = _PyNumber_Long($1);
      var $3 = $2;
      HEAP[$cookieLong] = $3;
      
      
      if (HEAP[$cookieLong] == 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 1:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 2:
      var $6 = HEAP[$cookieLong];
      var $buffer2 = $buffer;
      var $7 = __PyLong_AsByteArray($6, $buffer2, 21, 1, 0);
      
      if ($7 < 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 3:
      
      var $10 = HEAP[$cookieLong];
      
      
      var $13 = HEAP[$10] - 1;
      var $14 = $10;
      HEAP[$14] = $13;
      
      
      
      if (HEAP[$10] == 0) {
        __label__ = 4;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 4:
      
      
      
      
      
      var $23 = HEAP[HEAP[HEAP[$cookieLong] + 4] + 24];
      
      var $25 = HEAP[$cookieLong];
      FUNCTION_TABLE[$23]($25);
      __label__ = 5;
      break;
     case 5:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 6:
      
      var $27 = HEAP[$cookieLong];
      
      
      var $30 = HEAP[$27] - 1;
      var $31 = $27;
      HEAP[$31] = $30;
      
      
      
      if (HEAP[$27] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      
      var $40 = HEAP[HEAP[HEAP[$cookieLong] + 4] + 24];
      
      var $42 = HEAP[$cookieLong];
      FUNCTION_TABLE[$40]($42);
      __label__ = 8;
      break;
     case 8:
      
      
      
      var $45 = $buffer;
      var $46 = HEAP[$cookie_addr];
      _llvm_memcpy_p0i8_p0i8_i32($46, $45, 8, 1, 0);
      
      
      
      var $49 = $buffer + 8;
      var $50 = HEAP[$cookie_addr] + 8;
      _llvm_memcpy_p0i8_p0i8_i32($50, $49, 4, 1, 0);
      
      
      
      var $53 = $buffer + 12;
      var $54 = HEAP[$cookie_addr] + 12;
      _llvm_memcpy_p0i8_p0i8_i32($54, $53, 4, 1, 0);
      
      
      
      var $57 = $buffer + 16;
      var $58 = HEAP[$cookie_addr] + 16;
      _llvm_memcpy_p0i8_p0i8_i32($58, $57, 4, 1, 0);
      
      var $60 = HEAP[$cookie_addr] + 20;
      
      var $61 = $buffer + 20;
      _llvm_memcpy_p0i8_p0i8_i32($60, $61, 1, 1, 0);
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 9:
      var $62 = HEAP[$0];
      HEAP[$retval] = $62;
      __label__ = 10;
      break;
     case 10:
      var $retval15 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval15;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_build_cookie($cookie) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 33;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 33);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $cookie_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $buffer = __stackBase__ + 12;
      
      HEAP[$cookie_addr] = $cookie;
      
      
      
      var $3 = $buffer;
      var $4 = HEAP[$cookie_addr];
      _llvm_memcpy_p0i8_p0i8_i32($3, $4, 8, 1, 0);
      
      
      
      var $7 = $buffer + 8;
      var $8 = HEAP[$cookie_addr] + 8;
      _llvm_memcpy_p0i8_p0i8_i32($7, $8, 4, 1, 0);
      
      
      
      var $11 = $buffer + 12;
      var $12 = HEAP[$cookie_addr] + 12;
      _llvm_memcpy_p0i8_p0i8_i32($11, $12, 4, 1, 0);
      
      
      
      var $15 = $buffer + 16;
      var $16 = HEAP[$cookie_addr] + 16;
      _llvm_memcpy_p0i8_p0i8_i32($15, $16, 4, 1, 0);
      
      var $18 = HEAP[$cookie_addr] + 20;
      
      var $19 = $buffer + 20;
      _llvm_memcpy_p0i8_p0i8_i32($19, $18, 1, 1, 0);
      var $buffer6 = $buffer;
      var $20 = __PyLong_FromByteArray($buffer6, 21, 1, 0);
      HEAP[$0] = $20;
      var $21 = HEAP[$0];
      HEAP[$retval] = $21;
      __label__ = 1;
      break;
     case 1:
      var $retval7 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval7;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_decoder_setstate($self, $cookie) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $cookie_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$cookie_addr] = $cookie;
      
      
      
      
      if (HEAP[HEAP[$cookie_addr]] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$cookie_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      var $9 = HEAP[__PyIO_str_reset];
      
      
      var $12 = HEAP[HEAP[$self_addr] + 32];
      var $13 = _PyObject_CallMethodObjArgs($12, $9, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $13;
      __label__ = 4;
      break;
     case 3:
      
      
      var $16 = HEAP[HEAP[$cookie_addr] + 8];
      
      
      var $19 = HEAP[HEAP[$self_addr] + 32];
      var $20 = __PyObject_CallMethod_SizeT($19, __str22397, __str73449, allocate([ __str20395, 0, 0, 0, $16, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $20;
      __label__ = 4;
      break;
     case 4:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 6:
      
      
      
      var $26 = HEAP[HEAP[$res]] - 1;
      
      var $28 = HEAP[$res];
      HEAP[$28] = $26;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $37 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $38 = HEAP[$res];
      FUNCTION_TABLE[$37]($38);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 9:
      var $39 = HEAP[$0];
      HEAP[$retval] = $39;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function __textiowrapper_encoder_setstate($self, $cookie) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $cookie_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$cookie_addr] = $cookie;
      
      
      
      
      if (HEAP[HEAP[$cookie_addr]] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 1;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$cookie_addr] + 8] != 0) {
        __label__ = 3;
        break;
      } else {
        __label__ = 2;
        break;
      }
     case 2:
      var $9 = HEAP[__PyIO_str_reset];
      
      
      var $12 = HEAP[HEAP[$self_addr] + 28];
      var $13 = _PyObject_CallMethodObjArgs($12, $9, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $13;
      
      var $15 = HEAP[$self_addr] + 60;
      HEAP[$15] = 1;
      __label__ = 4;
      break;
     case 3:
      var $16 = HEAP[__PyIO_zero];
      var $17 = HEAP[__PyIO_str_setstate];
      
      
      var $20 = HEAP[HEAP[$self_addr] + 28];
      var $21 = _PyObject_CallMethodObjArgs($20, $17, allocate([ $16, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $21;
      
      var $23 = HEAP[$self_addr] + 60;
      HEAP[$23] = 0;
      __label__ = 4;
      break;
     case 4:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 5;
        break;
      } else {
        __label__ = 6;
        break;
      }
     case 5:
      HEAP[$0] = -1;
      __label__ = 9;
      break;
     case 6:
      
      
      
      var $29 = HEAP[HEAP[$res]] - 1;
      
      var $31 = HEAP[$res];
      HEAP[$31] = $29;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      
      
      var $40 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $41 = HEAP[$res];
      FUNCTION_TABLE[$40]($41);
      __label__ = 8;
      break;
     case 8:
      HEAP[$0] = 0;
      __label__ = 9;
      break;
     case 9:
      var $42 = HEAP[$0];
      HEAP[$retval] = $42;
      __label__ = 10;
      break;
     case 10:
      var $retval9 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval9;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_seek($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 88;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 88);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $cookieObj = __stackBase__ + 16;
      var $posobj = __stackBase__ + 20;
      var $cookie = __stackBase__ + 24;
      var $whence = __stackBase__ + 48;
      var $res = __stackBase__ + 52;
      var $cmp = __stackBase__ + 56;
      var $r = __stackBase__ + 60;
      var $_res = __stackBase__ + 64;
      var $_py_tmp = __stackBase__ + 68;
      var $repr = __stackBase__ + 72;
      var $_py_tmp68 = __stackBase__ + 76;
      var $input_chunk = __stackBase__ + 80;
      var $decoded = __stackBase__ + 84;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$whence] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str74, allocate([ $cookieObj, 0, 0, 0, $whence, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 7:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 8;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 8:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      var $25 = HEAP[HEAP[$self_addr] + 84];
      var $26 = __PyFileIO_closed($25);
      HEAP[$r] = $26;
      __label__ = 16;
      break;
     case 10:
      var $27 = HEAP[$self_addr];
      var $28 = _textiowrapper_closed_get($27, 0);
      HEAP[$_res] = $28;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 12:
      var $31 = HEAP[$_res];
      var $32 = _PyObject_IsTrue($31);
      HEAP[$r] = $32;
      
      
      
      var $36 = HEAP[HEAP[$_res]] - 1;
      
      var $38 = HEAP[$_res];
      HEAP[$38] = $36;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      
      
      
      
      var $47 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $48 = HEAP[$_res];
      FUNCTION_TABLE[$47]($48);
      __label__ = 14;
      break;
     case 14:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 16:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 17;
        break;
      } else {
        __label__ = 18;
        break;
      }
     case 17:
      var $53 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($53, __str60436);
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 18:
      __label__ = 21;
      break;
     case 19:
      
      var $55 = HEAP[$self_addr];
      var $56 = __PyIOBase_check_closed($55, __Py_TrueStruct);
      
      if ($56 == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 21:
      
      
      
      var $61 = HEAP[HEAP[$cookieObj]] + 1;
      var $62 = HEAP[$cookieObj];
      HEAP[$62] = $61;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      var $67 = HEAP[_PyExc_IOError];
      _PyErr_SetString($67, __str75);
      __label__ = 88;
      break;
     case 23:
      
      
      if (HEAP[$whence] == 1) {
        __label__ = 24;
        break;
      } else {
        __label__ = 31;
        break;
      }
     case 24:
      var $70 = HEAP[__PyIO_zero];
      var $71 = HEAP[$cookieObj];
      var $72 = _PyObject_RichCompareBool($71, $70, 2);
      HEAP[$cmp] = $72;
      
      
      if (HEAP[$cmp] < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 25:
      
      
      if (HEAP[$cmp] == 0) {
        __label__ = 26;
        break;
      } else {
        __label__ = 27;
        break;
      }
     case 26:
      var $77 = HEAP[_PyExc_IOError];
      _PyErr_SetString($77, __str76);
      __label__ = 88;
      break;
     case 27:
      var $78 = HEAP[$cookieObj];
      
      
      var $81 = HEAP[$78] - 1;
      var $82 = $78;
      HEAP[$82] = $81;
      
      
      
      if (HEAP[$78] == 0) {
        __label__ = 28;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 28:
      
      
      
      
      var $90 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $91 = HEAP[$cookieObj];
      FUNCTION_TABLE[$90]($91);
      __label__ = 29;
      break;
     case 29:
      
      var $93 = HEAP[$self_addr];
      var $94 = __PyObject_CallMethod_SizeT($93, __str77, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$cookieObj] = $94;
      
      
      if (HEAP[$cookieObj] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      __label__ = 51;
      break;
     case 31:
      
      
      if (HEAP[$whence] == 2) {
        __label__ = 32;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 32:
      var $99 = HEAP[__PyIO_zero];
      var $100 = HEAP[$cookieObj];
      var $101 = _PyObject_RichCompareBool($100, $99, 2);
      HEAP[$cmp] = $101;
      
      
      if (HEAP[$cmp] < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 33;
        break;
      }
     case 33:
      
      
      if (HEAP[$cmp] == 0) {
        __label__ = 34;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 34:
      var $106 = HEAP[_PyExc_IOError];
      _PyErr_SetString($106, __str78);
      __label__ = 88;
      break;
     case 35:
      
      var $108 = HEAP[$self_addr];
      var $109 = __PyObject_CallMethod_SizeT($108, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $109;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 36:
      
      
      
      var $115 = HEAP[HEAP[$res]] - 1;
      
      var $117 = HEAP[$res];
      HEAP[$117] = $115;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 37;
        break;
      } else {
        __label__ = 38;
        break;
      }
     case 37:
      
      
      
      
      var $126 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $127 = HEAP[$res];
      FUNCTION_TABLE[$126]($127);
      __label__ = 38;
      break;
     case 38:
      var $128 = HEAP[$self_addr];
      _textiowrapper_set_decoded_chars($128, 0);
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 39;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 39:
      
      
      var $135 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $135;
      
      var $137 = HEAP[$self_addr] + 80;
      HEAP[$137] = 0;
      
      
      
      var $141 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $143 = HEAP[$_py_tmp];
      HEAP[$143] = $141;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 41;
        break;
      }
     case 40:
      
      
      
      
      var $152 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $153 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$152]($153);
      __label__ = 41;
      break;
     case 41:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 42;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 42:
      
      
      var $160 = HEAP[HEAP[$self_addr] + 32];
      var $161 = __PyObject_CallMethod_SizeT($160, __str31406, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $161;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 43:
      
      
      
      var $167 = HEAP[HEAP[$res]] - 1;
      
      var $169 = HEAP[$res];
      HEAP[$169] = $167;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 44;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 44:
      
      
      
      
      var $178 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $179 = HEAP[$res];
      FUNCTION_TABLE[$178]($179);
      __label__ = 45;
      break;
     case 45:
      
      
      var $182 = HEAP[HEAP[$self_addr] + 20];
      var $183 = __PyObject_CallMethod_SizeT($182, __str80, __str81, allocate([ 0, 0, 0, 0, 2, 0, 0, 0 ], [ "i32", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $183;
      
      
      if (HEAP[$cookieObj] != 0) {
        __label__ = 46;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 46:
      var $186 = HEAP[$cookieObj];
      
      
      var $189 = HEAP[$186] - 1;
      var $190 = $186;
      HEAP[$190] = $189;
      
      
      
      if (HEAP[$186] == 0) {
        __label__ = 47;
        break;
      } else {
        __label__ = 48;
        break;
      }
     case 47:
      
      
      
      
      var $198 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $199 = HEAP[$cookieObj];
      FUNCTION_TABLE[$198]($199);
      __label__ = 48;
      break;
     case 48:
      var $200 = HEAP[$res];
      HEAP[$0] = $200;
      __label__ = 92;
      break;
     case 49:
      
      
      if (HEAP[$whence] != 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      var $203 = HEAP[$whence];
      var $204 = HEAP[_PyExc_ValueError];
      var $205 = _PyErr_Format($204, __str82, allocate([ $203, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      __label__ = 88;
      break;
     case 51:
      var $206 = HEAP[__PyIO_zero];
      var $207 = HEAP[$cookieObj];
      var $208 = _PyObject_RichCompareBool($207, $206, 0);
      HEAP[$cmp] = $208;
      
      
      if (HEAP[$cmp] < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      
      
      if (HEAP[$cmp] == 1) {
        __label__ = 53;
        break;
      } else {
        __label__ = 57;
        break;
      }
     case 53:
      var $213 = HEAP[$cookieObj];
      var $214 = _PyObject_Repr($213);
      HEAP[$repr] = $214;
      
      
      if (HEAP[$repr] != 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 54:
      
      
      
      var $220 = HEAP[$repr] + 20;
      var $221 = HEAP[_PyExc_ValueError];
      var $222 = _PyErr_Format($221, __str83, allocate([ $220, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $226 = HEAP[HEAP[$repr]] - 1;
      
      var $228 = HEAP[$repr];
      HEAP[$228] = $226;
      
      
      
      
      if (HEAP[HEAP[$repr]] == 0) {
        __label__ = 55;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 55:
      
      
      
      
      var $237 = HEAP[HEAP[HEAP[$repr] + 4] + 24];
      var $238 = HEAP[$repr];
      FUNCTION_TABLE[$237]($238);
      __label__ = 56;
      break;
     case 56:
      __label__ = 88;
      break;
     case 57:
      var $239 = HEAP[__PyIO_str_flush];
      
      var $241 = HEAP[$self_addr];
      var $242 = _PyObject_CallMethodObjArgs($241, $239, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $242;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 58:
      
      
      
      var $248 = HEAP[HEAP[$res]] - 1;
      
      var $250 = HEAP[$res];
      HEAP[$250] = $248;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 60;
        break;
      }
     case 59:
      
      
      
      
      var $259 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $260 = HEAP[$res];
      FUNCTION_TABLE[$259]($260);
      __label__ = 60;
      break;
     case 60:
      var $261 = HEAP[$cookieObj];
      var $262 = _textiowrapper_parse_cookie($cookie, $261);
      
      if ($262 < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 61:
      
      var $265 = HEAP[$cookie];
      var $266 = _PyLong_FromLongLong($265);
      HEAP[$posobj] = $266;
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      var $269 = HEAP[__PyIO_str_seek];
      
      
      var $272 = HEAP[HEAP[$self_addr] + 20];
      var $273 = HEAP[$posobj];
      var $274 = _PyObject_CallMethodObjArgs($272, $269, allocate([ $273, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $274;
      
      
      
      var $278 = HEAP[HEAP[$posobj]] - 1;
      
      var $280 = HEAP[$posobj];
      HEAP[$280] = $278;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 63;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 63:
      
      
      
      
      var $289 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $290 = HEAP[$posobj];
      FUNCTION_TABLE[$289]($290);
      __label__ = 64;
      break;
     case 64:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 65;
        break;
      }
     case 65:
      
      
      
      var $296 = HEAP[HEAP[$res]] - 1;
      
      var $298 = HEAP[$res];
      HEAP[$298] = $296;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 66;
        break;
      } else {
        __label__ = 67;
        break;
      }
     case 66:
      
      
      
      
      var $307 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $308 = HEAP[$res];
      FUNCTION_TABLE[$307]($308);
      __label__ = 67;
      break;
     case 67:
      var $309 = HEAP[$self_addr];
      _textiowrapper_set_decoded_chars($309, 0);
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 68;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 68:
      
      
      var $316 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp68] = $316;
      
      var $318 = HEAP[$self_addr] + 80;
      HEAP[$318] = 0;
      
      
      
      var $322 = HEAP[HEAP[$_py_tmp68]] - 1;
      
      var $324 = HEAP[$_py_tmp68];
      HEAP[$324] = $322;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp68]] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $333 = HEAP[HEAP[HEAP[$_py_tmp68] + 4] + 24];
      var $334 = HEAP[$_py_tmp68];
      FUNCTION_TABLE[$333]($334);
      __label__ = 70;
      break;
     case 70:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] != 0) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      var $339 = HEAP[$self_addr];
      var $340 = __textiowrapper_decoder_setstate($339, $cookie);
      
      if ($340 < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 72:
      
      
      
      if (HEAP[$cookie + 16] != 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 84;
        break;
      }
     case 73:
      
      var $346 = HEAP[$cookie + 12];
      
      
      var $349 = HEAP[HEAP[$self_addr] + 20];
      var $350 = __PyObject_CallMethod_SizeT($349, __str1375, __str84, allocate([ $346, 0, 0, 0 ], [ "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$input_chunk] = $350;
      
      
      if (HEAP[$input_chunk] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 74;
        break;
      }
     case 74:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$input_chunk] + 4] + 84] & 134217728) == 0) {
        __label__ = 75;
        break;
      } else {
        __label__ = 76;
        break;
      }
     case 75:
      ___assert_fail(__str66442, __str15390, 2088, ___PRETTY_FUNCTION___11136);
      throw "Reached an unreachable!";
     case 76:
      
      var $361 = HEAP[$cookie + 8];
      var $362 = HEAP[$input_chunk];
      var $363 = __Py_BuildValue_SizeT(__str85, allocate([ $361, 0, 0, 0, $362, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      
      var $365 = HEAP[$self_addr] + 80;
      HEAP[$365] = $363;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] == 0) {
        __label__ = 77;
        break;
      } else {
        __label__ = 80;
        break;
      }
     case 77:
      
      
      
      var $373 = HEAP[HEAP[$input_chunk]] - 1;
      
      var $375 = HEAP[$input_chunk];
      HEAP[$375] = $373;
      
      
      
      
      if (HEAP[HEAP[$input_chunk]] == 0) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      
      
      
      
      var $384 = HEAP[HEAP[HEAP[$input_chunk] + 4] + 24];
      var $385 = HEAP[$input_chunk];
      FUNCTION_TABLE[$384]($385);
      __label__ = 79;
      break;
     case 79:
      __label__ = 88;
      break;
     case 80:
      
      
      var $388 = HEAP[$cookie + 20];
      
      
      var $391 = HEAP[HEAP[$self_addr] + 32];
      var $392 = HEAP[$input_chunk];
      var $393 = __PyObject_CallMethod_SizeT($391, __str29404, __str51427, allocate([ $392, 0, 0, 0, $388, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$decoded] = $393;
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 81:
      var $396 = HEAP[$self_addr];
      var $397 = HEAP[$decoded];
      _textiowrapper_set_decoded_chars($396, $397);
      
      
      var $400 = HEAP[HEAP[$self_addr] + 64];
      var $401 = _PyUnicodeUCS2_GetSize($400);
      
      
      
      if ($401 < HEAP[$cookie + 16]) {
        __label__ = 82;
        break;
      } else {
        __label__ = 83;
        break;
      }
     case 82:
      var $405 = HEAP[_PyExc_IOError];
      _PyErr_SetString($405, __str86);
      __label__ = 88;
      break;
     case 83:
      
      var $407 = HEAP[$cookie + 16];
      
      var $409 = HEAP[$self_addr] + 68;
      HEAP[$409] = $407;
      __label__ = 85;
      break;
     case 84:
      
      var $411 = HEAP[$cookie + 8];
      var $412 = __Py_BuildValue_SizeT(__str87, allocate([ $411, 0, 0, 0, __str20395, 0, 0, 0 ], [ "i32", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      var $414 = HEAP[$self_addr] + 80;
      HEAP[$414] = $412;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] == 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 85:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 28] != 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 86:
      var $423 = HEAP[$self_addr];
      var $424 = __textiowrapper_encoder_setstate($423, $cookie);
      
      if ($424 < 0) {
        __label__ = 88;
        break;
      } else {
        __label__ = 87;
        break;
      }
     case 87:
      var $426 = HEAP[$cookieObj];
      HEAP[$0] = $426;
      __label__ = 92;
      break;
     case 88:
      
      
      if (HEAP[$cookieObj] != 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 89:
      var $429 = HEAP[$cookieObj];
      
      
      var $432 = HEAP[$429] - 1;
      var $433 = $429;
      HEAP[$433] = $432;
      
      
      
      if (HEAP[$429] == 0) {
        __label__ = 90;
        break;
      } else {
        __label__ = 91;
        break;
      }
     case 90:
      
      
      
      
      var $441 = HEAP[HEAP[HEAP[$cookieObj] + 4] + 24];
      var $442 = HEAP[$cookieObj];
      FUNCTION_TABLE[$441]($442);
      __label__ = 91;
      break;
     case 91:
      HEAP[$0] = 0;
      __label__ = 92;
      break;
     case 92:
      var $443 = HEAP[$0];
      HEAP[$retval] = $443;
      __label__ = 93;
      break;
     case 93:
      var $retval92 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval92;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_tell($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 116;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 116);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $posobj = __stackBase__ + 20;
      var $cookie = __stackBase__ + 24;
      var $next_input = __stackBase__ + 48;
      var $chars_to_skip = __stackBase__ + 52;
      var $chars_decoded = __stackBase__ + 56;
      var $saved_state = __stackBase__ + 60;
      var $input = __stackBase__ + 64;
      var $input_end = __stackBase__ + 68;
      var $r = __stackBase__ + 72;
      var $_res = __stackBase__ + 76;
      var $state = __stackBase__ + 80;
      var $dec_buffer = __stackBase__ + 84;
      var $dec_buffer_len = __stackBase__ + 88;
      var $dec_flags = __stackBase__ + 92;
      var $decoded = __stackBase__ + 96;
      var $decoded65 = __stackBase__ + 100;
      var $type = __stackBase__ + 104;
      var $value = __stackBase__ + 108;
      var $traceback = __stackBase__ + 112;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$posobj] = 0;
      
      HEAP[$cookie] = 0;
      
      HEAP[$cookie + 8] = 0;
      
      HEAP[$cookie + 12] = 0;
      
      HEAP[$cookie + 16] = 0;
      
      HEAP[$cookie + 20] = 0;
      HEAP[$saved_state] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $14 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($14, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $15 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($15, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 5:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      var $27 = HEAP[HEAP[$self_addr] + 84];
      var $28 = __PyFileIO_closed($27);
      HEAP[$r] = $28;
      __label__ = 14;
      break;
     case 8:
      var $29 = HEAP[$self_addr];
      var $30 = _textiowrapper_closed_get($29, 0);
      HEAP[$_res] = $30;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 10:
      var $33 = HEAP[$_res];
      var $34 = _PyObject_IsTrue($33);
      HEAP[$r] = $34;
      
      
      
      var $38 = HEAP[HEAP[$_res]] - 1;
      
      var $40 = HEAP[$_res];
      HEAP[$40] = $38;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $49 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $50 = HEAP[$_res];
      FUNCTION_TABLE[$49]($50);
      __label__ = 12;
      break;
     case 12:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 14:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $55 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($55, __str60436);
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 16:
      __label__ = 19;
      break;
     case 17:
      
      var $57 = HEAP[$self_addr];
      var $58 = __PyIOBase_check_closed($57, __Py_TrueStruct);
      
      if ($58 == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 19:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 52] == 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      var $64 = HEAP[_PyExc_IOError];
      _PyErr_SetString($64, __str75);
      __label__ = 82;
      break;
     case 21:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 53] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      var $69 = HEAP[_PyExc_IOError];
      _PyErr_SetString($69, __str88);
      __label__ = 82;
      break;
     case 23:
      var $70 = HEAP[$self_addr];
      var $71 = __textiowrapper_writeflush($70);
      
      if ($71 < 0) {
        __label__ = 24;
        break;
      } else {
        __label__ = 25;
        break;
      }
     case 24:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 25:
      
      var $74 = HEAP[$self_addr];
      var $75 = __PyObject_CallMethod_SizeT($74, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $75;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 26;
        break;
      }
     case 26:
      
      
      
      var $81 = HEAP[HEAP[$res]] - 1;
      
      var $83 = HEAP[$res];
      HEAP[$83] = $81;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 27;
        break;
      } else {
        __label__ = 28;
        break;
      }
     case 27:
      
      
      
      
      var $92 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $93 = HEAP[$res];
      FUNCTION_TABLE[$92]($93);
      __label__ = 28;
      break;
     case 28:
      
      
      var $96 = HEAP[HEAP[$self_addr] + 20];
      var $97 = __PyObject_CallMethod_SizeT($96, __str77, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$posobj] = $97;
      
      
      if (HEAP[$posobj] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 29;
        break;
      }
     case 29:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 30;
        break;
      }
     case 30:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] == 0) {
        __label__ = 31;
        break;
      } else {
        __label__ = 35;
        break;
      }
     case 31:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 64] != 0) {
        __label__ = 32;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 32:
      
      
      var $114 = HEAP[HEAP[$self_addr] + 64];
      var $115 = _PyUnicodeUCS2_GetSize($114);
      
      if ($115 != 0) {
        __label__ = 33;
        break;
      } else {
        __label__ = 34;
        break;
      }
     case 33:
      ___assert_fail(__str89, __str15390, 2166, ___PRETTY_FUNCTION___11423);
      throw "Reached an unreachable!";
     case 34:
      var $117 = HEAP[$posobj];
      HEAP[$0] = $117;
      __label__ = 94;
      break;
     case 35:
      var $118 = HEAP[$posobj];
      var $119 = _PyLong_AsLongLong($118);
      
      HEAP[$cookie] = $119;
      var $121 = _PyErr_Occurred();
      
      if ($121 != 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 36;
        break;
      }
     case 36:
      
      
      var $125 = HEAP[HEAP[$self_addr] + 80];
      var $126 = $cookie + 8;
      var $127 = __PyArg_Parse_SizeT($125, __str90, allocate([ $126, 0, 0, 0, $next_input, 0, 0, 0 ], [ "i32*", 0, 0, 0, "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($127 == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 37;
        break;
      }
     case 37:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$next_input] + 4] + 84] & 134217728) == 0) {
        __label__ = 38;
        break;
      } else {
        __label__ = 39;
        break;
      }
     case 38:
      ___assert_fail(__str67443, __str15390, 2182, ___PRETTY_FUNCTION___11423);
      throw "Reached an unreachable!";
     case 39:
      
      
      
      
      
      
      
      var $143 = HEAP[$cookie] - HEAP[HEAP[$next_input] + 8];
      
      HEAP[$cookie] = $143;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 68] == 0) {
        __label__ = 40;
        break;
      } else {
        __label__ = 43;
        break;
      }
     case 40:
      
      
      
      var $152 = HEAP[HEAP[$posobj]] - 1;
      
      var $154 = HEAP[$posobj];
      HEAP[$154] = $152;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 41;
        break;
      } else {
        __label__ = 42;
        break;
      }
     case 41:
      
      
      
      
      var $163 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $164 = HEAP[$posobj];
      FUNCTION_TABLE[$163]($164);
      __label__ = 42;
      break;
     case 42:
      var $165 = _textiowrapper_build_cookie($cookie);
      HEAP[$0] = $165;
      __label__ = 94;
      break;
     case 43:
      
      
      var $168 = HEAP[HEAP[$self_addr] + 68];
      HEAP[$chars_to_skip] = $168;
      var $169 = HEAP[__PyIO_str_getstate];
      
      
      var $172 = HEAP[HEAP[$self_addr] + 32];
      var $173 = _PyObject_CallMethodObjArgs($172, $169, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$saved_state] = $173;
      
      
      if (HEAP[$saved_state] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 44;
        break;
      }
     case 44:
      var $176 = HEAP[$self_addr];
      var $177 = __textiowrapper_decoder_setstate($176, $cookie);
      
      if ($177 < 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 45;
        break;
      }
     case 45:
      HEAP[$chars_decoded] = 0;
      
      
      
      var $182 = HEAP[$next_input] + 20;
      HEAP[$input] = $182;
      
      
      
      
      
      var $188 = HEAP[$input] + HEAP[HEAP[$next_input] + 8];
      HEAP[$input_end] = $188;
      __label__ = 63;
      break;
     case 46:
      
      
      var $191 = HEAP[HEAP[$self_addr] + 32];
      var $192 = HEAP[$input];
      var $193 = __PyObject_CallMethod_SizeT($191, __str29404, __str91, allocate([ $192, 0, 0, 0, 1, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$decoded] = $193;
      
      
      if (HEAP[$decoded] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 47;
        break;
      }
     case 47:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$decoded] + 4] + 84] & 268435456) == 0) {
        __label__ = 48;
        break;
      } else {
        __label__ = 49;
        break;
      }
     case 48:
      ___assert_fail(__str92, __str15390, 2225, ___PRETTY_FUNCTION___11423);
      throw "Reached an unreachable!";
     case 49:
      
      
      
      
      
      var $208 = HEAP[HEAP[$decoded] + 8] + HEAP[$chars_decoded];
      HEAP[$chars_decoded] = $208;
      
      
      
      var $212 = HEAP[HEAP[$decoded]] - 1;
      
      var $214 = HEAP[$decoded];
      HEAP[$214] = $212;
      
      
      
      
      if (HEAP[HEAP[$decoded]] == 0) {
        __label__ = 50;
        break;
      } else {
        __label__ = 51;
        break;
      }
     case 50:
      
      
      
      
      var $223 = HEAP[HEAP[HEAP[$decoded] + 4] + 24];
      var $224 = HEAP[$decoded];
      FUNCTION_TABLE[$223]($224);
      __label__ = 51;
      break;
     case 51:
      
      
      var $227 = HEAP[$cookie + 12] + 1;
      
      HEAP[$cookie + 12] = $227;
      var $229 = HEAP[__PyIO_str_getstate];
      
      
      var $232 = HEAP[HEAP[$self_addr] + 32];
      var $233 = _PyObject_CallMethodObjArgs($232, $229, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$state] = $233;
      
      
      if (HEAP[$state] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 52;
        break;
      }
     case 52:
      var $236 = HEAP[$state];
      var $237 = __PyArg_Parse_SizeT($236, __str93, allocate([ $dec_buffer, 0, 0, 0, $dec_buffer_len, 0, 0, 0, $dec_flags, 0, 0, 0 ], [ "i8**", 0, 0, 0, "i32*", 0, 0, 0, "i32*", 0, 0, 0 ], ALLOC_STACK));
      
      if ($237 == 0) {
        __label__ = 53;
        break;
      } else {
        __label__ = 56;
        break;
      }
     case 53:
      
      
      
      var $242 = HEAP[HEAP[$state]] - 1;
      
      var $244 = HEAP[$state];
      HEAP[$244] = $242;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 54;
        break;
      } else {
        __label__ = 55;
        break;
      }
     case 54:
      
      
      
      
      var $253 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $254 = HEAP[$state];
      FUNCTION_TABLE[$253]($254);
      __label__ = 55;
      break;
     case 55:
      __label__ = 82;
      break;
     case 56:
      
      
      
      var $258 = HEAP[HEAP[$state]] - 1;
      
      var $260 = HEAP[$state];
      HEAP[$260] = $258;
      
      
      
      
      if (HEAP[HEAP[$state]] == 0) {
        __label__ = 57;
        break;
      } else {
        __label__ = 58;
        break;
      }
     case 57:
      
      
      
      
      var $269 = HEAP[HEAP[HEAP[$state] + 4] + 24];
      var $270 = HEAP[$state];
      FUNCTION_TABLE[$269]($270);
      __label__ = 58;
      break;
     case 58:
      
      
      if (HEAP[$dec_buffer_len] == 0) {
        __label__ = 59;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 59:
      
      
      
      if (HEAP[$chars_decoded] <= HEAP[$chars_to_skip]) {
        __label__ = 60;
        break;
      } else {
        __label__ = 61;
        break;
      }
     case 60:
      
      
      
      
      
      var $281 = HEAP[$cookie] + HEAP[$cookie + 12];
      
      HEAP[$cookie] = $281;
      
      
      var $285 = HEAP[$chars_to_skip] - HEAP[$chars_decoded];
      HEAP[$chars_to_skip] = $285;
      var $286 = HEAP[$dec_flags];
      
      HEAP[$cookie + 8] = $286;
      
      HEAP[$cookie + 12] = 0;
      HEAP[$chars_decoded] = 0;
      __label__ = 61;
      break;
     case 61:
      
      
      
      if (HEAP[$chars_decoded] >= HEAP[$chars_to_skip]) {
        __label__ = 64;
        break;
      } else {
        __label__ = 62;
        break;
      }
     case 62:
      
      var $293 = HEAP[$input] + 1;
      HEAP[$input] = $293;
      __label__ = 63;
      break;
     case 63:
      
      
      
      if (HEAP[$input] < HEAP[$input_end]) {
        __label__ = 46;
        break;
      } else {
        __label__ = 64;
        break;
      }
     case 64:
      
      
      
      if (HEAP[$input] == HEAP[$input_end]) {
        __label__ = 65;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 65:
      
      
      var $302 = HEAP[HEAP[$self_addr] + 32];
      var $303 = __PyObject_CallMethod_SizeT($302, __str29404, __str94, allocate([ __str20395, 0, 0, 0, 1, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$decoded65] = $303;
      
      
      if (HEAP[$decoded65] == 0) {
        __label__ = 82;
        break;
      } else {
        __label__ = 66;
        break;
      }
     case 66:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$decoded65] + 4] + 84] & 268435456) == 0) {
        __label__ = 67;
        break;
      } else {
        __label__ = 68;
        break;
      }
     case 67:
      ___assert_fail(__str92, __str15390, 2259, ___PRETTY_FUNCTION___11423);
      throw "Reached an unreachable!";
     case 68:
      
      
      
      
      
      var $318 = HEAP[HEAP[$decoded65] + 8] + HEAP[$chars_decoded];
      HEAP[$chars_decoded] = $318;
      
      
      
      var $322 = HEAP[HEAP[$decoded65]] - 1;
      
      var $324 = HEAP[$decoded65];
      HEAP[$324] = $322;
      
      
      
      
      if (HEAP[HEAP[$decoded65]] == 0) {
        __label__ = 69;
        break;
      } else {
        __label__ = 70;
        break;
      }
     case 69:
      
      
      
      
      var $333 = HEAP[HEAP[HEAP[$decoded65] + 4] + 24];
      var $334 = HEAP[$decoded65];
      FUNCTION_TABLE[$333]($334);
      __label__ = 70;
      break;
     case 70:
      
      HEAP[$cookie + 20] = 1;
      
      
      
      if (HEAP[$chars_decoded] < HEAP[$chars_to_skip]) {
        __label__ = 71;
        break;
      } else {
        __label__ = 72;
        break;
      }
     case 71:
      var $339 = HEAP[_PyExc_IOError];
      _PyErr_SetString($339, __str95);
      __label__ = 82;
      break;
     case 72:
      
      
      if (HEAP[$posobj] != 0) {
        __label__ = 73;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 73:
      
      
      
      var $345 = HEAP[HEAP[$posobj]] - 1;
      
      var $347 = HEAP[$posobj];
      HEAP[$347] = $345;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 74;
        break;
      } else {
        __label__ = 75;
        break;
      }
     case 74:
      
      
      
      
      var $356 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $357 = HEAP[$posobj];
      FUNCTION_TABLE[$356]($357);
      __label__ = 75;
      break;
     case 75:
      
      
      var $360 = HEAP[HEAP[$self_addr] + 32];
      var $361 = HEAP[$saved_state];
      var $362 = __PyObject_CallMethod_SizeT($360, __str22397, __str96, allocate([ $361, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $362;
      
      
      
      var $366 = HEAP[HEAP[$saved_state]] - 1;
      
      var $368 = HEAP[$saved_state];
      HEAP[$368] = $366;
      
      
      
      
      if (HEAP[HEAP[$saved_state]] == 0) {
        __label__ = 76;
        break;
      } else {
        __label__ = 77;
        break;
      }
     case 76:
      
      
      
      
      var $377 = HEAP[HEAP[HEAP[$saved_state] + 4] + 24];
      var $378 = HEAP[$saved_state];
      FUNCTION_TABLE[$377]($378);
      __label__ = 77;
      break;
     case 77:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 78;
        break;
      } else {
        __label__ = 79;
        break;
      }
     case 78:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 79:
      
      
      
      var $384 = HEAP[HEAP[$res]] - 1;
      
      var $386 = HEAP[$res];
      HEAP[$386] = $384;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 80;
        break;
      } else {
        __label__ = 81;
        break;
      }
     case 80:
      
      
      
      
      var $395 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $396 = HEAP[$res];
      FUNCTION_TABLE[$395]($396);
      __label__ = 81;
      break;
     case 81:
      
      var $398 = HEAP[$chars_to_skip];
      HEAP[$cookie + 16] = $398;
      var $399 = _textiowrapper_build_cookie($cookie);
      HEAP[$0] = $399;
      __label__ = 94;
      break;
     case 82:
      
      
      if (HEAP[$posobj] != 0) {
        __label__ = 83;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 83:
      
      
      
      var $405 = HEAP[HEAP[$posobj]] - 1;
      
      var $407 = HEAP[$posobj];
      HEAP[$407] = $405;
      
      
      
      
      if (HEAP[HEAP[$posobj]] == 0) {
        __label__ = 84;
        break;
      } else {
        __label__ = 85;
        break;
      }
     case 84:
      
      
      
      
      var $416 = HEAP[HEAP[HEAP[$posobj] + 4] + 24];
      var $417 = HEAP[$posobj];
      FUNCTION_TABLE[$416]($417);
      __label__ = 85;
      break;
     case 85:
      
      
      if (HEAP[$saved_state] != 0) {
        __label__ = 86;
        break;
      } else {
        __label__ = 93;
        break;
      }
     case 86:
      _PyErr_Fetch($type, $value, $traceback);
      
      
      var $422 = HEAP[HEAP[$self_addr] + 32];
      var $423 = HEAP[$saved_state];
      var $424 = __PyObject_CallMethod_SizeT($422, __str22397, __str96, allocate([ $423, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $424;
      
      
      
      var $428 = HEAP[HEAP[$saved_state]] - 1;
      
      var $430 = HEAP[$saved_state];
      HEAP[$430] = $428;
      
      
      
      
      if (HEAP[HEAP[$saved_state]] == 0) {
        __label__ = 87;
        break;
      } else {
        __label__ = 88;
        break;
      }
     case 87:
      
      
      
      
      var $439 = HEAP[HEAP[HEAP[$saved_state] + 4] + 24];
      var $440 = HEAP[$saved_state];
      FUNCTION_TABLE[$439]($440);
      __label__ = 88;
      break;
     case 88:
      
      
      if (HEAP[$res] == 0) {
        __label__ = 89;
        break;
      } else {
        __label__ = 90;
        break;
      }
     case 89:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 90:
      
      
      
      var $446 = HEAP[HEAP[$res]] - 1;
      
      var $448 = HEAP[$res];
      HEAP[$448] = $446;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 91;
        break;
      } else {
        __label__ = 92;
        break;
      }
     case 91:
      
      
      
      
      var $457 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $458 = HEAP[$res];
      FUNCTION_TABLE[$457]($458);
      __label__ = 92;
      break;
     case 92:
      var $459 = HEAP[$traceback];
      var $460 = HEAP[$value];
      var $461 = HEAP[$type];
      _PyErr_Restore($461, $460, $459);
      __label__ = 93;
      break;
     case 93:
      HEAP[$0] = 0;
      __label__ = 94;
      break;
     case 94:
      var $462 = HEAP[$0];
      HEAP[$retval] = $462;
      __label__ = 95;
      break;
     case 95:
      var $retval94 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval94;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_truncate($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $pos = __stackBase__ + 16;
      var $res = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      HEAP[$pos] = __Py_NoneStruct;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 5:
      var $11 = HEAP[$args_addr];
      var $12 = __PyArg_ParseTuple_SizeT($11, __str97, allocate([ $pos, 0, 0, 0 ], [ "%struct.PyObject**", 0, 0, 0 ], ALLOC_STACK));
      
      if ($12 == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 7:
      var $14 = HEAP[__PyIO_str_flush];
      
      var $16 = HEAP[$self_addr];
      var $17 = _PyObject_CallMethodObjArgs($16, $14, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$res] = $17;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 9:
      
      
      
      var $23 = HEAP[HEAP[$res]] - 1;
      
      var $25 = HEAP[$res];
      HEAP[$25] = $23;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $34 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $35 = HEAP[$res];
      FUNCTION_TABLE[$34]($35);
      __label__ = 11;
      break;
     case 11:
      var $36 = HEAP[$pos];
      var $37 = HEAP[__PyIO_str_truncate];
      
      
      var $40 = HEAP[HEAP[$self_addr] + 20];
      var $41 = _PyObject_CallMethodObjArgs($40, $37, allocate([ $36, 0, 0, 0, 0, 0, 0, 0 ], [ "%struct.PyObject*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$0] = $41;
      __label__ = 12;
      break;
     case 12:
      var $42 = HEAP[$0];
      HEAP[$retval] = $42;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_repr($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 28;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 28);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $nameobj = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $namerepr = __stackBase__ + 20;
      var $encrepr = __stackBase__ + 24;
      
      HEAP[$self_addr] = $self;
      HEAP[$namerepr] = 0;
      HEAP[$encrepr] = 0;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 5:
      
      var $12 = HEAP[$self_addr];
      var $13 = _PyObject_GetAttrString($12, __str53429);
      HEAP[$nameobj] = $13;
      
      
      if (HEAP[$nameobj] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $16 = HEAP[_PyExc_AttributeError];
      var $17 = _PyErr_ExceptionMatches($16);
      
      if ($17 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 7:
      _PyErr_Clear();
      
      
      var $21 = HEAP[HEAP[$self_addr] + 24];
      var $22 = _PyObject_Repr($21);
      HEAP[$encrepr] = $22;
      
      
      
      var $26 = HEAP[$encrepr] + 20;
      var $27 = _PyString_FromFormat(__str98, allocate([ $26, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $27;
      __label__ = 10;
      break;
     case 8:
      
      
      var $30 = HEAP[HEAP[$self_addr] + 24];
      var $31 = _PyObject_Repr($30);
      HEAP[$encrepr] = $31;
      var $32 = HEAP[$nameobj];
      var $33 = _PyObject_Repr($32);
      HEAP[$namerepr] = $33;
      
      
      
      var $37 = HEAP[$encrepr] + 20;
      
      
      
      var $41 = HEAP[$namerepr] + 20;
      var $42 = _PyString_FromFormat(__str99, allocate([ $41, 0, 0, 0, $37, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i8*", 0, 0, 0 ], ALLOC_STACK));
      HEAP[$res] = $42;
      
      
      
      var $46 = HEAP[HEAP[$nameobj]] - 1;
      
      var $48 = HEAP[$nameobj];
      HEAP[$48] = $46;
      
      
      
      
      if (HEAP[HEAP[$nameobj]] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      
      
      
      
      var $57 = HEAP[HEAP[HEAP[$nameobj] + 4] + 24];
      var $58 = HEAP[$nameobj];
      FUNCTION_TABLE[$57]($58);
      __label__ = 10;
      break;
     case 10:
      
      
      if (HEAP[$namerepr] != 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 11:
      
      
      
      var $64 = HEAP[HEAP[$namerepr]] - 1;
      
      var $66 = HEAP[$namerepr];
      HEAP[$66] = $64;
      
      
      
      
      if (HEAP[HEAP[$namerepr]] == 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      
      
      
      var $75 = HEAP[HEAP[HEAP[$namerepr] + 4] + 24];
      var $76 = HEAP[$namerepr];
      FUNCTION_TABLE[$75]($76);
      __label__ = 13;
      break;
     case 13:
      
      
      if (HEAP[$encrepr] != 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 14:
      
      
      
      var $82 = HEAP[HEAP[$encrepr]] - 1;
      
      var $84 = HEAP[$encrepr];
      HEAP[$84] = $82;
      
      
      
      
      if (HEAP[HEAP[$encrepr]] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      
      
      
      
      var $93 = HEAP[HEAP[HEAP[$encrepr] + 4] + 24];
      var $94 = HEAP[$encrepr];
      FUNCTION_TABLE[$93]($94);
      __label__ = 16;
      break;
     case 16:
      var $95 = HEAP[$res];
      HEAP[$0] = $95;
      __label__ = 24;
      break;
     case 17:
      
      
      if (HEAP[$namerepr] != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      
      var $101 = HEAP[HEAP[$namerepr]] - 1;
      
      var $103 = HEAP[$namerepr];
      HEAP[$103] = $101;
      
      
      
      
      if (HEAP[HEAP[$namerepr]] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $112 = HEAP[HEAP[HEAP[$namerepr] + 4] + 24];
      var $113 = HEAP[$namerepr];
      FUNCTION_TABLE[$112]($113);
      __label__ = 20;
      break;
     case 20:
      
      
      if (HEAP[$encrepr] != 0) {
        __label__ = 21;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 21:
      
      
      
      var $119 = HEAP[HEAP[$encrepr]] - 1;
      
      var $121 = HEAP[$encrepr];
      HEAP[$121] = $119;
      
      
      
      
      if (HEAP[HEAP[$encrepr]] == 0) {
        __label__ = 22;
        break;
      } else {
        __label__ = 23;
        break;
      }
     case 22:
      
      
      
      
      var $130 = HEAP[HEAP[HEAP[$encrepr] + 4] + 24];
      var $131 = HEAP[$encrepr];
      FUNCTION_TABLE[$130]($131);
      __label__ = 23;
      break;
     case 23:
      HEAP[$0] = 0;
      __label__ = 24;
      break;
     case 24:
      var $132 = HEAP[$0];
      HEAP[$retval] = $132;
      __label__ = 25;
      break;
     case 25:
      var $retval23 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval23;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_fileno($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = __PyObject_CallMethod_SizeT($13, __str100, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_seekable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = __PyObject_CallMethod_SizeT($13, __str55431, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_readable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = __PyObject_CallMethod_SizeT($13, __str50426, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_writable($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = __PyObject_CallMethod_SizeT($13, __str52428, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_isatty($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = __PyObject_CallMethod_SizeT($13, __str101, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_flush($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $r = __stackBase__ + 16;
      var $_res = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 5:
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 6:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 84] != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      
      
      var $22 = HEAP[HEAP[$self_addr] + 84];
      var $23 = __PyFileIO_closed($22);
      HEAP[$r] = $23;
      __label__ = 14;
      break;
     case 8:
      var $24 = HEAP[$self_addr];
      var $25 = _textiowrapper_closed_get($24, 0);
      HEAP[$_res] = $25;
      
      
      if (HEAP[$_res] == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 10:
      var $28 = HEAP[$_res];
      var $29 = _PyObject_IsTrue($28);
      HEAP[$r] = $29;
      
      
      
      var $33 = HEAP[HEAP[$_res]] - 1;
      
      var $35 = HEAP[$_res];
      HEAP[$35] = $33;
      
      
      
      
      if (HEAP[HEAP[$_res]] == 0) {
        __label__ = 11;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 11:
      
      
      
      
      var $44 = HEAP[HEAP[HEAP[$_res] + 4] + 24];
      var $45 = HEAP[$_res];
      FUNCTION_TABLE[$44]($45);
      __label__ = 12;
      break;
     case 12:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 14:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 16;
        break;
      }
     case 15:
      var $50 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($50, __str60436);
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 16:
      __label__ = 19;
      break;
     case 17:
      
      var $52 = HEAP[$self_addr];
      var $53 = __PyIOBase_check_closed($52, __Py_TrueStruct);
      
      if ($53 == 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 19;
        break;
      }
     case 18:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 19:
      
      
      var $57 = HEAP[HEAP[$self_addr] + 52];
      
      var $59 = HEAP[$self_addr] + 53;
      HEAP[$59] = $57;
      var $60 = HEAP[$self_addr];
      var $61 = __textiowrapper_writeflush($60);
      
      if ($61 < 0) {
        __label__ = 20;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 20:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 21:
      
      
      var $65 = HEAP[HEAP[$self_addr] + 20];
      var $66 = __PyObject_CallMethod_SizeT($65, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $66;
      __label__ = 22;
      break;
     case 22:
      var $67 = HEAP[$0];
      HEAP[$retval] = $67;
      __label__ = 23;
      break;
     case 23:
      var $retval22 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_close($self, $args) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $args_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      var $r = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$args_addr] = $args;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 5:
      var $11 = HEAP[$self_addr];
      var $12 = _textiowrapper_closed_get($11, 0);
      HEAP[$res] = $12;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 7:
      var $15 = HEAP[$res];
      var $16 = _PyObject_IsTrue($15);
      HEAP[$r] = $16;
      
      
      
      var $20 = HEAP[HEAP[$res]] - 1;
      
      var $22 = HEAP[$res];
      HEAP[$22] = $20;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 9;
        break;
      }
     case 8:
      
      
      
      
      var $31 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $32 = HEAP[$res];
      FUNCTION_TABLE[$31]($32);
      __label__ = 9;
      break;
     case 9:
      
      
      if (HEAP[$r] < 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 11:
      
      
      if (HEAP[$r] > 0) {
        __label__ = 12;
        break;
      } else {
        __label__ = 13;
        break;
      }
     case 12:
      
      var $38 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $38;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 18;
      break;
     case 13:
      
      var $40 = HEAP[$self_addr];
      var $41 = __PyObject_CallMethod_SizeT($40, __str79, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$res] = $41;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 14;
        break;
      } else {
        __label__ = 15;
        break;
      }
     case 14:
      HEAP[$0] = 0;
      __label__ = 18;
      break;
     case 15:
      
      
      
      var $47 = HEAP[HEAP[$res]] - 1;
      
      var $49 = HEAP[$res];
      HEAP[$49] = $47;
      
      
      
      
      if (HEAP[HEAP[$res]] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $58 = HEAP[HEAP[HEAP[$res] + 4] + 24];
      var $59 = HEAP[$res];
      FUNCTION_TABLE[$58]($59);
      __label__ = 17;
      break;
     case 17:
      
      
      var $62 = HEAP[HEAP[$self_addr] + 20];
      var $63 = __PyObject_CallMethod_SizeT($62, __str102, 0, allocate(1, "i32", ALLOC_STACK));
      HEAP[$0] = $63;
      __label__ = 18;
      break;
     case 18:
      var $64 = HEAP[$0];
      HEAP[$retval] = $64;
      __label__ = 19;
      break;
     case 19:
      var $retval18 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval18;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_iternext($self) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $retval = __stackBase__ + 4;
      var $0 = __stackBase__ + 8;
      var $line = __stackBase__ + 12;
      var $_py_tmp = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 5:
      
      var $12 = HEAP[$self_addr] + 53;
      HEAP[$12] = 0;
      
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 4] == _PyTextIOWrapper_Type) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      var $18 = HEAP[$self_addr];
      var $19 = __textiowrapper_readline($18, -1);
      HEAP[$line] = $19;
      __label__ = 12;
      break;
     case 7:
      var $20 = HEAP[__PyIO_str_readline];
      
      var $22 = HEAP[$self_addr];
      var $23 = _PyObject_CallMethodObjArgs($22, $20, allocate(4, "i8*", ALLOC_STACK));
      HEAP[$line] = $23;
      
      
      if (HEAP[$line] != 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 8:
      
      
      
      
      
      
      
      if ((HEAP[HEAP[HEAP[$line] + 4] + 84] & 268435456) == 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 12;
        break;
      }
     case 9:
      
      
      
      
      var $37 = HEAP[HEAP[HEAP[$line] + 4] + 12];
      var $38 = HEAP[_PyExc_IOError];
      var $39 = _PyErr_Format($38, __str103, allocate([ $37, 0, 0, 0 ], [ "i8*", 0, 0, 0 ], ALLOC_STACK));
      
      
      
      var $43 = HEAP[HEAP[$line]] - 1;
      
      var $45 = HEAP[$line];
      HEAP[$45] = $43;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 10;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 10:
      
      
      
      
      var $54 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $55 = HEAP[$line];
      FUNCTION_TABLE[$54]($55);
      __label__ = 11;
      break;
     case 11:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 12:
      
      
      if (HEAP[$line] == 0) {
        __label__ = 13;
        break;
      } else {
        __label__ = 14;
        break;
      }
     case 13:
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 14:
      
      
      
      
      
      if (HEAP[HEAP[$line] + 8] == 0) {
        __label__ = 15;
        break;
      } else {
        __label__ = 21;
        break;
      }
     case 15:
      
      
      
      var $66 = HEAP[HEAP[$line]] - 1;
      
      var $68 = HEAP[$line];
      HEAP[$68] = $66;
      
      
      
      
      if (HEAP[HEAP[$line]] == 0) {
        __label__ = 16;
        break;
      } else {
        __label__ = 17;
        break;
      }
     case 16:
      
      
      
      
      var $77 = HEAP[HEAP[HEAP[$line] + 4] + 24];
      var $78 = HEAP[$line];
      FUNCTION_TABLE[$77]($78);
      __label__ = 17;
      break;
     case 17:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 80] != 0) {
        __label__ = 18;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 18:
      
      
      var $85 = HEAP[HEAP[$self_addr] + 80];
      HEAP[$_py_tmp] = $85;
      
      var $87 = HEAP[$self_addr] + 80;
      HEAP[$87] = 0;
      
      
      
      var $91 = HEAP[HEAP[$_py_tmp]] - 1;
      
      var $93 = HEAP[$_py_tmp];
      HEAP[$93] = $91;
      
      
      
      
      if (HEAP[HEAP[$_py_tmp]] == 0) {
        __label__ = 19;
        break;
      } else {
        __label__ = 20;
        break;
      }
     case 19:
      
      
      
      
      var $102 = HEAP[HEAP[HEAP[$_py_tmp] + 4] + 24];
      var $103 = HEAP[$_py_tmp];
      FUNCTION_TABLE[$102]($103);
      __label__ = 20;
      break;
     case 20:
      
      
      var $106 = HEAP[HEAP[$self_addr] + 52];
      
      var $108 = HEAP[$self_addr] + 53;
      HEAP[$108] = $106;
      HEAP[$0] = 0;
      __label__ = 22;
      break;
     case 21:
      var $109 = HEAP[$line];
      HEAP[$0] = $109;
      __label__ = 22;
      break;
     case 22:
      var $110 = HEAP[$0];
      HEAP[$retval] = $110;
      __label__ = 23;
      break;
     case 23:
      var $retval22 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval22;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_name_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 20];
      var $14 = _PyObject_GetAttrString($13, __str53429);
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_closed_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      var $11 = HEAP[__PyIO_str_closed];
      
      
      var $14 = HEAP[HEAP[$self_addr] + 20];
      var $15 = _PyObject_GetAttr($14, $11);
      HEAP[$0] = $15;
      __label__ = 6;
      break;
     case 6:
      var $16 = HEAP[$0];
      HEAP[$retval] = $16;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_newlines_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 20;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 20);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      var $res = __stackBase__ + 16;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 5:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 32] == 0) {
        __label__ = 6;
        break;
      } else {
        __label__ = 7;
        break;
      }
     case 6:
      
      var $16 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $16;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 7:
      var $17 = HEAP[__PyIO_str_newlines];
      
      
      var $20 = HEAP[HEAP[$self_addr] + 32];
      var $21 = _PyObject_GetAttr($20, $17);
      HEAP[$res] = $21;
      
      
      if (HEAP[$res] == 0) {
        __label__ = 8;
        break;
      } else {
        __label__ = 11;
        break;
      }
     case 8:
      var $24 = HEAP[_PyExc_AttributeError];
      var $25 = _PyErr_ExceptionMatches($24);
      
      if ($25 != 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      _PyErr_Clear();
      
      var $28 = HEAP[__Py_NoneStruct] + 1;
      HEAP[__Py_NoneStruct] = $28;
      HEAP[$0] = __Py_NoneStruct;
      __label__ = 12;
      break;
     case 10:
      HEAP[$0] = 0;
      __label__ = 12;
      break;
     case 11:
      var $29 = HEAP[$res];
      HEAP[$0] = $29;
      __label__ = 12;
      break;
     case 12:
      var $30 = HEAP[$0];
      HEAP[$retval] = $30;
      __label__ = 13;
      break;
     case 13:
      var $retval12 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval12;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_errors_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      
      
      
      var $16 = HEAP[HEAP[HEAP[$self_addr] + 40]] + 1;
      var $17 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$17] = $16;
      
      
      var $20 = HEAP[HEAP[$self_addr] + 40];
      HEAP[$0] = $20;
      __label__ = 6;
      break;
     case 6:
      var $21 = HEAP[$0];
      HEAP[$retval] = $21;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_chunk_size_get($self, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 16;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 16);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $context_addr = __stackBase__ + 4;
      var $retval = __stackBase__ + 8;
      var $0 = __stackBase__ + 12;
      
      HEAP[$self_addr] = $self;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = 0;
      __label__ = 6;
      break;
     case 5:
      
      
      var $13 = HEAP[HEAP[$self_addr] + 16];
      var $14 = _PyLong_FromSsize_t($13);
      HEAP[$0] = $14;
      __label__ = 6;
      break;
     case 6:
      var $15 = HEAP[$0];
      HEAP[$retval] = $15;
      __label__ = 7;
      break;
     case 7:
      var $retval6 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval6;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  function _textiowrapper_chunk_size_set($self, $arg, $context) {
    var __stackBase__ = STACKTOP;
    STACKTOP += 24;
    assert(STACKTOP < STACK_MAX);
    _memset(__stackBase__, 0, 24);
    var __label__;
    __label__ = -1;
    while (1) switch (__label__) {
     case -1:
      var $self_addr = __stackBase__;
      var $arg_addr = __stackBase__ + 4;
      var $context_addr = __stackBase__ + 8;
      var $retval = __stackBase__ + 12;
      var $0 = __stackBase__ + 16;
      var $n = __stackBase__ + 20;
      
      HEAP[$self_addr] = $self;
      HEAP[$arg_addr] = $arg;
      HEAP[$context_addr] = $context;
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 8] <= 0) {
        __label__ = 1;
        break;
      } else {
        __label__ = 5;
        break;
      }
     case 1:
      
      
      
      
      if (HEAP[HEAP[$self_addr] + 12] != 0) {
        __label__ = 2;
        break;
      } else {
        __label__ = 3;
        break;
      }
     case 2:
      var $9 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($9, __str57433);
      __label__ = 4;
      break;
     case 3:
      var $10 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($10, __str58434);
      __label__ = 4;
      break;
     case 4:
      HEAP[$0] = -1;
      __label__ = 11;
      break;
     case 5:
      var $11 = HEAP[_PyExc_TypeError];
      var $12 = HEAP[$arg_addr];
      var $13 = _PyNumber_AsSsize_t($12, $11);
      HEAP[$n] = $13;
      
      var $15 = HEAP[$n] == -1;
      if ($15) {
        __label__ = 6;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 6:
      var $16 = _PyErr_Occurred();
      
      if ($16 != 0) {
        __label__ = 7;
        break;
      } else {
        __label__ = 8;
        break;
      }
     case 7:
      HEAP[$0] = -1;
      __label__ = 11;
      break;
     case 8:
      
      
      if (HEAP[$n] <= 0) {
        __label__ = 9;
        break;
      } else {
        __label__ = 10;
        break;
      }
     case 9:
      var $20 = HEAP[_PyExc_ValueError];
      _PyErr_SetString($20, __str104);
      HEAP[$0] = -1;
      __label__ = 11;
      break;
     case 10:
      
      var $22 = HEAP[$self_addr] + 16;
      var $23 = HEAP[$n];
      HEAP[$22] = $23;
      HEAP[$0] = 0;
      __label__ = 11;
      break;
     case 11:
      var $24 = HEAP[$0];
      HEAP[$retval] = $24;
      __label__ = 12;
      break;
     case 12:
      var $retval11 = HEAP[$retval];
      STACKTOP = __stackBase__;
      return $retval11;
     default:
      assert(0, "bad label: " + __label__);
    }
  }
  FUNCTION_TABLE = FUNCTION_TABLE.concat([ 0, 0, __PyIO_ConvertSsize_t, 0, _bufferediobase_detach, 0, _bufferediobase_read, 0, _bufferediobase_read1, 0, _bufferediobase_readinto, 0, _bufferediobase_write, 0, _buffered_detach, 0, _buffered_simple_flush, 0, _buffered_close, 0, _buffered_seekable, 0, _buffered_readable, 0, _buffered_writable, 0, _buffered_fileno, 0, _buffered_isatty, 0, _buffered_read, 0, _buffered_peek, 0, _buffered_read1, 0, _buffered_readline, 0, _buffered_seek, 0, _buffered_tell, 0, _buffered_truncate, 0, _buffered_closed_get, 0, _buffered_name_get, 0, _buffered_mode_get, 0, _buffered_dealloc, 0, _buffered_repr, 0, _buffered_traverse, 0, _buffered_clear, 0, _buffered_iternext, 0, _bufferedreader_init, 0, _PyType_GenericNew, 0, _bufferedwriter_write, 0, _buffered_flush, 0, _bufferedwriter_init, 0, _bufferedrwpair_read, 0, _bufferedrwpair_peek, 0, _bufferedrwpair_read1, 0, _bufferedrwpair_readinto, 0, _bufferedrwpair_write, 0, _bufferedrwpair_flush, 0, _bufferedrwpair_readable, 0, _bufferedrwpair_writable, 0, _bufferedrwpair_close, 0, _bufferedrwpair_isatty, 0, _bufferedrwpair_closed_get, 0, _bufferedrwpair_dealloc, 0, _bufferedrwpair_traverse, 0, _bufferedrwpair_clear, 0, _bufferedrwpair_init, 0, _buffered_readinto, 0, _bufferedrandom_init, 0, _bytesio_get_closed, 0, _return_true, 0, _bytesio_close, 0, _bytesio_flush, 0, _bytesio_isatty, 0, _bytesio_tell, 0, _bytesio_write, 0, _bytesio_writelines, 0, _bytesio_read1, 0, _bytesio_readinto, 0, _bytesio_readline, 0, _bytesio_readlines, 0, _bytesio_read, 0, _bytesio_getvalue, 0, _bytesio_seek, 0, _bytesio_truncate, 0, _bytesio_getstate, 0, _bytesio_setstate, 0, _bytesio_dealloc, 0, _bytesio_traverse, 0, _bytesio_clear, 0, _PyObject_SelfIter, 0, _bytesio_iternext, 0, _bytesio_init, 0, _bytesio_new, 0, _fileio_read, 0, _fileio_readall, 0, _fileio_readinto, 0, _fileio_write, 0, _fileio_seek, 0, _fileio_tell, 0, _fileio_truncate, 0, _fileio_close, 0, _fileio_seekable, 0, _fileio_readable, 0, _fileio_writable, 0, _fileio_fileno, 0, _fileio_isatty, 0, _get_closed, 0, _get_closefd, 0, _get_mode, 0, _fileio_dealloc, 0, _fileio_repr, 0, _PyObject_GenericGetAttr, 0, _fileio_traverse, 0, _fileio_clear, 0, _fileio_init, 0, _PyType_GenericAlloc, 0, _fileio_new, 0, _PyObject_GC_Del, 0, _iobase_seek, 0, _iobase_tell, 0, _iobase_truncate, 0, _iobase_flush, 0, _iobase_close, 0, _iobase_seekable, 0, _iobase_readable, 0, _iobase_writable, 0, __PyIOBase_check_closed, 0, __PyIOBase_check_seekable, 0, __PyIOBase_check_readable, 0, __PyIOBase_check_writable, 0, _iobase_fileno, 0, _iobase_isatty, 0, _iobase_enter, 0, _iobase_exit, 0, _iobase_readline, 0, _iobase_readlines, 0, _iobase_writelines, 0, _iobase_closed_get, 0, _iobase_dealloc, 0, _iobase_traverse, 0, _iobase_clear, 0, _iobase_iter, 0, _iobase_iternext, 0, _rawiobase_read, 0, _rawiobase_readall, 0, _blockingioerror_init, 0, _io_open, 0, _stringio_close, 0, _stringio_getvalue, 0, _stringio_read, 0, _stringio_readline, 0, _stringio_tell, 0, _stringio_truncate, 0, _stringio_seek, 0, _stringio_write, 0, _stringio_seekable, 0, _stringio_readable, 0, _stringio_writable, 0, _stringio_getstate, 0, _stringio_setstate, 0, _stringio_closed, 0, _stringio_newlines, 0, _stringio_line_buffering, 0, _stringio_dealloc, 0, _stringio_traverse, 0, _stringio_clear, 0, _stringio_iternext, 0, _stringio_init, 0, _stringio_new, 0, _textiobase_detach, 0, _textiobase_read, 0, _textiobase_readline, 0, _textiobase_write, 0, _textiobase_encoding_get, 0, _textiobase_newlines_get, 0, _textiobase_errors_get, 0, _incrementalnewlinedecoder_decode, 0, _incrementalnewlinedecoder_getstate, 0, _incrementalnewlinedecoder_setstate, 0, _incrementalnewlinedecoder_reset, 0, _incrementalnewlinedecoder_newlines_get, 0, _incrementalnewlinedecoder_dealloc, 0, _incrementalnewlinedecoder_init, 0, _ascii_encode, 0, _latin1_encode, 0, _utf8_encode, 0, _utf16be_encode, 0, _utf16le_encode, 0, _utf16_encode, 0, _utf32be_encode, 0, _utf32le_encode, 0, _utf32_encode, 0, _textiowrapper_detach, 0, _textiowrapper_write, 0, _textiowrapper_read, 0, _textiowrapper_readline, 0, _textiowrapper_flush, 0, _textiowrapper_close, 0, _textiowrapper_fileno, 0, _textiowrapper_seekable, 0, _textiowrapper_readable, 0, _textiowrapper_writable, 0, _textiowrapper_isatty, 0, _textiowrapper_seek, 0, _textiowrapper_tell, 0, _textiowrapper_truncate, 0, _textiowrapper_name_get, 0, _textiowrapper_closed_get, 0, _textiowrapper_newlines_get, 0, _textiowrapper_errors_get, 0, _textiowrapper_chunk_size_get, 0, _textiowrapper_chunk_size_set, 0, _textiowrapper_dealloc, 0, _textiowrapper_repr, 0, _textiowrapper_traverse, 0, _textiowrapper_clear, 0, _textiowrapper_iternext, 0, _textiowrapper_init, 0 ]);
  function run(args) {
    _bufferediobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 115, 46, 10, 10, 84, 104, 101, 32, 109, 97, 105, 110, 32, 100, 105, 102, 102, 101, 114, 101, 110, 99, 101, 32, 119, 105, 116, 104, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 105, 115, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 114, 101, 97, 100, 40, 41, 32, 109, 101, 116, 104, 111, 100, 10, 115, 117, 112, 112, 111, 114, 116, 115, 32, 111, 109, 105, 116, 116, 105, 110, 103, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 44, 32, 97, 110, 100, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 104, 97, 118, 101, 32, 97, 32, 100, 101, 102, 97, 117, 108, 116, 10, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 116, 104, 97, 116, 32, 100, 101, 102, 101, 114, 115, 32, 116, 111, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 46, 10, 10, 73, 110, 32, 97, 100, 100, 105, 116, 105, 111, 110, 44, 32, 114, 101, 97, 100, 40, 41, 44, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 40, 41, 32, 109, 97, 121, 32, 114, 97, 105, 115, 101, 10, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 105, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 10, 109, 111, 100, 101, 32, 97, 110, 100, 32, 110, 111, 116, 32, 114, 101, 97, 100, 121, 59, 32, 117, 110, 108, 105, 107, 101, 32, 116, 104, 101, 105, 114, 32, 114, 97, 119, 32, 99, 111, 117, 110, 116, 101, 114, 112, 97, 114, 116, 115, 44, 32, 116, 104, 101, 121, 32, 119, 105, 108, 108, 32, 110, 101, 118, 101, 114, 10, 114, 101, 116, 117, 114, 110, 32, 78, 111, 110, 101, 46, 10, 10, 65, 32, 116, 121, 112, 105, 99, 97, 108, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 115, 104, 111, 117, 108, 100, 32, 110, 111, 116, 32, 105, 110, 104, 101, 114, 105, 116, 32, 102, 114, 111, 109, 32, 97, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 10, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 44, 32, 98, 117, 116, 32, 119, 114, 97, 112, 32, 111, 110, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str = allocate([ 119, 42, 58, 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __str1 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str2 = allocate([ 110, 0 ], "i8", ALLOC_NORMAL);
    __str3 = allocate([ 114, 101, 97, 100, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 114, 101, 116, 117, 114, 110, 32, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_detach_doc = allocate([ 68, 105, 115, 99, 111, 110, 110, 101, 99, 116, 32, 116, 104, 105, 115, 32, 98, 117, 102, 102, 101, 114, 32, 102, 114, 111, 109, 32, 105, 116, 115, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 105, 116, 46, 10, 10, 65, 102, 116, 101, 114, 32, 116, 104, 101, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 44, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 105, 115, 32, 105, 110, 32, 97, 110, 32, 117, 110, 117, 115, 97, 98, 108, 101, 10, 115, 116, 97, 116, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str4 = allocate([ 100, 101, 116, 97, 99, 104, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 117, 112, 32, 116, 111, 32, 110, 32, 98, 121, 116, 101, 115, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 78, 111, 110, 101, 44, 32, 111, 114, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 114, 101, 97, 100, 115, 32, 97, 110, 100, 10, 114, 101, 116, 117, 114, 110, 115, 32, 97, 108, 108, 32, 100, 97, 116, 97, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 112, 111, 115, 105, 116, 105, 118, 101, 44, 32, 97, 110, 100, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 10, 110, 111, 116, 32, 39, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 39, 44, 32, 109, 117, 108, 116, 105, 112, 108, 101, 32, 114, 97, 119, 32, 114, 101, 97, 100, 115, 32, 109, 97, 121, 32, 98, 101, 32, 105, 115, 115, 117, 101, 100, 32, 116, 111, 32, 115, 97, 116, 105, 115, 102, 121, 10, 116, 104, 101, 32, 98, 121, 116, 101, 32, 99, 111, 117, 110, 116, 32, 40, 117, 110, 108, 101, 115, 115, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 32, 102, 105, 114, 115, 116, 41, 46, 32, 32, 66, 117, 116, 32, 102, 111, 114, 10, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 115, 32, 40, 97, 115, 32, 119, 101, 108, 108, 32, 97, 115, 32, 115, 111, 99, 107, 101, 116, 115, 32, 97, 110, 100, 32, 112, 105, 112, 101, 115, 41, 44, 32, 97, 116, 32, 109, 111, 115, 116, 10, 111, 110, 101, 32, 114, 97, 119, 32, 114, 101, 97, 100, 32, 119, 105, 108, 108, 32, 98, 101, 32, 105, 115, 115, 117, 101, 100, 44, 32, 97, 110, 100, 32, 97, 32, 115, 104, 111, 114, 116, 32, 114, 101, 115, 117, 108, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 121, 10, 116, 104, 97, 116, 32, 69, 79, 70, 32, 105, 115, 32, 105, 109, 109, 105, 110, 101, 110, 116, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 32, 111, 110, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 78, 111, 110, 101, 32, 105, 102, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 119, 97, 115, 32, 111, 112, 101, 110, 32, 105, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 10, 109, 111, 100, 101, 32, 97, 110, 100, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 32, 97, 116, 32, 116, 104, 101, 32, 109, 111, 109, 101, 110, 116, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_read1_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 117, 112, 32, 116, 111, 32, 110, 32, 98, 121, 116, 101, 115, 44, 32, 119, 105, 116, 104, 32, 97, 116, 32, 109, 111, 115, 116, 32, 111, 110, 101, 32, 114, 101, 97, 100, 40, 41, 32, 99, 97, 108, 108, 10, 116, 111, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 46, 32, 65, 32, 115, 104, 111, 114, 116, 32, 114, 101, 115, 117, 108, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 121, 10, 116, 104, 97, 116, 32, 69, 79, 70, 32, 105, 115, 32, 105, 109, 109, 105, 110, 101, 110, 116, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 32, 111, 110, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str5 = allocate([ 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 98, 117, 102, 102, 101, 114, 32, 116, 111, 32, 116, 104, 101, 32, 73, 79, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 119, 114, 105, 116, 116, 101, 110, 44, 32, 119, 104, 105, 99, 104, 32, 105, 115, 32, 110, 101, 118, 101, 114, 32, 108, 101, 115, 115, 32, 116, 104, 97, 110, 10, 108, 101, 110, 40, 98, 41, 46, 10, 10, 82, 97, 105, 115, 101, 115, 32, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 105, 115, 32, 102, 117, 108, 108, 32, 97, 110, 100, 32, 116, 104, 101, 10, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 99, 97, 110, 110, 111, 116, 32, 97, 99, 99, 101, 112, 116, 32, 109, 111, 114, 101, 32, 100, 97, 116, 97, 32, 97, 116, 32, 116, 104, 101, 32, 109, 111, 109, 101, 110, 116, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str6 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str7 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    _bufferediobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str8 = allocate([ 95, 105, 111, 46, 95, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str9 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str10 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 98, 117, 102, 102, 101, 114, 101, 100, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8511 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str11 = allocate([ 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str12 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 117, 110, 105, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 32, 111, 98, 106, 101, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str13 = allocate([ 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str14 = allocate([ 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str15 = allocate([ 82, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 108, 108, 100, 0 ], "i8", ALLOC_NORMAL);
    __str16 = allocate([ 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 115, 116, 114, 105, 99, 116, 108, 121, 32, 112, 111, 115, 105, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    _eintr_int_9041 = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str17 = allocate([ 101, 105, 110, 116, 114, 95, 105, 110, 116, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9046 = allocate([ 95, 116, 114, 97, 112, 95, 101, 105, 110, 116, 114, 0 ], "i8", ALLOC_NORMAL);
    __str18 = allocate([ 101, 110, 118, 95, 101, 114, 114, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str19 = allocate([ 102, 108, 117, 115, 104, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str20 = allocate([ 124, 110, 58, 112, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str21 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str22 = allocate([ 114, 101, 97, 100, 32, 108, 101, 110, 103, 116, 104, 32, 109, 117, 115, 116, 32, 98, 101, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 111, 114, 32, 45, 49, 0 ], "i8", ALLOC_NORMAL);
    __str23 = allocate([ 114, 101, 97, 100, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str24 = allocate([ 110, 58, 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    __str25 = allocate([ 114, 101, 97, 100, 32, 108, 101, 110, 103, 116, 104, 32, 109, 117, 115, 116, 32, 98, 101, 32, 112, 111, 115, 105, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str26 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str28 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str29 = allocate([ 119, 104, 101, 110, 99, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 50, 44, 32, 110, 111, 116, 32, 37, 100, 0 ], "i8", ALLOC_NORMAL);
    __str30 = allocate([ 115, 101, 101, 107, 32, 111, 102, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str33 = allocate([ 60, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str34 = allocate([ 60, 37, 115, 32, 110, 97, 109, 101, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_doc = allocate([ 67, 114, 101, 97, 116, 101, 32, 97, 32, 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 117, 115, 105, 110, 103, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 114, 101, 97, 100, 97, 98, 108, 101, 32, 114, 97, 119, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    _C_170_9977 = allocate(12, "i8*", ALLOC_NORMAL);
    __str35 = allocate([ 114, 97, 119, 0 ], "i8", ALLOC_NORMAL);
    __str36 = allocate([ 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37 = allocate([ 79, 124, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str38 = allocate([ 114, 97, 119, 32, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 108, 101, 110, 103, 116, 104, 32, 37, 122, 100, 32, 40, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 98, 101, 101, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 37, 122, 100, 41, 0 ], "i8", ALLOC_NORMAL);
    __str39 = allocate([ 114, 101, 109, 97, 105, 110, 105, 110, 103, 32, 60, 61, 32, 115, 101, 108, 102, 45, 62, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10317 = allocate([ 95, 98, 117, 102, 102, 101, 114, 101, 100, 114, 101, 97, 100, 101, 114, 95, 114, 101, 97, 100, 95, 103, 101, 110, 101, 114, 105, 99, 0 ], "i8", ALLOC_NORMAL);
    __str40 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str41 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str43 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str46 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str47 = allocate([ 112, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str48 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str49 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str50 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str51 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedreader_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str52 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _bufferedreader_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str53 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedReader_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str54 = allocate([ 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 100, 101, 112, 114, 101, 99, 97, 116, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _bufferedwriter_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 32, 102, 111, 114, 32, 97, 32, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 115, 101, 113, 117, 101, 110, 116, 105, 97, 108, 32, 82, 97, 119, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 10, 10, 84, 104, 101, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 32, 99, 114, 101, 97, 116, 101, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 32, 102, 111, 114, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 114, 97, 119, 10, 115, 116, 114, 101, 97, 109, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 110, 111, 116, 32, 103, 105, 118, 101, 110, 44, 32, 105, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 32, 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 110, 39, 116, 32, 117, 115, 101, 100, 32, 97, 110, 121, 109, 111, 114, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _C_210_10512 = allocate(16, "i8*", ALLOC_NORMAL);
    __str55 = allocate([ 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str56 = allocate([ 79, 124, 110, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str57 = allocate([ 114, 97, 119, 32, 119, 114, 105, 116, 101, 40, 41, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 118, 97, 108, 105, 100, 32, 108, 101, 110, 103, 116, 104, 32, 37, 122, 100, 32, 40, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 98, 101, 101, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 48, 32, 97, 110, 100, 32, 37, 122, 100, 41, 0 ], "i8", ALLOC_NORMAL);
    __str58 = allocate([ 115, 42, 58, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str59 = allocate([ 119, 114, 105, 116, 101, 32, 116, 111, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str60 = allocate([ 40, 115, 101, 108, 102, 45, 62, 119, 114, 105, 116, 97, 98, 108, 101, 32, 38, 38, 32, 115, 101, 108, 102, 45, 62, 119, 114, 105, 116, 101, 95, 101, 110, 100, 32, 33, 61, 32, 45, 49, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10710 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 119, 114, 105, 116, 101, 114, 95, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _bufferedwriter_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedwriter_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedwriter_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str61 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedWriter_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrwpair_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 116, 111, 103, 101, 116, 104, 101, 114, 46, 10, 10, 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 101, 97, 100, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 97, 110, 100, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 119, 114, 105, 116, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 112, 117, 116, 32, 116, 111, 103, 101, 116, 104, 101, 114, 32, 116, 111, 10, 102, 111, 114, 109, 32, 97, 32, 115, 101, 113, 117, 101, 110, 116, 105, 97, 108, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 32, 116, 104, 97, 116, 32, 99, 97, 110, 32, 114, 101, 97, 100, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 46, 32, 84, 104, 105, 115, 32, 105, 115, 32, 116, 121, 112, 105, 99, 97, 108, 108, 121, 10, 117, 115, 101, 100, 32, 119, 105, 116, 104, 32, 97, 32, 115, 111, 99, 107, 101, 116, 32, 111, 114, 32, 116, 119, 111, 45, 119, 97, 121, 32, 112, 105, 112, 101, 46, 10, 10, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 97, 114, 101, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 115, 32, 116, 104, 97, 116, 32, 97, 114, 101, 32, 114, 101, 97, 100, 97, 98, 108, 101, 32, 97, 110, 100, 10, 119, 114, 105, 116, 101, 97, 98, 108, 101, 32, 114, 101, 115, 112, 101, 99, 116, 105, 118, 101, 108, 121, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 32, 105, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str62 = allocate([ 79, 79, 124, 110, 110, 58, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    __str63 = allocate([ 79, 110, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11077 = allocate([ 98, 117, 102, 102, 101, 114, 101, 100, 114, 119, 112, 97, 105, 114, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    _bufferedrwpair_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrwpair_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str64 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedRWPair_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_doc = allocate([ 65, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 32, 115, 116, 114, 101, 97, 109, 115, 46, 10, 10, 84, 104, 101, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 32, 99, 114, 101, 97, 116, 101, 115, 32, 97, 32, 114, 101, 97, 100, 101, 114, 32, 97, 110, 100, 32, 119, 114, 105, 116, 101, 114, 32, 102, 111, 114, 32, 97, 32, 115, 101, 101, 107, 97, 98, 108, 101, 32, 115, 116, 114, 101, 97, 109, 44, 10, 114, 97, 119, 44, 32, 103, 105, 118, 101, 110, 32, 105, 110, 32, 116, 104, 101, 32, 102, 105, 114, 115, 116, 32, 97, 114, 103, 117, 109, 101, 110, 116, 46, 32, 73, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 32, 111, 109, 105, 116, 116, 101, 100, 32, 105, 116, 10, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 46, 32, 109, 97, 120, 95, 98, 117, 102, 102, 101, 114, 95, 115, 105, 122, 101, 32, 105, 115, 110, 39, 116, 32, 117, 115, 101, 100, 32, 97, 110, 121, 109, 111, 114, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _C_248_11275 = allocate(16, "i8*", ALLOC_NORMAL);
    _bufferedrandom_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bufferedrandom_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str65 = allocate([ 95, 105, 111, 46, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 0 ], "i8", ALLOC_NORMAL);
    _PyBufferedRandom_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str66 = allocate([ 115, 101, 108, 102, 45, 62, 98, 117, 102, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str167 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 98, 121, 116, 101, 115, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8386 = allocate([ 103, 101, 116, 95, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str268 = allocate([ 108, 101, 110, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str369 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 60, 32, 40, 40, 80, 121, 95, 115, 115, 105, 122, 101, 95, 116, 41, 40, 40, 40, 115, 105, 122, 101, 95, 116, 41, 45, 49, 41, 62, 62, 49, 41, 41, 32, 45, 32, 108, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8425 = allocate([ 114, 101, 115, 105, 122, 101, 95, 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str470 = allocate([ 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8462 = allocate([ 119, 114, 105, 116, 101, 95, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str571 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    _flush_doc = allocate([ 102, 108, 117, 115, 104, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 68, 111, 101, 115, 32, 110, 111, 116, 104, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    __str672 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _getval_doc = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 40, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 10, 10, 82, 101, 116, 114, 105, 101, 118, 101, 32, 116, 104, 101, 32, 101, 110, 116, 105, 114, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 66, 121, 116, 101, 115, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    _isatty_doc = allocate([ 105, 115, 97, 116, 116, 121, 40, 41, 32, 45, 62, 32, 70, 97, 108, 115, 101, 46, 10, 10, 65, 108, 119, 97, 121, 115, 32, 114, 101, 116, 117, 114, 110, 115, 32, 70, 97, 108, 115, 101, 32, 115, 105, 110, 99, 101, 32, 66, 121, 116, 101, 115, 73, 79, 32, 111, 98, 106, 101, 99, 116, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 10, 116, 111, 32, 97, 32, 116, 116, 121, 45, 108, 105, 107, 101, 32, 100, 101, 118, 105, 99, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _tell_doc = allocate([ 116, 101, 108, 108, 40, 41, 32, 45, 62, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 10, 0 ], "i8", ALLOC_NORMAL);
    _read_doc = allocate([ 114, 101, 97, 100, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 0 ], "i8", ALLOC_NORMAL);
    __str773 = allocate([ 124, 79, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str874 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8590 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    _read1_doc = allocate([ 114, 101, 97, 100, 49, 40, 115, 105, 122, 101, 41, 32, 45, 62, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 32, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 0 ], "i8", ALLOC_NORMAL);
    _readline_doc = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 110, 101, 120, 116, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 44, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 82, 101, 116, 97, 105, 110, 32, 110, 101, 119, 108, 105, 110, 101, 46, 32, 32, 65, 32, 110, 111, 110, 45, 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 108, 105, 109, 105, 116, 115, 32, 116, 104, 101, 32, 109, 97, 120, 105, 109, 117, 109, 10, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 114, 101, 116, 117, 114, 110, 32, 40, 97, 110, 32, 105, 110, 99, 111, 109, 112, 108, 101, 116, 101, 32, 108, 105, 110, 101, 32, 109, 97, 121, 32, 98, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 104, 101, 110, 41, 46, 10, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str975 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _readlines_doc = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 108, 105, 115, 116, 32, 111, 102, 32, 115, 116, 114, 105, 110, 103, 115, 44, 32, 101, 97, 99, 104, 32, 97, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 67, 97, 108, 108, 32, 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 114, 101, 112, 101, 97, 116, 101, 100, 108, 121, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 115, 111, 32, 114, 101, 97, 100, 46, 10, 84, 104, 101, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 105, 122, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 44, 32, 105, 102, 32, 103, 105, 118, 101, 110, 44, 32, 105, 115, 32, 97, 110, 32, 97, 112, 112, 114, 111, 120, 105, 109, 97, 116, 101, 32, 98, 111, 117, 110, 100, 32, 111, 110, 32, 116, 104, 101, 10, 116, 111, 116, 97, 108, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 105, 110, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1076 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _readinto_doc = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 40, 98, 121, 116, 101, 97, 114, 114, 97, 121, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 82, 101, 97, 100, 32, 117, 112, 32, 116, 111, 32, 108, 101, 110, 40, 98, 41, 32, 98, 121, 116, 101, 115, 32, 105, 110, 116, 111, 32, 98, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 114, 101, 97, 100, 32, 40, 48, 32, 102, 111, 114, 32, 69, 79, 70, 41, 44, 32, 111, 114, 32, 78, 111, 110, 101, 32, 105, 102, 32, 116, 104, 101, 32, 111, 98, 106, 101, 99, 116, 10, 105, 115, 32, 115, 101, 116, 32, 110, 111, 116, 32, 116, 111, 32, 98, 108, 111, 99, 107, 32, 97, 115, 32, 104, 97, 115, 32, 110, 111, 32, 100, 97, 116, 97, 32, 116, 111, 32, 114, 101, 97, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1177 = allocate([ 119, 42, 0 ], "i8", ALLOC_NORMAL);
    __str1278 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 43, 32, 108, 101, 110, 32, 60, 32, 40, 40, 80, 121, 95, 115, 115, 105, 122, 101, 95, 116, 41, 40, 40, 40, 115, 105, 122, 101, 95, 116, 41, 45, 49, 41, 62, 62, 49, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8792 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    _truncate_doc = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 40, 91, 115, 105, 122, 101, 93, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 84, 114, 117, 110, 99, 97, 116, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 10, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 32, 32, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 115, 105, 122, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1379 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str1480 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    _seek_doc = allocate([ 115, 101, 101, 107, 40, 112, 111, 115, 44, 32, 119, 104, 101, 110, 99, 101, 61, 48, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 83, 101, 101, 107, 32, 116, 111, 32, 98, 121, 116, 101, 32, 111, 102, 102, 115, 101, 116, 32, 112, 111, 115, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 58, 10, 32, 32, 32, 32, 32, 48, 32, 32, 83, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 46, 32, 32, 112, 111, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 59, 10, 32, 32, 32, 32, 32, 49, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 45, 32, 112, 111, 115, 32, 109, 97, 121, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 59, 10, 32, 32, 32, 32, 32, 50, 32, 32, 69, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 45, 32, 112, 111, 115, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1581 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str1682 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    __str1783 = allocate([ 110, 101, 119, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    __str1884 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 105, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    _write_doc = allocate([ 119, 114, 105, 116, 101, 40, 98, 121, 116, 101, 115, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 87, 114, 105, 116, 101, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 102, 105, 108, 101, 46, 10, 10, 82, 101, 116, 117, 114, 110, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 119, 114, 105, 116, 116, 101, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    _writelines_doc = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 40, 115, 101, 113, 117, 101, 110, 99, 101, 95, 111, 102, 95, 115, 116, 114, 105, 110, 103, 115, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 115, 32, 116, 111, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 97, 100, 100, 101, 100, 46, 32, 32, 84, 104, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 32, 99, 97, 110, 32, 98, 101, 32, 97, 110, 121, 32, 105, 116, 101, 114, 97, 98, 108, 101, 10, 111, 98, 106, 101, 99, 116, 32, 112, 114, 111, 100, 117, 99, 105, 110, 103, 32, 115, 116, 114, 105, 110, 103, 115, 46, 32, 84, 104, 105, 115, 32, 105, 115, 32, 101, 113, 117, 105, 118, 97, 108, 101, 110, 116, 32, 116, 111, 32, 99, 97, 108, 108, 105, 110, 103, 32, 119, 114, 105, 116, 101, 40, 41, 32, 102, 111, 114, 10, 101, 97, 99, 104, 32, 115, 116, 114, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    _close_doc = allocate([ 99, 108, 111, 115, 101, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 68, 105, 115, 97, 98, 108, 101, 32, 97, 108, 108, 32, 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1985 = allocate([ 40, 79, 110, 78, 41, 0 ], "i8", ALLOC_NORMAL);
    __str2086 = allocate([ 115, 116, 97, 116, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9082 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str2187 = allocate([ 37, 46, 50, 48, 48, 115, 46, 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 51, 45, 116, 117, 112, 108, 101, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2288 = allocate([ 115, 101, 99, 111, 110, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 44, 32, 110, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2389 = allocate([ 112, 111, 115, 105, 116, 105, 111, 110, 32, 118, 97, 108, 117, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str2490 = allocate([ 116, 104, 105, 114, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 32, 100, 105, 99, 116, 44, 32, 103, 111, 116, 32, 97, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2591 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9166 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str2692 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9203 = allocate([ 98, 121, 116, 101, 115, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    _C_82_9238 = allocate(8, "i8*", ALLOC_NORMAL);
    __str2793 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str2894 = allocate([ 124, 79, 58, 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str2995 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str3096 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    _bytesio_getsetlist = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str3197 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str3298 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str3399 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str34100 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str35101 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str36102 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str37103 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str38104 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str39105 = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str40106 = allocate([ 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    __str41107 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __str42108 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str43109 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str44110 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str45111 = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str46112 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str47113 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str48114 = allocate([ 95, 95, 103, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str49115 = allocate([ 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    _bytesio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _bytesio_doc = allocate([ 66, 121, 116, 101, 115, 73, 79, 40, 91, 98, 117, 102, 102, 101, 114, 93, 41, 32, 45, 62, 32, 111, 98, 106, 101, 99, 116, 10, 10, 67, 114, 101, 97, 116, 101, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 73, 47, 79, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 117, 115, 105, 110, 103, 32, 97, 110, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 121, 116, 101, 115, 10, 98, 117, 102, 102, 101, 114, 44, 32, 114, 101, 97, 100, 121, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    __str50116 = allocate([ 95, 105, 111, 46, 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyBytesIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str117 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str1118 = allocate([ 79, 0 ], "i8", ALLOC_NORMAL);
    __str2119 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str3120 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 102, 105, 108, 101, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8510 = allocate([ 102, 105, 108, 101, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    __str4121 = allocate([ 40, 105, 115, 115, 41, 0 ], "i8", ALLOC_NORMAL);
    __str5122 = allocate([ 40, 105, 115, 41, 0 ], "i8", ALLOC_NORMAL);
    __str6123 = allocate([ 114, 0 ], "i8", ALLOC_NORMAL);
    __str7124 = allocate([ 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 40, 111, 115, 101, 108, 102, 41, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 32, 61, 61, 32, 40, 38, 80, 121, 70, 105, 108, 101, 73, 79, 95, 84, 121, 112, 101, 41, 32, 124, 124, 32, 80, 121, 84, 121, 112, 101, 95, 73, 115, 83, 117, 98, 116, 121, 112, 101, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 40, 111, 115, 101, 108, 102, 41, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 44, 32, 40, 38, 80, 121, 70, 105, 108, 101, 73, 79, 95, 84, 121, 112, 101, 41, 41, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8604 = allocate([ 102, 105, 108, 101, 105, 111, 95, 105, 110, 105, 116, 0 ], "i8", ALLOC_NORMAL);
    __str8125 = allocate([ 79, 124, 115, 105, 58, 102, 105, 108, 101, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    _kwlist_8591 = allocate(16, "i8*", ALLOC_NORMAL);
    __str9126 = allocate([ 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str10127 = allocate([ 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str11128 = allocate([ 99, 108, 111, 115, 101, 102, 100, 0 ], "i8", ALLOC_NORMAL);
    __str12129 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 102, 108, 111, 97, 116, 0 ], "i8", ALLOC_NORMAL);
    __str13130 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 102, 105, 108, 101, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str14131 = allocate([ 101, 110, 99, 111, 100, 101, 114, 32, 102, 97, 105, 108, 101, 100, 32, 116, 111, 32, 114, 101, 116, 117, 114, 110, 32, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str15132 = allocate([ 77, 117, 115, 116, 32, 104, 97, 118, 101, 32, 101, 120, 97, 99, 116, 108, 121, 32, 111, 110, 101, 32, 111, 102, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 47, 97, 112, 112, 101, 110, 100, 32, 109, 111, 100, 101, 32, 97, 110, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 111, 110, 101, 32, 112, 108, 117, 115, 0 ], "i8", ALLOC_NORMAL);
    __str16133 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 109, 111, 100, 101, 58, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str17134 = allocate([ 67, 97, 110, 110, 111, 116, 32, 117, 115, 101, 32, 99, 108, 111, 115, 101, 102, 100, 61, 70, 97, 108, 115, 101, 32, 119, 105, 116, 104, 32, 102, 105, 108, 101, 32, 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str18135 = allocate([ 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str19136 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8813 = allocate([ 102, 105, 108, 101, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str20137 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str21138 = allocate([ 70, 105, 108, 101, 32, 110, 111, 116, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str22139 = allocate([ 114, 101, 97, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str23140 = allocate([ 119, 42, 0 ], "i8", ALLOC_NORMAL);
    __str24141 = allocate([ 117, 110, 98, 111, 117, 110, 100, 101, 100, 32, 114, 101, 97, 100, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 109, 111, 114, 101, 32, 98, 121, 116, 101, 115, 32, 116, 104, 97, 110, 32, 97, 32, 80, 121, 116, 104, 111, 110, 32, 115, 116, 114, 105, 110, 103, 32, 99, 97, 110, 32, 104, 111, 108, 100, 32, 0 ], "i8", ALLOC_NORMAL);
    __str25142 = allocate([ 124, 79, 38, 0 ], "i8", ALLOC_NORMAL);
    __str26143 = allocate([ 119, 114, 105, 116, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str27144 = allocate([ 115, 42, 0 ], "i8", ALLOC_NORMAL);
    __str28145 = allocate([ 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 105, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str29146 = allocate([ 79, 124, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30147 = allocate([ 124, 79, 0 ], "i8", ALLOC_NORMAL);
    __str31148 = allocate([ 114, 98, 43, 0 ], "i8", ALLOC_NORMAL);
    __str32149 = allocate([ 114, 98, 0 ], "i8", ALLOC_NORMAL);
    __str33150 = allocate([ 119, 98, 0 ], "i8", ALLOC_NORMAL);
    __str34151 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 91, 99, 108, 111, 115, 101, 100, 93, 62, 0 ], "i8", ALLOC_NORMAL);
    __str35152 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 102, 100, 61, 37, 100, 32, 109, 111, 100, 101, 61, 39, 37, 115, 39, 62, 0 ], "i8", ALLOC_NORMAL);
    __str36153 = allocate([ 60, 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 32, 110, 97, 109, 101, 61, 37, 115, 32, 109, 111, 100, 101, 61, 39, 37, 115, 39, 62, 0 ], "i8", ALLOC_NORMAL);
    _fileio_doc = allocate([ 102, 105, 108, 101, 40, 110, 97, 109, 101, 58, 32, 115, 116, 114, 91, 44, 32, 109, 111, 100, 101, 58, 32, 115, 116, 114, 93, 41, 32, 45, 62, 32, 102, 105, 108, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 10, 10, 79, 112, 101, 110, 32, 97, 32, 102, 105, 108, 101, 46, 32, 32, 84, 104, 101, 32, 109, 111, 100, 101, 32, 99, 97, 110, 32, 98, 101, 32, 39, 114, 39, 44, 32, 39, 119, 39, 32, 111, 114, 32, 39, 97, 39, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 44, 10, 119, 114, 105, 116, 105, 110, 103, 32, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 46, 32, 32, 84, 104, 101, 32, 102, 105, 108, 101, 32, 119, 105, 108, 108, 32, 98, 101, 32, 99, 114, 101, 97, 116, 101, 100, 32, 105, 102, 32, 105, 116, 32, 100, 111, 101, 115, 110, 39, 116, 32, 101, 120, 105, 115, 116, 10, 119, 104, 101, 110, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 32, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 59, 32, 105, 116, 32, 119, 105, 108, 108, 32, 98, 101, 32, 116, 114, 117, 110, 99, 97, 116, 101, 100, 32, 119, 104, 101, 110, 10, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 46, 32, 32, 65, 100, 100, 32, 97, 32, 39, 43, 39, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 116, 111, 32, 97, 108, 108, 111, 119, 32, 115, 105, 109, 117, 108, 116, 97, 110, 101, 111, 117, 115, 10, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 0 ], "i8", ALLOC_NORMAL);
    _read_doc154 = allocate([ 114, 101, 97, 100, 40, 115, 105, 122, 101, 58, 32, 105, 110, 116, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 32, 32, 114, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 98, 121, 116, 101, 115, 46, 10, 10, 79, 110, 108, 121, 32, 109, 97, 107, 101, 115, 32, 111, 110, 101, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 44, 32, 115, 111, 32, 108, 101, 115, 115, 32, 100, 97, 116, 97, 32, 109, 97, 121, 32, 98, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 104, 97, 110, 32, 114, 101, 113, 117, 101, 115, 116, 101, 100, 10, 73, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 109, 111, 100, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 78, 111, 110, 101, 32, 105, 102, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 46, 10, 79, 110, 32, 101, 110, 100, 45, 111, 102, 45, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 39, 39, 46, 0 ], "i8", ALLOC_NORMAL);
    _readall_doc = allocate([ 114, 101, 97, 100, 97, 108, 108, 40, 41, 32, 45, 62, 32, 98, 121, 116, 101, 115, 46, 32, 32, 114, 101, 97, 100, 32, 97, 108, 108, 32, 100, 97, 116, 97, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 98, 121, 116, 101, 115, 46, 10, 10, 73, 110, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 109, 111, 100, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 115, 32, 109, 117, 99, 104, 32, 97, 115, 32, 105, 115, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 44, 10, 111, 114, 32, 78, 111, 110, 101, 32, 105, 102, 32, 110, 111, 32, 100, 97, 116, 97, 32, 105, 115, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 46, 32, 32, 79, 110, 32, 101, 110, 100, 45, 111, 102, 45, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 115, 32, 39, 39, 46, 0 ], "i8", ALLOC_NORMAL);
    _write_doc155 = allocate([ 119, 114, 105, 116, 101, 40, 98, 58, 32, 98, 121, 116, 101, 115, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 87, 114, 105, 116, 101, 32, 98, 121, 116, 101, 115, 32, 98, 32, 116, 111, 32, 102, 105, 108, 101, 44, 32, 114, 101, 116, 117, 114, 110, 32, 110, 117, 109, 98, 101, 114, 32, 119, 114, 105, 116, 116, 101, 110, 46, 10, 10, 79, 110, 108, 121, 32, 109, 97, 107, 101, 115, 32, 111, 110, 101, 32, 115, 121, 115, 116, 101, 109, 32, 99, 97, 108, 108, 44, 32, 115, 111, 32, 110, 111, 116, 32, 97, 108, 108, 32, 111, 102, 32, 116, 104, 101, 32, 100, 97, 116, 97, 32, 109, 97, 121, 32, 98, 101, 32, 119, 114, 105, 116, 116, 101, 110, 46, 10, 84, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 98, 121, 116, 101, 115, 32, 97, 99, 116, 117, 97, 108, 108, 121, 32, 119, 114, 105, 116, 116, 101, 110, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 46, 0 ], "i8", ALLOC_NORMAL);
    _fileno_doc = allocate([ 102, 105, 108, 101, 110, 111, 40, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 34, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 34, 46, 10, 10, 84, 104, 105, 115, 32, 105, 115, 32, 110, 101, 101, 100, 101, 100, 32, 102, 111, 114, 32, 108, 111, 119, 101, 114, 45, 108, 101, 118, 101, 108, 32, 102, 105, 108, 101, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 44, 32, 115, 117, 99, 104, 32, 116, 104, 101, 32, 102, 99, 110, 116, 108, 32, 109, 111, 100, 117, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _seek_doc156 = allocate([ 115, 101, 101, 107, 40, 111, 102, 102, 115, 101, 116, 58, 32, 105, 110, 116, 91, 44, 32, 119, 104, 101, 110, 99, 101, 58, 32, 105, 110, 116, 93, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 77, 111, 118, 101, 32, 116, 111, 32, 110, 101, 119, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 65, 114, 103, 117, 109, 101, 110, 116, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 32, 97, 32, 98, 121, 116, 101, 32, 99, 111, 117, 110, 116, 46, 32, 32, 79, 112, 116, 105, 111, 110, 97, 108, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 119, 104, 101, 110, 99, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 10, 48, 32, 40, 111, 102, 102, 115, 101, 116, 32, 102, 114, 111, 109, 32, 115, 116, 97, 114, 116, 32, 111, 102, 32, 102, 105, 108, 101, 44, 32, 111, 102, 102, 115, 101, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 41, 59, 32, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101, 115, 32, 97, 114, 101, 32, 49, 10, 40, 109, 111, 118, 101, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 99, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 111, 114, 32, 110, 101, 103, 97, 116, 105, 118, 101, 41, 44, 32, 97, 110, 100, 32, 50, 32, 40, 109, 111, 118, 101, 10, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 101, 110, 100, 32, 111, 102, 32, 102, 105, 108, 101, 44, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 44, 32, 97, 108, 116, 104, 111, 117, 103, 104, 32, 109, 97, 110, 121, 32, 112, 108, 97, 116, 102, 111, 114, 109, 115, 32, 97, 108, 108, 111, 119, 10, 115, 101, 101, 107, 105, 110, 103, 32, 98, 101, 121, 111, 110, 100, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 97, 32, 102, 105, 108, 101, 41, 46, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 110, 111, 116, 32, 97, 108, 108, 32, 102, 105, 108, 101, 32, 111, 98, 106, 101, 99, 116, 115, 32, 97, 114, 101, 32, 115, 101, 101, 107, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _truncate_doc157 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 40, 91, 115, 105, 122, 101, 58, 32, 105, 110, 116, 93, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 84, 114, 117, 110, 99, 97, 116, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 97, 116, 32, 109, 111, 115, 116, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 99, 104, 97, 110, 103, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 32, 111, 102, 32, 115, 105, 122, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _tell_doc158 = allocate([ 116, 101, 108, 108, 40, 41, 32, 45, 62, 32, 105, 110, 116, 46, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    _readinto_doc159 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 32, 45, 62, 32, 83, 97, 109, 101, 32, 97, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 46, 114, 101, 97, 100, 105, 110, 116, 111, 40, 41, 46, 0 ], "i8", ALLOC_NORMAL);
    _close_doc160 = allocate([ 99, 108, 111, 115, 101, 40, 41, 32, 45, 62, 32, 78, 111, 110, 101, 46, 32, 32, 67, 108, 111, 115, 101, 32, 116, 104, 101, 32, 102, 105, 108, 101, 46, 10, 10, 65, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 117, 115, 101, 100, 32, 102, 111, 114, 32, 102, 117, 114, 116, 104, 101, 114, 32, 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 46, 32, 32, 99, 108, 111, 115, 101, 40, 41, 32, 109, 97, 121, 32, 98, 101, 10, 99, 97, 108, 108, 101, 100, 32, 109, 111, 114, 101, 32, 116, 104, 97, 110, 32, 111, 110, 99, 101, 32, 119, 105, 116, 104, 111, 117, 116, 32, 101, 114, 114, 111, 114, 46, 32, 32, 67, 104, 97, 110, 103, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 110, 111, 32, 116, 111, 32, 45, 49, 46, 0 ], "i8", ALLOC_NORMAL);
    _isatty_doc161 = allocate([ 105, 115, 97, 116, 116, 121, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 111, 110, 110, 101, 99, 116, 101, 100, 32, 116, 111, 32, 97, 32, 116, 116, 121, 32, 100, 101, 118, 105, 99, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _seekable_doc = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 114, 97, 110, 100, 111, 109, 45, 97, 99, 99, 101, 115, 115, 46, 0 ], "i8", ALLOC_NORMAL);
    _readable_doc = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 114, 101, 97, 100, 32, 109, 111, 100, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _writable_doc = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 40, 41, 32, 45, 62, 32, 98, 111, 111, 108, 46, 32, 32, 84, 114, 117, 101, 32, 105, 102, 32, 102, 105, 108, 101, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 119, 114, 105, 116, 101, 32, 109, 111, 100, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str37162 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str38163 = allocate([ 114, 101, 97, 100, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str39164 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __str40165 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41166 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str42167 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str43168 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44169 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45170 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str46171 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str47172 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str48173 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    _fileio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str49174 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str50175 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str51176 = allocate([ 84, 114, 117, 101, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 119, 105, 108, 108, 32, 98, 101, 32, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str52177 = allocate([ 83, 116, 114, 105, 110, 103, 32, 103, 105, 118, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    _fileio_getsetlist = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str53178 = allocate([ 95, 105, 111, 46, 70, 105, 108, 101, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyFileIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "void (i8*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _iobase_doc = allocate([ 84, 104, 101, 32, 97, 98, 115, 116, 114, 97, 99, 116, 32, 98, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 97, 108, 108, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 44, 32, 97, 99, 116, 105, 110, 103, 32, 111, 110, 32, 115, 116, 114, 101, 97, 109, 115, 32, 111, 102, 10, 98, 121, 116, 101, 115, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 112, 117, 98, 108, 105, 99, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 10, 10, 84, 104, 105, 115, 32, 99, 108, 97, 115, 115, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 100, 117, 109, 109, 121, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 102, 111, 114, 32, 109, 97, 110, 121, 32, 109, 101, 116, 104, 111, 100, 115, 32, 116, 104, 97, 116, 10, 100, 101, 114, 105, 118, 101, 100, 32, 99, 108, 97, 115, 115, 101, 115, 32, 99, 97, 110, 32, 111, 118, 101, 114, 114, 105, 100, 101, 32, 115, 101, 108, 101, 99, 116, 105, 118, 101, 108, 121, 59, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 10, 114, 101, 112, 114, 101, 115, 101, 110, 116, 32, 97, 32, 102, 105, 108, 101, 32, 116, 104, 97, 116, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 114, 101, 97, 100, 44, 32, 119, 114, 105, 116, 116, 101, 110, 32, 111, 114, 32, 115, 101, 101, 107, 101, 100, 46, 10, 10, 69, 118, 101, 110, 32, 116, 104, 111, 117, 103, 104, 32, 73, 79, 66, 97, 115, 101, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 100, 101, 99, 108, 97, 114, 101, 32, 114, 101, 97, 100, 44, 32, 114, 101, 97, 100, 105, 110, 116, 111, 44, 32, 111, 114, 32, 119, 114, 105, 116, 101, 32, 98, 101, 99, 97, 117, 115, 101, 10, 116, 104, 101, 105, 114, 32, 115, 105, 103, 110, 97, 116, 117, 114, 101, 115, 32, 119, 105, 108, 108, 32, 118, 97, 114, 121, 44, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 97, 110, 100, 32, 99, 108, 105, 101, 110, 116, 115, 32, 115, 104, 111, 117, 108, 100, 10, 99, 111, 110, 115, 105, 100, 101, 114, 32, 116, 104, 111, 115, 101, 32, 109, 101, 116, 104, 111, 100, 115, 32, 112, 97, 114, 116, 32, 111, 102, 32, 116, 104, 101, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 46, 32, 65, 108, 115, 111, 44, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 10, 109, 97, 121, 32, 114, 97, 105, 115, 101, 32, 97, 32, 73, 79, 69, 114, 114, 111, 114, 32, 119, 104, 101, 110, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 32, 116, 104, 101, 121, 32, 100, 111, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 97, 114, 101, 32, 99, 97, 108, 108, 101, 100, 46, 10, 10, 84, 104, 101, 32, 98, 97, 115, 105, 99, 32, 116, 121, 112, 101, 32, 117, 115, 101, 100, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 100, 97, 116, 97, 32, 114, 101, 97, 100, 32, 102, 114, 111, 109, 32, 111, 114, 32, 119, 114, 105, 116, 116, 101, 110, 32, 116, 111, 32, 97, 32, 102, 105, 108, 101, 32, 105, 115, 10, 98, 121, 116, 101, 115, 46, 32, 98, 121, 116, 101, 97, 114, 114, 97, 121, 115, 32, 97, 114, 101, 32, 97, 99, 99, 101, 112, 116, 101, 100, 32, 116, 111, 111, 44, 32, 97, 110, 100, 32, 105, 110, 32, 115, 111, 109, 101, 32, 99, 97, 115, 101, 115, 32, 40, 115, 117, 99, 104, 32, 97, 115, 10, 114, 101, 97, 100, 105, 110, 116, 111, 41, 32, 110, 101, 101, 100, 101, 100, 46, 32, 84, 101, 120, 116, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 32, 119, 111, 114, 107, 32, 119, 105, 116, 104, 32, 115, 116, 114, 32, 100, 97, 116, 97, 46, 10, 10, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 99, 97, 108, 108, 105, 110, 103, 32, 97, 110, 121, 32, 109, 101, 116, 104, 111, 100, 32, 40, 101, 118, 101, 110, 32, 105, 110, 113, 117, 105, 114, 105, 101, 115, 41, 32, 111, 110, 32, 97, 32, 99, 108, 111, 115, 101, 100, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 10, 117, 110, 100, 101, 102, 105, 110, 101, 100, 46, 32, 73, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 109, 97, 121, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 110, 32, 116, 104, 105, 115, 32, 99, 97, 115, 101, 46, 10, 10, 73, 79, 66, 97, 115, 101, 32, 40, 97, 110, 100, 32, 105, 116, 115, 32, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 41, 32, 115, 117, 112, 112, 111, 114, 116, 32, 116, 104, 101, 32, 105, 116, 101, 114, 97, 116, 111, 114, 32, 112, 114, 111, 116, 111, 99, 111, 108, 44, 32, 109, 101, 97, 110, 105, 110, 103, 10, 116, 104, 97, 116, 32, 97, 110, 32, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 32, 99, 97, 110, 32, 98, 101, 32, 105, 116, 101, 114, 97, 116, 101, 100, 32, 111, 118, 101, 114, 32, 121, 105, 101, 108, 100, 105, 110, 103, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 105, 110, 32, 97, 10, 115, 116, 114, 101, 97, 109, 46, 10, 10, 73, 79, 66, 97, 115, 101, 32, 97, 108, 115, 111, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 116, 104, 101, 32, 58, 107, 101, 121, 119, 111, 114, 100, 58, 96, 119, 105, 116, 104, 96, 32, 115, 116, 97, 116, 101, 109, 101, 110, 116, 46, 32, 73, 110, 32, 116, 104, 105, 115, 32, 101, 120, 97, 109, 112, 108, 101, 44, 10, 102, 112, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 97, 102, 116, 101, 114, 32, 116, 104, 101, 32, 115, 117, 105, 116, 101, 32, 111, 102, 32, 116, 104, 101, 32, 119, 105, 116, 104, 32, 115, 116, 97, 116, 101, 109, 101, 110, 116, 32, 105, 115, 32, 99, 111, 109, 112, 108, 101, 116, 101, 58, 10, 10, 119, 105, 116, 104, 32, 111, 112, 101, 110, 40, 39, 115, 112, 97, 109, 46, 116, 120, 116, 39, 44, 32, 39, 114, 39, 41, 32, 97, 115, 32, 102, 112, 58, 10, 32, 32, 32, 32, 102, 112, 46, 119, 114, 105, 116, 101, 40, 39, 83, 112, 97, 109, 32, 97, 110, 100, 32, 101, 103, 103, 115, 33, 39, 41, 10, 0 ], "i8", ALLOC_NORMAL);
    _iobase_seek_doc = allocate([ 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 67, 104, 97, 110, 103, 101, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 32, 98, 121, 116, 101, 32, 111, 102, 102, 115, 101, 116, 32, 111, 102, 102, 115, 101, 116, 46, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 10, 105, 110, 116, 101, 114, 112, 114, 101, 116, 101, 100, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 116, 104, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 46, 32, 32, 86, 97, 108, 117, 101, 115, 10, 102, 111, 114, 32, 119, 104, 101, 110, 99, 101, 32, 97, 114, 101, 58, 10, 10, 42, 32, 48, 32, 45, 45, 32, 115, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 59, 32, 111, 102, 102, 115, 101, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 122, 101, 114, 111, 32, 111, 114, 32, 112, 111, 115, 105, 116, 105, 118, 101, 10, 42, 32, 49, 32, 45, 45, 32, 99, 117, 114, 114, 101, 110, 116, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 59, 32, 111, 102, 102, 115, 101, 116, 32, 109, 97, 121, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 10, 42, 32, 50, 32, 45, 45, 32, 101, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 59, 32, 111, 102, 102, 115, 101, 116, 32, 105, 115, 32, 117, 115, 117, 97, 108, 108, 121, 32, 110, 101, 103, 97, 116, 105, 118, 101, 10, 10, 82, 101, 116, 117, 114, 110, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str181 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    _iobase_tell_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 99, 117, 114, 114, 101, 110, 116, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    __str1182 = allocate([ 105, 105, 0 ], "i8", ALLOC_NORMAL);
    _iobase_truncate_doc = allocate([ 84, 114, 117, 110, 99, 97, 116, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 115, 105, 122, 101, 32, 98, 121, 116, 101, 115, 46, 10, 10, 70, 105, 108, 101, 32, 112, 111, 105, 110, 116, 101, 114, 32, 105, 115, 32, 108, 101, 102, 116, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 32, 32, 83, 105, 122, 101, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 73, 79, 10, 112, 111, 115, 105, 116, 105, 111, 110, 32, 97, 115, 32, 114, 101, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 32, 32, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 115, 105, 122, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str2183 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _iobase_flush_doc = allocate([ 70, 108, 117, 115, 104, 32, 119, 114, 105, 116, 101, 32, 98, 117, 102, 102, 101, 114, 115, 44, 32, 105, 102, 32, 97, 112, 112, 108, 105, 99, 97, 98, 108, 101, 46, 10, 10, 84, 104, 105, 115, 32, 105, 115, 32, 110, 111, 116, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 101, 100, 32, 102, 111, 114, 32, 114, 101, 97, 100, 45, 111, 110, 108, 121, 32, 97, 110, 100, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 115, 116, 114, 101, 97, 109, 115, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str3184 = allocate([ 95, 95, 73, 79, 66, 97, 115, 101, 95, 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str4185 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_close_doc = allocate([ 70, 108, 117, 115, 104, 32, 97, 110, 100, 32, 99, 108, 111, 115, 101, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 10, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 104, 97, 115, 32, 110, 111, 32, 101, 102, 102, 101, 99, 116, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 97, 108, 114, 101, 97, 100, 121, 32, 99, 108, 111, 115, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str5186 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str6187 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 105, 111, 98, 97, 115, 101, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8582 = allocate([ 105, 111, 98, 97, 115, 101, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    _iobase_seekable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 115, 117, 112, 112, 111, 114, 116, 115, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 115, 101, 101, 107, 40, 41, 44, 32, 116, 101, 108, 108, 40, 41, 32, 97, 110, 100, 32, 116, 114, 117, 110, 99, 97, 116, 101, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 109, 97, 121, 32, 110, 101, 101, 100, 32, 116, 111, 32, 100, 111, 32, 97, 32, 116, 101, 115, 116, 32, 115, 101, 101, 107, 40, 41, 46, 0 ], "i8", ALLOC_NORMAL);
    __str7188 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 115, 101, 101, 107, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 114, 101, 97, 100, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str8189 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 114, 101, 97, 100, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_writable_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 111, 98, 106, 101, 99, 116, 32, 119, 97, 115, 32, 111, 112, 101, 110, 101, 100, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 46, 10, 10, 73, 102, 32, 70, 97, 108, 115, 101, 44, 32, 114, 101, 97, 100, 40, 41, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str9190 = allocate([ 70, 105, 108, 101, 32, 111, 114, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 119, 114, 105, 116, 97, 98, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    _iobase_fileno_doc = allocate([ 82, 101, 116, 117, 114, 110, 115, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 102, 32, 111, 110, 101, 32, 101, 120, 105, 115, 116, 115, 46, 10, 10, 65, 110, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 115, 32, 114, 97, 105, 115, 101, 100, 32, 105, 102, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 117, 115, 101, 32, 97, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str10191 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    _iobase_isatty_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 119, 104, 101, 116, 104, 101, 114, 32, 116, 104, 105, 115, 32, 105, 115, 32, 97, 110, 32, 39, 105, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 39, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 116, 117, 114, 110, 32, 70, 97, 108, 115, 101, 32, 105, 102, 32, 105, 116, 32, 99, 97, 110, 39, 116, 32, 98, 101, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readline_doc = allocate([ 82, 101, 97, 100, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 110, 101, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 73, 102, 32, 108, 105, 109, 105, 116, 32, 105, 115, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 44, 32, 97, 116, 32, 109, 111, 115, 116, 32, 108, 105, 109, 105, 116, 32, 98, 121, 116, 101, 115, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 101, 97, 100, 46, 10, 10, 84, 104, 101, 32, 108, 105, 110, 101, 32, 116, 101, 114, 109, 105, 110, 97, 116, 111, 114, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 98, 39, 10, 39, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 59, 32, 102, 111, 114, 32, 116, 101, 120, 116, 10, 102, 105, 108, 101, 115, 44, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 116, 111, 32, 111, 112, 101, 110, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 116, 111, 32, 115, 101, 108, 101, 99, 116, 32, 116, 104, 101, 32, 108, 105, 110, 101, 10, 116, 101, 114, 109, 105, 110, 97, 116, 111, 114, 40, 115, 41, 32, 114, 101, 99, 111, 103, 110, 105, 122, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str11192 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str12193 = allocate([ 112, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str13194 = allocate([ 105, 0 ], "i8", ALLOC_NORMAL);
    __str14195 = allocate([ 112, 101, 101, 107, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str15196 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str16197 = allocate([ 110, 0 ], "i8", ALLOC_NORMAL);
    __str17198 = allocate([ 114, 101, 97, 100, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 32, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str18199 = allocate([ 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 98, 117, 102, 102, 101, 114, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 32, 61, 61, 32, 40, 38, 80, 121, 66, 121, 116, 101, 65, 114, 114, 97, 121, 95, 84, 121, 112, 101, 41, 32, 124, 124, 32, 80, 121, 84, 121, 112, 101, 95, 73, 115, 83, 117, 98, 116, 121, 112, 101, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 98, 117, 102, 102, 101, 114, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 44, 32, 40, 38, 80, 121, 66, 121, 116, 101, 65, 114, 114, 97, 121, 95, 84, 121, 112, 101, 41, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8823 = allocate([ 105, 111, 98, 97, 115, 101, 95, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _iobase_readlines_doc = allocate([ 82, 101, 116, 117, 114, 110, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 108, 105, 110, 101, 115, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 104, 105, 110, 116, 32, 99, 97, 110, 32, 98, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 116, 111, 32, 99, 111, 110, 116, 114, 111, 108, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 108, 105, 110, 101, 115, 32, 114, 101, 97, 100, 58, 32, 110, 111, 32, 109, 111, 114, 101, 10, 108, 105, 110, 101, 115, 32, 119, 105, 108, 108, 32, 98, 101, 32, 114, 101, 97, 100, 32, 105, 102, 32, 116, 104, 101, 32, 116, 111, 116, 97, 108, 32, 115, 105, 122, 101, 32, 40, 105, 110, 32, 98, 121, 116, 101, 115, 47, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 41, 32, 111, 102, 32, 97, 108, 108, 10, 108, 105, 110, 101, 115, 32, 115, 111, 32, 102, 97, 114, 32, 101, 120, 99, 101, 101, 100, 115, 32, 104, 105, 110, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    __str19200 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str20201 = allocate([ 101, 120, 116, 101, 110, 100, 0 ], "i8", ALLOC_NORMAL);
    __str21202 = allocate([ 79, 0 ], "i8", ALLOC_NORMAL);
    __str22203 = allocate([ 79, 58, 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str23204 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str24205 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str25206 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str26207 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27208 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str28209 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str29210 = allocate([ 95, 99, 104, 101, 99, 107, 67, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str30211 = allocate([ 95, 99, 104, 101, 99, 107, 83, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31212 = allocate([ 95, 99, 104, 101, 99, 107, 82, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32213 = allocate([ 95, 99, 104, 101, 99, 107, 87, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str33214 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str34215 = allocate([ 95, 95, 101, 110, 116, 101, 114, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str35216 = allocate([ 95, 95, 101, 120, 105, 116, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str36217 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37218 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str38219 = allocate([ 119, 114, 105, 116, 101, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _iobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str39220 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    _iobase_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str40221 = allocate([ 95, 105, 111, 46, 95, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _rawiobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 114, 97, 119, 32, 98, 105, 110, 97, 114, 121, 32, 73, 47, 79, 46, 0 ], "i8", ALLOC_NORMAL);
    __str41223 = allocate([ 124, 110, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str42224 = allocate([ 114, 101, 97, 100, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    _rawiobase_readall_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 44, 32, 117, 115, 105, 110, 103, 32, 109, 117, 108, 116, 105, 112, 108, 101, 32, 114, 101, 97, 100, 40, 41, 32, 99, 97, 108, 108, 46, 0 ], "i8", ALLOC_NORMAL);
    __str43225 = allocate([ 114, 101, 97, 100, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 114, 101, 116, 117, 114, 110, 32, 98, 121, 116, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    _rawiobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str44226 = allocate([ 95, 105, 111, 46, 95, 82, 97, 119, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyRawIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _module_doc = allocate([ 84, 104, 101, 32, 105, 111, 32, 109, 111, 100, 117, 108, 101, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 116, 104, 101, 32, 80, 121, 116, 104, 111, 110, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 32, 104, 97, 110, 100, 108, 105, 110, 103, 46, 32, 84, 104, 101, 10, 98, 117, 105, 108, 116, 105, 110, 32, 111, 112, 101, 110, 32, 102, 117, 110, 99, 116, 105, 111, 110, 32, 105, 115, 32, 100, 101, 102, 105, 110, 101, 100, 32, 105, 110, 32, 116, 104, 105, 115, 32, 109, 111, 100, 117, 108, 101, 46, 10, 10, 65, 116, 32, 116, 104, 101, 32, 116, 111, 112, 32, 111, 102, 32, 116, 104, 101, 32, 73, 47, 79, 32, 104, 105, 101, 114, 97, 114, 99, 104, 121, 32, 105, 115, 32, 116, 104, 101, 32, 97, 98, 115, 116, 114, 97, 99, 116, 32, 98, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 73, 79, 66, 97, 115, 101, 46, 32, 73, 116, 10, 100, 101, 102, 105, 110, 101, 115, 32, 116, 104, 101, 32, 98, 97, 115, 105, 99, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 78, 111, 116, 101, 44, 32, 104, 111, 119, 101, 118, 101, 114, 44, 32, 116, 104, 97, 116, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 10, 115, 101, 112, 101, 114, 97, 116, 105, 111, 110, 32, 98, 101, 116, 119, 101, 101, 110, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 115, 59, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 115, 32, 97, 114, 101, 10, 97, 108, 108, 111, 119, 101, 100, 32, 116, 111, 32, 116, 104, 114, 111, 119, 32, 97, 110, 32, 73, 79, 69, 114, 114, 111, 114, 32, 105, 102, 32, 116, 104, 101, 121, 32, 100, 111, 32, 110, 111, 116, 32, 115, 117, 112, 112, 111, 114, 116, 32, 97, 32, 103, 105, 118, 101, 110, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 46, 10, 10, 69, 120, 116, 101, 110, 100, 105, 110, 103, 32, 73, 79, 66, 97, 115, 101, 32, 105, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 119, 104, 105, 99, 104, 32, 100, 101, 97, 108, 115, 32, 115, 105, 109, 112, 108, 121, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 10, 119, 114, 105, 116, 105, 110, 103, 32, 111, 102, 32, 114, 97, 119, 32, 98, 121, 116, 101, 115, 32, 116, 111, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 70, 105, 108, 101, 73, 79, 32, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 82, 97, 119, 73, 79, 66, 97, 115, 101, 32, 116, 111, 32, 112, 114, 111, 118, 105, 100, 101, 10, 97, 110, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 79, 83, 32, 102, 105, 108, 101, 115, 46, 10, 10, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 32, 100, 101, 97, 108, 115, 32, 119, 105, 116, 104, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 111, 110, 32, 97, 32, 114, 97, 119, 32, 98, 121, 116, 101, 32, 115, 116, 114, 101, 97, 109, 32, 40, 82, 97, 119, 73, 79, 66, 97, 115, 101, 41, 46, 32, 73, 116, 115, 10, 115, 117, 98, 99, 108, 97, 115, 115, 101, 115, 44, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 44, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 44, 32, 97, 110, 100, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 32, 98, 117, 102, 102, 101, 114, 10, 115, 116, 114, 101, 97, 109, 115, 32, 116, 104, 97, 116, 32, 97, 114, 101, 32, 114, 101, 97, 100, 97, 98, 108, 101, 44, 32, 119, 114, 105, 116, 97, 98, 108, 101, 44, 32, 97, 110, 100, 32, 98, 111, 116, 104, 32, 114, 101, 115, 112, 101, 99, 116, 105, 118, 101, 108, 121, 46, 10, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 114, 97, 110, 100, 111, 109, 32, 97, 99, 99, 101, 115, 115, 10, 115, 116, 114, 101, 97, 109, 115, 46, 32, 66, 121, 116, 101, 115, 73, 79, 32, 105, 115, 32, 97, 32, 115, 105, 109, 112, 108, 101, 32, 115, 116, 114, 101, 97, 109, 32, 111, 102, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 121, 116, 101, 115, 46, 10, 10, 65, 110, 111, 116, 104, 101, 114, 32, 73, 79, 66, 97, 115, 101, 32, 115, 117, 98, 99, 108, 97, 115, 115, 44, 32, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 44, 32, 100, 101, 97, 108, 115, 32, 119, 105, 116, 104, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 110, 100, 32, 100, 101, 99, 111, 100, 105, 110, 103, 10, 111, 102, 32, 115, 116, 114, 101, 97, 109, 115, 32, 105, 110, 116, 111, 32, 116, 101, 120, 116, 46, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 44, 32, 119, 104, 105, 99, 104, 32, 101, 120, 116, 101, 110, 100, 115, 32, 105, 116, 44, 32, 105, 115, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 116, 101, 120, 116, 10, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 97, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 114, 97, 119, 32, 115, 116, 114, 101, 97, 109, 32, 40, 96, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 96, 41, 46, 32, 70, 105, 110, 97, 108, 108, 121, 44, 32, 83, 116, 114, 105, 110, 103, 73, 79, 10, 105, 115, 32, 97, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 115, 116, 114, 101, 97, 109, 32, 102, 111, 114, 32, 116, 101, 120, 116, 46, 10, 10, 65, 114, 103, 117, 109, 101, 110, 116, 32, 110, 97, 109, 101, 115, 32, 97, 114, 101, 32, 110, 111, 116, 32, 112, 97, 114, 116, 32, 111, 102, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 99, 97, 116, 105, 111, 110, 44, 32, 97, 110, 100, 32, 111, 110, 108, 121, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 115, 10, 111, 102, 32, 111, 112, 101, 110, 40, 41, 32, 97, 114, 101, 32, 105, 110, 116, 101, 110, 100, 101, 100, 32, 116, 111, 32, 98, 101, 32, 117, 115, 101, 100, 32, 97, 115, 32, 107, 101, 121, 119, 111, 114, 100, 32, 97, 114, 103, 117, 109, 101, 110, 116, 115, 46, 10, 10, 100, 97, 116, 97, 58, 10, 10, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 10, 10, 32, 32, 32, 65, 110, 32, 105, 110, 116, 32, 99, 111, 110, 116, 97, 105, 110, 105, 110, 103, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 117, 115, 101, 100, 32, 98, 121, 32, 116, 104, 101, 32, 109, 111, 100, 117, 108, 101, 39, 115, 32, 98, 117, 102, 102, 101, 114, 101, 100, 10, 32, 32, 32, 73, 47, 79, 32, 99, 108, 97, 115, 115, 101, 115, 46, 32, 111, 112, 101, 110, 40, 41, 32, 117, 115, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 39, 115, 32, 98, 108, 107, 115, 105, 122, 101, 32, 40, 97, 115, 32, 111, 98, 116, 97, 105, 110, 101, 100, 32, 98, 121, 32, 111, 115, 46, 115, 116, 97, 116, 41, 32, 105, 102, 10, 32, 32, 32, 112, 111, 115, 115, 105, 98, 108, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str232 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 97, 114, 103, 115, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 54, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str1233 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 95, 105, 111, 109, 111, 100, 117, 108, 101, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8402 = allocate([ 98, 108, 111, 99, 107, 105, 110, 103, 105, 111, 101, 114, 114, 111, 114, 95, 105, 110, 105, 116, 0 ], "i8", ALLOC_NORMAL);
    __str2234 = allocate([ 79, 79, 124, 110, 58, 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str3235 = allocate([ 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 95, 119, 114, 105, 116, 116, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    _blockingioerror_members = allocate([ 0, 0, 0, 0, 19, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str4236 = allocate([ 66, 108, 111, 99, 107, 105, 110, 103, 73, 79, 69, 114, 114, 111, 114, 0 ], "i8", ALLOC_NORMAL);
    __str5237 = allocate([ 69, 120, 99, 101, 112, 116, 105, 111, 110, 32, 114, 97, 105, 115, 101, 100, 32, 119, 104, 101, 110, 32, 73, 47, 79, 32, 119, 111, 117, 108, 100, 32, 98, 108, 111, 99, 107, 32, 111, 110, 32, 97, 32, 110, 111, 110, 45, 98, 108, 111, 99, 107, 105, 110, 103, 32, 73, 47, 79, 32, 115, 116, 114, 101, 97, 109, 0 ], "i8", ALLOC_NORMAL);
    __PyExc_BlockingIOError = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _PyExc_BlockingIOError = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    _open_doc = allocate([ 79, 112, 101, 110, 32, 102, 105, 108, 101, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 115, 116, 114, 101, 97, 109, 46, 32, 32, 82, 97, 105, 115, 101, 32, 73, 79, 69, 114, 114, 111, 114, 32, 117, 112, 111, 110, 32, 102, 97, 105, 108, 117, 114, 101, 46, 10, 10, 102, 105, 108, 101, 32, 105, 115, 32, 101, 105, 116, 104, 101, 114, 32, 97, 32, 116, 101, 120, 116, 32, 111, 114, 32, 98, 121, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 103, 105, 118, 105, 110, 103, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 40, 97, 110, 100, 32, 116, 104, 101, 32, 112, 97, 116, 104, 10, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 110, 39, 116, 32, 105, 110, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 119, 111, 114, 107, 105, 110, 103, 32, 100, 105, 114, 101, 99, 116, 111, 114, 121, 41, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 10, 98, 101, 32, 111, 112, 101, 110, 101, 100, 32, 111, 114, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 98, 101, 10, 119, 114, 97, 112, 112, 101, 100, 46, 32, 40, 73, 102, 32, 97, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 105, 115, 32, 103, 105, 118, 101, 110, 44, 32, 105, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 119, 104, 101, 110, 32, 116, 104, 101, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 73, 47, 79, 32, 111, 98, 106, 101, 99, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 44, 32, 117, 110, 108, 101, 115, 115, 32, 99, 108, 111, 115, 101, 102, 100, 32, 105, 115, 32, 115, 101, 116, 32, 116, 111, 32, 70, 97, 108, 115, 101, 46, 41, 10, 10, 109, 111, 100, 101, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 116, 114, 105, 110, 103, 32, 116, 104, 97, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 115, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 105, 110, 32, 119, 104, 105, 99, 104, 32, 116, 104, 101, 32, 102, 105, 108, 101, 10, 105, 115, 32, 111, 112, 101, 110, 101, 100, 46, 32, 73, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 39, 114, 39, 32, 119, 104, 105, 99, 104, 32, 109, 101, 97, 110, 115, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 105, 110, 32, 116, 101, 120, 116, 10, 109, 111, 100, 101, 46, 32, 32, 79, 116, 104, 101, 114, 32, 99, 111, 109, 109, 111, 110, 32, 118, 97, 108, 117, 101, 115, 32, 97, 114, 101, 32, 39, 119, 39, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 32, 40, 116, 114, 117, 110, 99, 97, 116, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 102, 10, 105, 116, 32, 97, 108, 114, 101, 97, 100, 121, 32, 101, 120, 105, 115, 116, 115, 41, 44, 32, 97, 110, 100, 32, 39, 97, 39, 32, 102, 111, 114, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 40, 119, 104, 105, 99, 104, 32, 111, 110, 32, 115, 111, 109, 101, 32, 85, 110, 105, 120, 32, 115, 121, 115, 116, 101, 109, 115, 44, 10, 109, 101, 97, 110, 115, 32, 116, 104, 97, 116, 32, 97, 108, 108, 32, 119, 114, 105, 116, 101, 115, 32, 97, 112, 112, 101, 110, 100, 32, 116, 111, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 114, 101, 103, 97, 114, 100, 108, 101, 115, 115, 32, 111, 102, 32, 116, 104, 101, 10, 99, 117, 114, 114, 101, 110, 116, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 41, 46, 32, 73, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 44, 32, 105, 102, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 32, 110, 111, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 116, 104, 101, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 115, 101, 100, 32, 105, 115, 32, 112, 108, 97, 116, 102, 111, 114, 109, 32, 100, 101, 112, 101, 110, 100, 101, 110, 116, 46, 32, 40, 70, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 114, 97, 119, 10, 98, 121, 116, 101, 115, 32, 117, 115, 101, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 97, 110, 100, 32, 108, 101, 97, 118, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 110, 115, 112, 101, 99, 105, 102, 105, 101, 100, 46, 41, 32, 84, 104, 101, 32, 97, 118, 97, 105, 108, 97, 98, 108, 101, 10, 109, 111, 100, 101, 115, 32, 97, 114, 101, 58, 10, 10, 61, 61, 61, 61, 61, 61, 61, 61, 61, 32, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 10, 67, 104, 97, 114, 97, 99, 116, 101, 114, 32, 77, 101, 97, 110, 105, 110, 103, 10, 45, 45, 45, 45, 45, 45, 45, 45, 45, 32, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 10, 39, 114, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 10, 39, 119, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 44, 32, 116, 114, 117, 110, 99, 97, 116, 105, 110, 103, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 102, 105, 114, 115, 116, 10, 39, 97, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 102, 111, 114, 32, 119, 114, 105, 116, 105, 110, 103, 44, 32, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 116, 111, 32, 116, 104, 101, 32, 101, 110, 100, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 102, 32, 105, 116, 32, 101, 120, 105, 115, 116, 115, 10, 39, 98, 39, 32, 32, 32, 32, 32, 32, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 10, 39, 116, 39, 32, 32, 32, 32, 32, 32, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 100, 101, 102, 97, 117, 108, 116, 41, 10, 39, 43, 39, 32, 32, 32, 32, 32, 32, 32, 111, 112, 101, 110, 32, 97, 32, 100, 105, 115, 107, 32, 102, 105, 108, 101, 32, 102, 111, 114, 32, 117, 112, 100, 97, 116, 105, 110, 103, 32, 40, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 41, 10, 39, 85, 39, 32, 32, 32, 32, 32, 32, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 109, 111, 100, 101, 32, 40, 102, 111, 114, 32, 98, 97, 99, 107, 119, 97, 114, 100, 115, 32, 99, 111, 109, 112, 97, 116, 105, 98, 105, 108, 105, 116, 121, 59, 32, 117, 110, 110, 101, 101, 100, 101, 100, 10, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 102, 111, 114, 32, 110, 101, 119, 32, 99, 111, 100, 101, 41, 10, 61, 61, 61, 61, 61, 61, 61, 61, 61, 32, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 10, 10, 84, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 109, 111, 100, 101, 32, 105, 115, 32, 39, 114, 116, 39, 32, 40, 111, 112, 101, 110, 32, 102, 111, 114, 32, 114, 101, 97, 100, 105, 110, 103, 32, 116, 101, 120, 116, 41, 46, 32, 70, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 114, 97, 110, 100, 111, 109, 10, 97, 99, 99, 101, 115, 115, 44, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 39, 119, 43, 98, 39, 32, 111, 112, 101, 110, 115, 32, 97, 110, 100, 32, 116, 114, 117, 110, 99, 97, 116, 101, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 116, 111, 32, 48, 32, 98, 121, 116, 101, 115, 44, 32, 119, 104, 105, 108, 101, 10, 39, 114, 43, 98, 39, 32, 111, 112, 101, 110, 115, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 119, 105, 116, 104, 111, 117, 116, 32, 116, 114, 117, 110, 99, 97, 116, 105, 111, 110, 46, 10, 10, 80, 121, 116, 104, 111, 110, 32, 100, 105, 115, 116, 105, 110, 103, 117, 105, 115, 104, 101, 115, 32, 98, 101, 116, 119, 101, 101, 110, 32, 102, 105, 108, 101, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 97, 110, 100, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 115, 44, 10, 101, 118, 101, 110, 32, 119, 104, 101, 110, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 111, 112, 101, 114, 97, 116, 105, 110, 103, 32, 115, 121, 115, 116, 101, 109, 32, 100, 111, 101, 115, 110, 39, 116, 46, 32, 70, 105, 108, 101, 115, 32, 111, 112, 101, 110, 101, 100, 32, 105, 110, 10, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 40, 97, 112, 112, 101, 110, 100, 105, 110, 103, 32, 39, 98, 39, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 41, 32, 114, 101, 116, 117, 114, 110, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 97, 115, 10, 98, 121, 116, 101, 115, 32, 111, 98, 106, 101, 99, 116, 115, 32, 119, 105, 116, 104, 111, 117, 116, 32, 97, 110, 121, 32, 100, 101, 99, 111, 100, 105, 110, 103, 46, 32, 73, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 44, 32, 111, 114, 32, 119, 104, 101, 110, 10, 39, 116, 39, 32, 105, 115, 32, 97, 112, 112, 101, 110, 100, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 109, 111, 100, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 41, 44, 32, 116, 104, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 97, 114, 101, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 115, 116, 114, 105, 110, 103, 115, 44, 32, 116, 104, 101, 32, 98, 121, 116, 101, 115, 32, 104, 97, 118, 105, 110, 103, 32, 98, 101, 101, 110, 32, 102, 105, 114, 115, 116, 32, 100, 101, 99, 111, 100, 101, 100, 32, 117, 115, 105, 110, 103, 32, 97, 10, 112, 108, 97, 116, 102, 111, 114, 109, 45, 100, 101, 112, 101, 110, 100, 101, 110, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 111, 114, 32, 117, 115, 105, 110, 103, 32, 116, 104, 101, 32, 115, 112, 101, 99, 105, 102, 105, 101, 100, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 102, 32, 103, 105, 118, 101, 110, 46, 10, 10, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 105, 110, 116, 101, 103, 101, 114, 32, 117, 115, 101, 100, 32, 116, 111, 32, 115, 101, 116, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 112, 111, 108, 105, 99, 121, 46, 10, 80, 97, 115, 115, 32, 48, 32, 116, 111, 32, 115, 119, 105, 116, 99, 104, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 111, 102, 102, 32, 40, 111, 110, 108, 121, 32, 97, 108, 108, 111, 119, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 41, 44, 32, 49, 32, 116, 111, 32, 115, 101, 108, 101, 99, 116, 10, 108, 105, 110, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 40, 111, 110, 108, 121, 32, 117, 115, 97, 98, 108, 101, 32, 105, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 41, 44, 32, 97, 110, 100, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 32, 62, 32, 49, 32, 116, 111, 32, 105, 110, 100, 105, 99, 97, 116, 101, 10, 116, 104, 101, 32, 115, 105, 122, 101, 32, 111, 102, 32, 97, 32, 102, 105, 120, 101, 100, 45, 115, 105, 122, 101, 32, 99, 104, 117, 110, 107, 32, 98, 117, 102, 102, 101, 114, 46, 32, 32, 87, 104, 101, 110, 32, 110, 111, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 10, 103, 105, 118, 101, 110, 44, 32, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 112, 111, 108, 105, 99, 121, 32, 119, 111, 114, 107, 115, 32, 97, 115, 32, 102, 111, 108, 108, 111, 119, 115, 58, 10, 10, 42, 32, 66, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 32, 97, 114, 101, 32, 98, 117, 102, 102, 101, 114, 101, 100, 32, 105, 110, 32, 102, 105, 120, 101, 100, 45, 115, 105, 122, 101, 32, 99, 104, 117, 110, 107, 115, 59, 32, 116, 104, 101, 32, 115, 105, 122, 101, 32, 111, 102, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 10, 32, 32, 105, 115, 32, 99, 104, 111, 115, 101, 110, 32, 117, 115, 105, 110, 103, 32, 97, 32, 104, 101, 117, 114, 105, 115, 116, 105, 99, 32, 116, 114, 121, 105, 110, 103, 32, 116, 111, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 100, 101, 118, 105, 99, 101, 39, 115, 10, 32, 32, 34, 98, 108, 111, 99, 107, 32, 115, 105, 122, 101, 34, 32, 97, 110, 100, 32, 102, 97, 108, 108, 105, 110, 103, 32, 98, 97, 99, 107, 32, 111, 110, 32, 96, 105, 111, 46, 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 96, 46, 10, 32, 32, 79, 110, 32, 109, 97, 110, 121, 32, 115, 121, 115, 116, 101, 109, 115, 44, 32, 116, 104, 101, 32, 98, 117, 102, 102, 101, 114, 32, 119, 105, 108, 108, 32, 116, 121, 112, 105, 99, 97, 108, 108, 121, 32, 98, 101, 32, 52, 48, 57, 54, 32, 111, 114, 32, 56, 49, 57, 50, 32, 98, 121, 116, 101, 115, 32, 108, 111, 110, 103, 46, 10, 10, 42, 32, 34, 73, 110, 116, 101, 114, 97, 99, 116, 105, 118, 101, 34, 32, 116, 101, 120, 116, 32, 102, 105, 108, 101, 115, 32, 40, 102, 105, 108, 101, 115, 32, 102, 111, 114, 32, 119, 104, 105, 99, 104, 32, 105, 115, 97, 116, 116, 121, 40, 41, 32, 114, 101, 116, 117, 114, 110, 115, 32, 84, 114, 117, 101, 41, 10, 32, 32, 117, 115, 101, 32, 108, 105, 110, 101, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 46, 32, 32, 79, 116, 104, 101, 114, 32, 116, 101, 120, 116, 32, 102, 105, 108, 101, 115, 32, 117, 115, 101, 32, 116, 104, 101, 32, 112, 111, 108, 105, 99, 121, 32, 100, 101, 115, 99, 114, 105, 98, 101, 100, 32, 97, 98, 111, 118, 101, 10, 32, 32, 102, 111, 114, 32, 98, 105, 110, 97, 114, 121, 32, 102, 105, 108, 101, 115, 46, 10, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 111, 102, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 117, 115, 101, 100, 32, 116, 111, 32, 100, 101, 99, 111, 100, 101, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 32, 116, 104, 101, 10, 102, 105, 108, 101, 46, 32, 84, 104, 105, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 110, 108, 121, 32, 98, 101, 32, 117, 115, 101, 100, 32, 105, 110, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 46, 32, 84, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 105, 115, 10, 112, 108, 97, 116, 102, 111, 114, 109, 32, 100, 101, 112, 101, 110, 100, 101, 110, 116, 44, 32, 98, 117, 116, 32, 97, 110, 121, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 98, 121, 32, 80, 121, 116, 104, 111, 110, 32, 99, 97, 110, 32, 98, 101, 10, 112, 97, 115, 115, 101, 100, 46, 32, 32, 83, 101, 101, 32, 116, 104, 101, 32, 99, 111, 100, 101, 99, 115, 32, 109, 111, 100, 117, 108, 101, 32, 102, 111, 114, 32, 116, 104, 101, 32, 108, 105, 115, 116, 32, 111, 102, 32, 115, 117, 112, 112, 111, 114, 116, 101, 100, 32, 101, 110, 99, 111, 100, 105, 110, 103, 115, 46, 10, 10, 101, 114, 114, 111, 114, 115, 32, 105, 115, 32, 97, 110, 32, 111, 112, 116, 105, 111, 110, 97, 108, 32, 115, 116, 114, 105, 110, 103, 32, 116, 104, 97, 116, 32, 115, 112, 101, 99, 105, 102, 105, 101, 115, 32, 104, 111, 119, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 115, 32, 97, 114, 101, 32, 116, 111, 10, 98, 101, 32, 104, 97, 110, 100, 108, 101, 100, 45, 45, 45, 116, 104, 105, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 110, 111, 116, 32, 98, 101, 32, 117, 115, 101, 100, 32, 105, 110, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 46, 32, 80, 97, 115, 115, 10, 39, 115, 116, 114, 105, 99, 116, 39, 32, 116, 111, 32, 114, 97, 105, 115, 101, 32, 97, 32, 86, 97, 108, 117, 101, 69, 114, 114, 111, 114, 32, 101, 120, 99, 101, 112, 116, 105, 111, 110, 32, 105, 102, 32, 116, 104, 101, 114, 101, 32, 105, 115, 32, 97, 110, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 10, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 111, 102, 32, 78, 111, 110, 101, 32, 104, 97, 115, 32, 116, 104, 101, 32, 115, 97, 109, 101, 32, 101, 102, 102, 101, 99, 116, 41, 44, 32, 111, 114, 32, 112, 97, 115, 115, 32, 39, 105, 103, 110, 111, 114, 101, 39, 32, 116, 111, 32, 105, 103, 110, 111, 114, 101, 10, 101, 114, 114, 111, 114, 115, 46, 32, 40, 78, 111, 116, 101, 32, 116, 104, 97, 116, 32, 105, 103, 110, 111, 114, 105, 110, 103, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 115, 32, 99, 97, 110, 32, 108, 101, 97, 100, 32, 116, 111, 32, 100, 97, 116, 97, 32, 108, 111, 115, 115, 46, 41, 10, 83, 101, 101, 32, 116, 104, 101, 32, 100, 111, 99, 117, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 102, 111, 114, 32, 99, 111, 100, 101, 99, 115, 46, 114, 101, 103, 105, 115, 116, 101, 114, 32, 102, 111, 114, 32, 97, 32, 108, 105, 115, 116, 32, 111, 102, 32, 116, 104, 101, 32, 112, 101, 114, 109, 105, 116, 116, 101, 100, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 101, 114, 114, 111, 114, 32, 115, 116, 114, 105, 110, 103, 115, 46, 10, 10, 110, 101, 119, 108, 105, 110, 101, 32, 99, 111, 110, 116, 114, 111, 108, 115, 32, 104, 111, 119, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 119, 111, 114, 107, 115, 32, 40, 105, 116, 32, 111, 110, 108, 121, 32, 97, 112, 112, 108, 105, 101, 115, 32, 116, 111, 32, 116, 101, 120, 116, 10, 109, 111, 100, 101, 41, 46, 32, 73, 116, 32, 99, 97, 110, 32, 98, 101, 32, 78, 111, 110, 101, 44, 32, 39, 39, 44, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 97, 110, 100, 32, 39, 92, 114, 92, 110, 39, 46, 32, 32, 73, 116, 32, 119, 111, 114, 107, 115, 32, 97, 115, 10, 102, 111, 108, 108, 111, 119, 115, 58, 10, 10, 42, 32, 79, 110, 32, 105, 110, 112, 117, 116, 44, 32, 105, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 109, 111, 100, 101, 32, 105, 115, 10, 32, 32, 101, 110, 97, 98, 108, 101, 100, 46, 32, 76, 105, 110, 101, 115, 32, 105, 110, 32, 116, 104, 101, 32, 105, 110, 112, 117, 116, 32, 99, 97, 110, 32, 101, 110, 100, 32, 105, 110, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 111, 114, 32, 39, 92, 114, 92, 110, 39, 44, 32, 97, 110, 100, 10, 32, 32, 116, 104, 101, 115, 101, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 105, 110, 116, 111, 32, 39, 92, 110, 39, 32, 98, 101, 102, 111, 114, 101, 32, 98, 101, 105, 110, 103, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 32, 32, 99, 97, 108, 108, 101, 114, 46, 32, 73, 102, 32, 105, 116, 32, 105, 115, 32, 39, 39, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 109, 111, 100, 101, 32, 105, 115, 32, 101, 110, 97, 98, 108, 101, 100, 44, 32, 98, 117, 116, 32, 108, 105, 110, 101, 10, 32, 32, 101, 110, 100, 105, 110, 103, 115, 32, 97, 114, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 97, 108, 108, 101, 114, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 32, 73, 102, 32, 105, 116, 32, 104, 97, 115, 32, 97, 110, 121, 32, 111, 102, 10, 32, 32, 116, 104, 101, 32, 111, 116, 104, 101, 114, 32, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 105, 110, 112, 117, 116, 32, 108, 105, 110, 101, 115, 32, 97, 114, 101, 32, 111, 110, 108, 121, 32, 116, 101, 114, 109, 105, 110, 97, 116, 101, 100, 32, 98, 121, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 10, 32, 32, 115, 116, 114, 105, 110, 103, 44, 32, 97, 110, 100, 32, 116, 104, 101, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 99, 97, 108, 108, 101, 114, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 10, 10, 42, 32, 79, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 105, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 97, 110, 121, 32, 39, 92, 110, 39, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 97, 114, 101, 10, 32, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 115, 121, 115, 116, 101, 109, 32, 100, 101, 102, 97, 117, 108, 116, 32, 108, 105, 110, 101, 32, 115, 101, 112, 97, 114, 97, 116, 111, 114, 44, 32, 111, 115, 46, 108, 105, 110, 101, 115, 101, 112, 46, 32, 73, 102, 10, 32, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 39, 39, 44, 32, 110, 111, 32, 116, 114, 97, 110, 115, 108, 97, 116, 105, 111, 110, 32, 116, 97, 107, 101, 115, 32, 112, 108, 97, 99, 101, 46, 32, 73, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 97, 110, 121, 32, 111, 102, 32, 116, 104, 101, 10, 32, 32, 111, 116, 104, 101, 114, 32, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 97, 110, 121, 32, 39, 92, 110, 39, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 10, 32, 32, 116, 104, 101, 32, 103, 105, 118, 101, 110, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 99, 108, 111, 115, 101, 102, 100, 32, 105, 115, 32, 70, 97, 108, 115, 101, 44, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 102, 105, 108, 101, 32, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 32, 119, 105, 108, 108, 32, 98, 101, 32, 107, 101, 112, 116, 32, 111, 112, 101, 110, 10, 119, 104, 101, 110, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 46, 32, 84, 104, 105, 115, 32, 100, 111, 101, 115, 32, 110, 111, 116, 32, 119, 111, 114, 107, 32, 119, 104, 101, 110, 32, 97, 32, 102, 105, 108, 101, 32, 110, 97, 109, 101, 32, 105, 115, 32, 103, 105, 118, 101, 110, 10, 97, 110, 100, 32, 109, 117, 115, 116, 32, 98, 101, 32, 84, 114, 117, 101, 32, 105, 110, 32, 116, 104, 97, 116, 32, 99, 97, 115, 101, 46, 10, 10, 111, 112, 101, 110, 40, 41, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 102, 105, 108, 101, 32, 111, 98, 106, 101, 99, 116, 32, 119, 104, 111, 115, 101, 32, 116, 121, 112, 101, 32, 100, 101, 112, 101, 110, 100, 115, 32, 111, 110, 32, 116, 104, 101, 32, 109, 111, 100, 101, 44, 32, 97, 110, 100, 10, 116, 104, 114, 111, 117, 103, 104, 32, 119, 104, 105, 99, 104, 32, 116, 104, 101, 32, 115, 116, 97, 110, 100, 97, 114, 100, 32, 102, 105, 108, 101, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 115, 32, 115, 117, 99, 104, 32, 97, 115, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 10, 97, 114, 101, 32, 112, 101, 114, 102, 111, 114, 109, 101, 100, 46, 32, 87, 104, 101, 110, 32, 111, 112, 101, 110, 40, 41, 32, 105, 115, 32, 117, 115, 101, 100, 32, 116, 111, 32, 111, 112, 101, 110, 32, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 97, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 32, 40, 39, 119, 39, 44, 10, 39, 114, 39, 44, 32, 39, 119, 116, 39, 44, 32, 39, 114, 116, 39, 44, 32, 101, 116, 99, 46, 41, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 46, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 116, 111, 32, 111, 112, 101, 110, 10, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 97, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 44, 32, 116, 104, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 99, 108, 97, 115, 115, 32, 118, 97, 114, 105, 101, 115, 58, 32, 105, 110, 32, 114, 101, 97, 100, 32, 98, 105, 110, 97, 114, 121, 10, 109, 111, 100, 101, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 59, 32, 105, 110, 32, 119, 114, 105, 116, 101, 32, 98, 105, 110, 97, 114, 121, 32, 97, 110, 100, 32, 97, 112, 112, 101, 110, 100, 32, 98, 105, 110, 97, 114, 121, 10, 109, 111, 100, 101, 115, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 44, 32, 97, 110, 100, 32, 105, 110, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 32, 109, 111, 100, 101, 44, 32, 105, 116, 32, 114, 101, 116, 117, 114, 110, 115, 10, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 46, 10, 10, 73, 116, 32, 105, 115, 32, 97, 108, 115, 111, 32, 112, 111, 115, 115, 105, 98, 108, 101, 32, 116, 111, 32, 117, 115, 101, 32, 97, 32, 115, 116, 114, 105, 110, 103, 32, 111, 114, 32, 98, 121, 116, 101, 97, 114, 114, 97, 121, 32, 97, 115, 32, 97, 32, 102, 105, 108, 101, 32, 102, 111, 114, 32, 98, 111, 116, 104, 10, 114, 101, 97, 100, 105, 110, 103, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 46, 32, 70, 111, 114, 32, 115, 116, 114, 105, 110, 103, 115, 32, 83, 116, 114, 105, 110, 103, 73, 79, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 108, 105, 107, 101, 32, 97, 32, 102, 105, 108, 101, 10, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 116, 101, 120, 116, 32, 109, 111, 100, 101, 44, 32, 97, 110, 100, 32, 102, 111, 114, 32, 98, 121, 116, 101, 115, 32, 97, 32, 66, 121, 116, 101, 115, 73, 79, 32, 99, 97, 110, 32, 98, 101, 32, 117, 115, 101, 100, 32, 108, 105, 107, 101, 32, 97, 32, 102, 105, 108, 101, 10, 111, 112, 101, 110, 101, 100, 32, 105, 110, 32, 97, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _C_6_8496 = allocate(32, "i8*", ALLOC_NORMAL);
    __str6239 = allocate([ 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str7240 = allocate([ 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str8241 = allocate([ 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str9242 = allocate([ 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str10243 = allocate([ 101, 114, 114, 111, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    __str11244 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str12245 = allocate([ 99, 108, 111, 115, 101, 102, 100, 0 ], "i8", ALLOC_NORMAL);
    __str13246 = allocate([ 114, 0 ], "i8", ALLOC_NORMAL);
    __str14247 = allocate([ 79, 124, 115, 105, 122, 122, 122, 105, 58, 111, 112, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    __str15248 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 102, 105, 108, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str16249 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 109, 111, 100, 101, 58, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str17250 = allocate([ 99, 97, 110, 39, 116, 32, 117, 115, 101, 32, 85, 32, 97, 110, 100, 32, 119, 114, 105, 116, 105, 110, 103, 32, 109, 111, 100, 101, 32, 97, 116, 32, 111, 110, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str18251 = allocate([ 99, 97, 110, 39, 116, 32, 104, 97, 118, 101, 32, 116, 101, 120, 116, 32, 97, 110, 100, 32, 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 97, 116, 32, 111, 110, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str19252 = allocate([ 109, 117, 115, 116, 32, 104, 97, 118, 101, 32, 101, 120, 97, 99, 116, 108, 121, 32, 111, 110, 101, 32, 111, 102, 32, 114, 101, 97, 100, 47, 119, 114, 105, 116, 101, 47, 97, 112, 112, 101, 110, 100, 32, 109, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str20253 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 110, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str21254 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 110, 32, 101, 114, 114, 111, 114, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str22255 = allocate([ 98, 105, 110, 97, 114, 121, 32, 109, 111, 100, 101, 32, 100, 111, 101, 115, 110, 39, 116, 32, 116, 97, 107, 101, 32, 97, 32, 110, 101, 119, 108, 105, 110, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 0 ], "i8", ALLOC_NORMAL);
    __str23256 = allocate([ 79, 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str24257 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str25258 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str26259 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 115, 105, 122, 101, 0 ], "i8", ALLOC_NORMAL);
    __str27260 = allocate([ 99, 97, 110, 39, 116, 32, 104, 97, 118, 101, 32, 117, 110, 98, 117, 102, 102, 101, 114, 101, 100, 32, 116, 101, 120, 116, 32, 73, 47, 79, 0 ], "i8", ALLOC_NORMAL);
    __str28261 = allocate([ 117, 110, 107, 110, 111, 119, 110, 32, 109, 111, 100, 101, 58, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str29262 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30263 = allocate([ 79, 115, 115, 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str31264 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 118, 97, 108, 117, 101, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 52, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8759 = allocate([ 80, 121, 78, 117, 109, 98, 101, 114, 95, 65, 115, 79, 102, 102, 95, 116, 0 ], "i8", ALLOC_NORMAL);
    __str32265 = allocate([ 99, 97, 110, 110, 111, 116, 32, 102, 105, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 32, 105, 110, 116, 111, 32, 97, 110, 32, 111, 102, 102, 115, 101, 116, 45, 115, 105, 122, 101, 100, 32, 105, 110, 116, 101, 103, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str33266 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_os_module = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_locale_module = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_unsupported_operation = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str34268 = allocate([ 111, 112, 101, 110, 0 ], "i8", ALLOC_NORMAL);
    _module_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str35269 = allocate([ 95, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    __str36270 = allocate([ 111, 115, 0 ], "i8", ALLOC_NORMAL);
    __str37271 = allocate([ 68, 69, 70, 65, 85, 76, 84, 95, 66, 85, 70, 70, 69, 82, 95, 83, 73, 90, 69, 0 ], "i8", ALLOC_NORMAL);
    __str38272 = allocate([ 115, 40, 79, 79, 41, 123, 125, 0 ], "i8", ALLOC_NORMAL);
    __str39273 = allocate([ 85, 110, 115, 117, 112, 112, 111, 114, 116, 101, 100, 79, 112, 101, 114, 97, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str40274 = allocate([ 95, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41275 = allocate([ 95, 82, 97, 119, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42276 = allocate([ 95, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str43277 = allocate([ 95, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44278 = allocate([ 70, 105, 108, 101, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str45279 = allocate([ 66, 121, 116, 101, 115, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str46280 = allocate([ 83, 116, 114, 105, 110, 103, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    __str47281 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 101, 97, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str48282 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 87, 114, 105, 116, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str49283 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 87, 80, 97, 105, 114, 0 ], "i8", ALLOC_NORMAL);
    __str50284 = allocate([ 66, 117, 102, 102, 101, 114, 101, 100, 82, 97, 110, 100, 111, 109, 0 ], "i8", ALLOC_NORMAL);
    __str51285 = allocate([ 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str52286 = allocate([ 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str53287 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_close = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str54289 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_closed = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str55291 = allocate([ 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_decode = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str56292 = allocate([ 101, 110, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_encode = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_str_fileno = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str57294 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_flush = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str58296 = allocate([ 103, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_getstate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_str_isatty = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str59298 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_newlines = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str60299 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_nl = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str61300 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_read = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str62302 = allocate([ 114, 101, 97, 100, 49, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_read1 = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str63303 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str64305 = allocate([ 114, 101, 97, 100, 105, 110, 116, 111, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readinto = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str65307 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_readline = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str66309 = allocate([ 114, 101, 115, 101, 116, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_reset = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str67 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_seek = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str68 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_seekable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str69 = allocate([ 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_setstate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str70 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_tell = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str71 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_truncate = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str72 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_write = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __str73 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __PyIO_str_writable = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_empty_str = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_empty_bytes = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    __PyIO_zero = allocate(1, "%struct.PyObject*", ALLOC_NORMAL);
    _stringio_doc = allocate([ 84, 101, 120, 116, 32, 73, 47, 79, 32, 105, 109, 112, 108, 101, 109, 101, 110, 116, 97, 116, 105, 111, 110, 32, 117, 115, 105, 110, 103, 32, 97, 110, 32, 105, 110, 45, 109, 101, 109, 111, 114, 121, 32, 98, 117, 102, 102, 101, 114, 46, 10, 10, 84, 104, 101, 32, 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 101, 116, 115, 32, 116, 104, 101, 32, 118, 97, 108, 117, 101, 32, 111, 102, 32, 111, 98, 106, 101, 99, 116, 46, 32, 32, 84, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 10, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 108, 105, 107, 101, 32, 116, 104, 101, 32, 111, 110, 101, 32, 111, 102, 32, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 39, 115, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    __str319 = allocate([ 115, 101, 108, 102, 45, 62, 98, 117, 102, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str1320 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 115, 116, 114, 105, 110, 103, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8390 = allocate([ 114, 101, 115, 105, 122, 101, 95, 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str2321 = allocate([ 110, 101, 119, 32, 98, 117, 102, 102, 101, 114, 32, 115, 105, 122, 101, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8432 = allocate([ 119, 114, 105, 116, 101, 95, 115, 116, 114, 0 ], "i8", ALLOC_NORMAL);
    __str3322 = allocate([ 115, 101, 108, 102, 45, 62, 112, 111, 115, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str4323 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 100, 101, 99, 111, 100, 101, 100, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 56, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str5324 = allocate([ 108, 101, 110, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    __str6325 = allocate([ 110, 101, 119, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 116, 111, 111, 32, 108, 97, 114, 103, 101, 0 ], "i8", ALLOC_NORMAL);
    _stringio_getvalue_doc = allocate([ 82, 101, 116, 114, 105, 101, 118, 101, 32, 116, 104, 101, 32, 101, 110, 116, 105, 114, 101, 32, 99, 111, 110, 116, 101, 110, 116, 115, 32, 111, 102, 32, 116, 104, 101, 32, 111, 98, 106, 101, 99, 116, 46, 0 ], "i8", ALLOC_NORMAL);
    __str7326 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 117, 110, 105, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 32, 111, 98, 106, 101, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str8327 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    _stringio_tell_doc = allocate([ 84, 101, 108, 108, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 0 ], "i8", ALLOC_NORMAL);
    _stringio_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 44, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 115, 32, 97, 32, 115, 116, 114, 105, 110, 103, 46, 10, 10, 73, 102, 32, 116, 104, 101, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 10, 105, 115, 32, 114, 101, 97, 99, 104, 101, 100, 46, 32, 82, 101, 116, 117, 114, 110, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 97, 116, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str9328 = allocate([ 124, 79, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str10329 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str11330 = allocate(1, "i8", ALLOC_NORMAL);
    _stringio_readline_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 111, 114, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 105, 102, 32, 69, 79, 70, 32, 105, 115, 32, 104, 105, 116, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str12331 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str13332 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 110, 32, 115, 116, 114, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    _stringio_truncate_doc = allocate([ 84, 114, 117, 110, 99, 97, 116, 101, 32, 115, 105, 122, 101, 32, 116, 111, 32, 112, 111, 115, 46, 10, 10, 84, 104, 101, 32, 112, 111, 115, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 116, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 44, 32, 97, 115, 10, 114, 101, 116, 117, 114, 110, 101, 100, 32, 98, 121, 32, 116, 101, 108, 108, 40, 41, 46, 32, 32, 84, 104, 101, 32, 99, 117, 114, 114, 101, 110, 116, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 115, 32, 117, 110, 99, 104, 97, 110, 103, 101, 100, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str14333 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str15334 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 115, 105, 122, 101, 32, 118, 97, 108, 117, 101, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    _stringio_seek_doc = allocate([ 67, 104, 97, 110, 103, 101, 32, 115, 116, 114, 101, 97, 109, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 10, 83, 101, 101, 107, 32, 116, 111, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 111, 102, 102, 115, 101, 116, 32, 112, 111, 115, 32, 114, 101, 108, 97, 116, 105, 118, 101, 32, 116, 111, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 105, 110, 100, 105, 99, 97, 116, 101, 100, 32, 98, 121, 32, 119, 104, 101, 110, 99, 101, 58, 10, 32, 32, 32, 32, 48, 32, 32, 83, 116, 97, 114, 116, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 40, 116, 104, 101, 32, 100, 101, 102, 97, 117, 108, 116, 41, 46, 32, 32, 112, 111, 115, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 62, 61, 32, 48, 59, 10, 32, 32, 32, 32, 49, 32, 32, 67, 117, 114, 114, 101, 110, 116, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 45, 32, 112, 111, 115, 32, 109, 117, 115, 116, 32, 98, 101, 32, 48, 59, 10, 32, 32, 32, 32, 50, 32, 32, 69, 110, 100, 32, 111, 102, 32, 115, 116, 114, 101, 97, 109, 32, 45, 32, 112, 111, 115, 32, 109, 117, 115, 116, 32, 98, 101, 32, 48, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 101, 119, 32, 97, 98, 115, 111, 108, 117, 116, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str16335 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str17336 = allocate([ 73, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 105, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str18337 = allocate([ 78, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 122, 100, 0 ], "i8", ALLOC_NORMAL);
    __str19338 = allocate([ 67, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 99, 117, 114, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    _stringio_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 116, 111, 32, 102, 105, 108, 101, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 44, 32, 119, 104, 105, 99, 104, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 101, 113, 117, 97, 108, 32, 116, 111, 10, 116, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 101, 32, 115, 116, 114, 105, 110, 103, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str20339 = allocate([ 115, 116, 114, 105, 110, 103, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    _stringio_close_doc = allocate([ 67, 108, 111, 115, 101, 32, 116, 104, 101, 32, 73, 79, 32, 111, 98, 106, 101, 99, 116, 46, 32, 65, 116, 116, 101, 109, 112, 116, 105, 110, 103, 32, 97, 110, 121, 32, 102, 117, 114, 116, 104, 101, 114, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 97, 102, 116, 101, 114, 32, 116, 104, 101, 10, 111, 98, 106, 101, 99, 116, 32, 105, 115, 32, 99, 108, 111, 115, 101, 100, 32, 119, 105, 108, 108, 32, 114, 97, 105, 115, 101, 32, 97, 32, 86, 97, 108, 117, 101, 69, 114, 114, 111, 114, 46, 10, 10, 84, 104, 105, 115, 32, 109, 101, 116, 104, 111, 100, 32, 104, 97, 115, 32, 110, 111, 32, 101, 102, 102, 101, 99, 116, 32, 105, 102, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 97, 108, 114, 101, 97, 100, 121, 32, 99, 108, 111, 115, 101, 100, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str21340 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8969 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str22341 = allocate([ 116, 121, 112, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 38, 38, 32, 116, 121, 112, 101, 45, 62, 116, 112, 95, 97, 108, 108, 111, 99, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9039 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 110, 101, 119, 0 ], "i8", ALLOC_NORMAL);
    _C_71_9078 = allocate(12, "i8*", ALLOC_NORMAL);
    __str23342 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str24343 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str25344 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __str26345 = allocate([ 124, 79, 122, 58, 95, 95, 105, 110, 105, 116, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str27346 = allocate([ 105, 108, 108, 101, 103, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 118, 97, 108, 117, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str28347 = allocate([ 105, 110, 105, 116, 105, 97, 108, 95, 118, 97, 108, 117, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 117, 110, 105, 99, 111, 100, 101, 32, 111, 114, 32, 78, 111, 110, 101, 44, 32, 110, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str29348 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str30349 = allocate([ 40, 79, 79, 110, 78, 41, 0 ], "i8", ALLOC_NORMAL);
    __str31350 = allocate([ 115, 116, 97, 116, 101, 32, 33, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9300 = allocate([ 115, 116, 114, 105, 110, 103, 105, 111, 95, 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str32351 = allocate([ 37, 46, 50, 48, 48, 115, 46, 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 52, 45, 116, 117, 112, 108, 101, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str33352 = allocate([ 116, 104, 105, 114, 100, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 109, 117, 115, 116, 32, 98, 101, 32, 97, 110, 32, 105, 110, 116, 101, 103, 101, 114, 44, 32, 103, 111, 116, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str34353 = allocate([ 112, 111, 115, 105, 116, 105, 111, 110, 32, 118, 97, 108, 117, 101, 32, 99, 97, 110, 110, 111, 116, 32, 98, 101, 32, 110, 101, 103, 97, 116, 105, 118, 101, 0 ], "i8", ALLOC_NORMAL);
    __str35354 = allocate([ 102, 111, 117, 114, 116, 104, 32, 105, 116, 101, 109, 32, 111, 102, 32, 115, 116, 97, 116, 101, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 97, 32, 100, 105, 99, 116, 44, 32, 103, 111, 116, 32, 97, 32, 37, 46, 50, 48, 48, 115, 0 ], "i8", ALLOC_NORMAL);
    __str36355 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37356 = allocate([ 103, 101, 116, 118, 97, 108, 117, 101, 0 ], "i8", ALLOC_NORMAL);
    __str38357 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str39358 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str40359 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str41360 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str42361 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str43362 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44363 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str45364 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str46365 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str47366 = allocate([ 95, 95, 103, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    __str48367 = allocate([ 95, 95, 115, 101, 116, 115, 116, 97, 116, 101, 95, 95, 0 ], "i8", ALLOC_NORMAL);
    _stringio_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str49368 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str50369 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str51370 = allocate([ 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    _stringio_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str52371 = allocate([ 95, 105, 111, 46, 83, 116, 114, 105, 110, 103, 73, 79, 0 ], "i8", ALLOC_NORMAL);
    _PyStringIO_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiobase_doc = allocate([ 66, 97, 115, 101, 32, 99, 108, 97, 115, 115, 32, 102, 111, 114, 32, 116, 101, 120, 116, 32, 73, 47, 79, 46, 10, 10, 84, 104, 105, 115, 32, 99, 108, 97, 115, 115, 32, 112, 114, 111, 118, 105, 100, 101, 115, 32, 97, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 97, 110, 100, 32, 108, 105, 110, 101, 32, 98, 97, 115, 101, 100, 32, 105, 110, 116, 101, 114, 102, 97, 99, 101, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 10, 73, 47, 79, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 114, 101, 97, 100, 105, 110, 116, 111, 32, 109, 101, 116, 104, 111, 100, 32, 98, 101, 99, 97, 117, 115, 101, 32, 80, 121, 116, 104, 111, 110, 39, 115, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 32, 115, 116, 114, 105, 110, 103, 115, 10, 97, 114, 101, 32, 105, 109, 109, 117, 116, 97, 98, 108, 101, 46, 32, 84, 104, 101, 114, 101, 32, 105, 115, 32, 110, 111, 32, 112, 117, 98, 108, 105, 99, 32, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_detach_doc = allocate([ 83, 101, 112, 97, 114, 97, 116, 101, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 102, 114, 111, 109, 32, 116, 104, 101, 32, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 32, 97, 110, 100, 32, 114, 101, 116, 117, 114, 110, 32, 105, 116, 46, 10, 10, 65, 102, 116, 101, 114, 32, 116, 104, 101, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 44, 32, 116, 104, 101, 32, 84, 101, 120, 116, 73, 79, 32, 105, 115, 32, 105, 110, 32, 97, 110, 10, 117, 110, 117, 115, 97, 98, 108, 101, 32, 115, 116, 97, 116, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str374 = allocate([ 100, 101, 116, 97, 99, 104, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_read_doc = allocate([ 82, 101, 97, 100, 32, 97, 116, 32, 109, 111, 115, 116, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 102, 114, 111, 109, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 82, 101, 97, 100, 32, 102, 114, 111, 109, 32, 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 117, 110, 116, 105, 108, 32, 119, 101, 32, 104, 97, 118, 101, 32, 110, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 111, 114, 32, 119, 101, 32, 104, 105, 116, 32, 69, 79, 70, 46, 10, 73, 102, 32, 110, 32, 105, 115, 32, 110, 101, 103, 97, 116, 105, 118, 101, 32, 111, 114, 32, 111, 109, 105, 116, 116, 101, 100, 44, 32, 114, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 69, 79, 70, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str1375 = allocate([ 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_readline_doc = allocate([ 82, 101, 97, 100, 32, 117, 110, 116, 105, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 111, 114, 32, 69, 79, 70, 46, 10, 10, 82, 101, 116, 117, 114, 110, 115, 32, 97, 110, 32, 101, 109, 112, 116, 121, 32, 115, 116, 114, 105, 110, 103, 32, 105, 102, 32, 69, 79, 70, 32, 105, 115, 32, 104, 105, 116, 32, 105, 109, 109, 101, 100, 105, 97, 116, 101, 108, 121, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str2376 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_write_doc = allocate([ 87, 114, 105, 116, 101, 32, 115, 116, 114, 105, 110, 103, 32, 116, 111, 32, 115, 116, 114, 101, 97, 109, 46, 10, 82, 101, 116, 117, 114, 110, 115, 32, 116, 104, 101, 32, 110, 117, 109, 98, 101, 114, 32, 111, 102, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 115, 32, 119, 114, 105, 116, 116, 101, 110, 32, 40, 119, 104, 105, 99, 104, 32, 105, 115, 32, 97, 108, 119, 97, 121, 115, 32, 101, 113, 117, 97, 108, 32, 116, 111, 10, 116, 104, 101, 32, 108, 101, 110, 103, 116, 104, 32, 111, 102, 32, 116, 104, 101, 32, 115, 116, 114, 105, 110, 103, 41, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    __str3377 = allocate([ 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_encoding_doc = allocate([ 69, 110, 99, 111, 100, 105, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 116, 101, 120, 116, 32, 115, 116, 114, 101, 97, 109, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_newlines_doc = allocate([ 76, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 115, 111, 32, 102, 97, 114, 46, 10, 10, 79, 110, 108, 121, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 100, 117, 114, 105, 110, 103, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 114, 101, 32, 99, 111, 110, 115, 105, 100, 101, 114, 101, 100, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_errors_doc = allocate([ 84, 104, 101, 32, 101, 114, 114, 111, 114, 32, 115, 101, 116, 116, 105, 110, 103, 32, 111, 102, 32, 116, 104, 101, 32, 100, 101, 99, 111, 100, 101, 114, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 114, 46, 10, 10, 83, 117, 98, 99, 108, 97, 115, 115, 101, 115, 32, 115, 104, 111, 117, 108, 100, 32, 111, 118, 101, 114, 114, 105, 100, 101, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str4378 = allocate([ 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str5379 = allocate([ 110, 101, 119, 108, 105, 110, 101, 115, 0 ], "i8", ALLOC_NORMAL);
    __str6380 = allocate([ 101, 114, 114, 111, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    _textiobase_getset = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str7381 = allocate([ 95, 105, 111, 46, 95, 84, 101, 120, 116, 73, 79, 66, 97, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    _PyTextIOBase_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _incrementalnewlinedecoder_doc = allocate([ 67, 111, 100, 101, 99, 32, 117, 115, 101, 100, 32, 119, 104, 101, 110, 32, 114, 101, 97, 100, 105, 110, 103, 32, 97, 32, 102, 105, 108, 101, 32, 105, 110, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 109, 111, 100, 101, 46, 32, 32, 73, 116, 32, 119, 114, 97, 112, 115, 10, 97, 110, 111, 116, 104, 101, 114, 32, 105, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 32, 100, 101, 99, 111, 100, 101, 114, 44, 32, 116, 114, 97, 110, 115, 108, 97, 116, 105, 110, 103, 32, 92, 114, 92, 110, 32, 97, 110, 100, 32, 92, 114, 32, 105, 110, 116, 111, 32, 92, 110, 46, 32, 32, 73, 116, 32, 97, 108, 115, 111, 10, 114, 101, 99, 111, 114, 100, 115, 32, 116, 104, 101, 32, 116, 121, 112, 101, 115, 32, 111, 102, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 101, 110, 99, 111, 117, 110, 116, 101, 114, 101, 100, 46, 32, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 119, 105, 116, 104, 10, 116, 114, 97, 110, 115, 108, 97, 116, 101, 61, 70, 97, 108, 115, 101, 44, 32, 105, 116, 32, 101, 110, 115, 117, 114, 101, 115, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 32, 115, 101, 113, 117, 101, 110, 99, 101, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 105, 110, 10, 111, 110, 101, 32, 112, 105, 101, 99, 101, 46, 32, 87, 104, 101, 110, 32, 117, 115, 101, 100, 32, 119, 105, 116, 104, 32, 100, 101, 99, 111, 100, 101, 114, 61, 78, 111, 110, 101, 44, 32, 105, 116, 32, 101, 120, 112, 101, 99, 116, 115, 32, 117, 110, 105, 99, 111, 100, 101, 32, 115, 116, 114, 105, 110, 103, 115, 32, 97, 115, 10, 100, 101, 99, 111, 100, 101, 32, 105, 110, 112, 117, 116, 32, 97, 110, 100, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 115, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 119, 105, 116, 104, 111, 117, 116, 32, 102, 105, 114, 115, 116, 32, 105, 110, 118, 111, 107, 105, 110, 103, 32, 97, 110, 32, 101, 120, 116, 101, 114, 110, 97, 108, 10, 100, 101, 99, 111, 100, 101, 114, 46, 10, 0 ], "i8", ALLOC_NORMAL);
    _C_1_8453 = allocate(16, "i8*", ALLOC_NORMAL);
    __str8383 = allocate([ 100, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str9384 = allocate([ 116, 114, 97, 110, 115, 108, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str10385 = allocate([ 79, 105, 124, 79, 58, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str11386 = allocate([ 115, 116, 114, 105, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str12387 = allocate([ 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 46, 95, 95, 105, 110, 105, 116, 95, 95, 32, 110, 111, 116, 32, 99, 97, 108, 108, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str13388 = allocate([ 100, 101, 99, 111, 100, 101, 114, 32, 115, 104, 111, 117, 108, 100, 32, 114, 101, 116, 117, 114, 110, 32, 97, 32, 115, 116, 114, 105, 110, 103, 32, 114, 101, 115, 117, 108, 116, 0 ], "i8", ALLOC_NORMAL);
    __str14389 = allocate([ 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 41, 41, 45, 62, 111, 98, 95, 114, 101, 102, 99, 110, 116, 41, 32, 61, 61, 32, 49, 0 ], "i8", ALLOC_NORMAL);
    __str15390 = allocate([ 46, 46, 47, 99, 112, 121, 116, 104, 111, 110, 47, 77, 111, 100, 117, 108, 101, 115, 47, 95, 105, 111, 47, 116, 101, 120, 116, 105, 111, 46, 99, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___8544 = allocate([ 95, 80, 121, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 95, 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    _C_56_8766 = allocate(12, "i8*", ALLOC_NORMAL);
    __str16391 = allocate([ 105, 110, 112, 117, 116, 0 ], "i8", ALLOC_NORMAL);
    __str17392 = allocate([ 102, 105, 110, 97, 108, 0 ], "i8", ALLOC_NORMAL);
    __str18393 = allocate([ 79, 124, 105, 58, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str19394 = allocate([ 40, 79, 75, 41, 0 ], "i8", ALLOC_NORMAL);
    __str20395 = allocate(1, "i8", ALLOC_NORMAL);
    __str21396 = allocate([ 78, 75, 0 ], "i8", ALLOC_NORMAL);
    __str22397 = allocate([ 115, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str23398 = allocate([ 40, 40, 79, 75, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    __str24399 = allocate([ 13, 0 ], "i8", ALLOC_NORMAL);
    __str25400 = allocate([ 10, 0 ], "i8", ALLOC_NORMAL);
    __str26401 = allocate([ 13, 10, 0 ], "i8", ALLOC_NORMAL);
    __str27402 = allocate([ 115, 115, 0 ], "i8", ALLOC_NORMAL);
    __str28403 = allocate([ 115, 115, 115, 0 ], "i8", ALLOC_NORMAL);
    __str29404 = allocate([ 100, 101, 99, 111, 100, 101, 0 ], "i8", ALLOC_NORMAL);
    __str30405 = allocate([ 103, 101, 116, 115, 116, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str31406 = allocate([ 114, 101, 115, 101, 116, 0 ], "i8", ALLOC_NORMAL);
    _incrementalnewlinedecoder_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _incrementalnewlinedecoder_getset = allocate(40, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str32407 = allocate([ 95, 105, 111, 46, 73, 110, 99, 114, 101, 109, 101, 110, 116, 97, 108, 78, 101, 119, 108, 105, 110, 101, 68, 101, 99, 111, 100, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyIncrementalNewlineDecoder_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132587, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiowrapper_doc = allocate([ 67, 104, 97, 114, 97, 99, 116, 101, 114, 32, 97, 110, 100, 32, 108, 105, 110, 101, 32, 98, 97, 115, 101, 100, 32, 108, 97, 121, 101, 114, 32, 111, 118, 101, 114, 32, 97, 32, 66, 117, 102, 102, 101, 114, 101, 100, 73, 79, 66, 97, 115, 101, 32, 111, 98, 106, 101, 99, 116, 44, 32, 98, 117, 102, 102, 101, 114, 46, 10, 10, 101, 110, 99, 111, 100, 105, 110, 103, 32, 103, 105, 118, 101, 115, 32, 116, 104, 101, 32, 110, 97, 109, 101, 32, 111, 102, 32, 116, 104, 101, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 116, 104, 97, 116, 32, 116, 104, 101, 32, 115, 116, 114, 101, 97, 109, 32, 119, 105, 108, 108, 32, 98, 101, 10, 100, 101, 99, 111, 100, 101, 100, 32, 111, 114, 32, 101, 110, 99, 111, 100, 101, 100, 32, 119, 105, 116, 104, 46, 32, 73, 116, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 108, 111, 99, 97, 108, 101, 46, 103, 101, 116, 112, 114, 101, 102, 101, 114, 114, 101, 100, 101, 110, 99, 111, 100, 105, 110, 103, 46, 10, 10, 101, 114, 114, 111, 114, 115, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 115, 32, 116, 104, 101, 32, 115, 116, 114, 105, 99, 116, 110, 101, 115, 115, 32, 111, 102, 32, 101, 110, 99, 111, 100, 105, 110, 103, 32, 97, 110, 100, 32, 100, 101, 99, 111, 100, 105, 110, 103, 32, 40, 115, 101, 101, 32, 116, 104, 101, 10, 99, 111, 100, 101, 99, 115, 46, 114, 101, 103, 105, 115, 116, 101, 114, 41, 32, 97, 110, 100, 32, 100, 101, 102, 97, 117, 108, 116, 115, 32, 116, 111, 32, 34, 115, 116, 114, 105, 99, 116, 34, 46, 10, 10, 110, 101, 119, 108, 105, 110, 101, 32, 99, 97, 110, 32, 98, 101, 32, 78, 111, 110, 101, 44, 32, 39, 39, 44, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 32, 111, 114, 32, 39, 92, 114, 92, 110, 39, 46, 32, 32, 73, 116, 32, 99, 111, 110, 116, 114, 111, 108, 115, 32, 116, 104, 101, 10, 104, 97, 110, 100, 108, 105, 110, 103, 32, 111, 102, 32, 108, 105, 110, 101, 32, 101, 110, 100, 105, 110, 103, 115, 46, 32, 73, 102, 32, 105, 116, 32, 105, 115, 32, 78, 111, 110, 101, 44, 32, 117, 110, 105, 118, 101, 114, 115, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 115, 32, 105, 115, 10, 101, 110, 97, 98, 108, 101, 100, 46, 32, 32, 87, 105, 116, 104, 32, 116, 104, 105, 115, 32, 101, 110, 97, 98, 108, 101, 100, 44, 32, 111, 110, 32, 105, 110, 112, 117, 116, 44, 32, 116, 104, 101, 32, 108, 105, 110, 101, 115, 32, 101, 110, 100, 105, 110, 103, 115, 32, 39, 92, 110, 39, 44, 32, 39, 92, 114, 39, 44, 10, 111, 114, 32, 39, 92, 114, 92, 110, 39, 32, 97, 114, 101, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 39, 92, 110, 39, 32, 98, 101, 102, 111, 114, 101, 32, 98, 101, 105, 110, 103, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 99, 97, 108, 108, 101, 114, 46, 32, 67, 111, 110, 118, 101, 114, 115, 101, 108, 121, 44, 32, 111, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 39, 92, 110, 39, 32, 105, 115, 32, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 32, 115, 121, 115, 116, 101, 109, 10, 100, 101, 102, 97, 117, 108, 116, 32, 108, 105, 110, 101, 32, 115, 101, 112, 101, 114, 97, 116, 111, 114, 44, 32, 111, 115, 46, 108, 105, 110, 101, 115, 101, 112, 46, 32, 73, 102, 32, 110, 101, 119, 108, 105, 110, 101, 32, 105, 115, 32, 97, 110, 121, 32, 111, 116, 104, 101, 114, 32, 111, 102, 32, 105, 116, 115, 10, 108, 101, 103, 97, 108, 32, 118, 97, 108, 117, 101, 115, 44, 32, 116, 104, 97, 116, 32, 110, 101, 119, 108, 105, 110, 101, 32, 98, 101, 99, 111, 109, 101, 115, 32, 116, 104, 101, 32, 110, 101, 119, 108, 105, 110, 101, 32, 119, 104, 101, 110, 32, 116, 104, 101, 32, 102, 105, 108, 101, 32, 105, 115, 32, 114, 101, 97, 100, 10, 97, 110, 100, 32, 105, 116, 32, 105, 115, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 117, 110, 116, 114, 97, 110, 115, 108, 97, 116, 101, 100, 46, 32, 79, 110, 32, 111, 117, 116, 112, 117, 116, 44, 32, 39, 92, 110, 39, 32, 105, 115, 32, 99, 111, 110, 118, 101, 114, 116, 101, 100, 32, 116, 111, 32, 116, 104, 101, 10, 110, 101, 119, 108, 105, 110, 101, 46, 10, 10, 73, 102, 32, 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 32, 105, 115, 32, 84, 114, 117, 101, 44, 32, 97, 32, 99, 97, 108, 108, 32, 116, 111, 32, 102, 108, 117, 115, 104, 32, 105, 115, 32, 105, 109, 112, 108, 105, 101, 100, 32, 119, 104, 101, 110, 32, 97, 32, 99, 97, 108, 108, 32, 116, 111, 10, 119, 114, 105, 116, 101, 32, 99, 111, 110, 116, 97, 105, 110, 115, 32, 97, 32, 110, 101, 119, 108, 105, 110, 101, 32, 99, 104, 97, 114, 97, 99, 116, 101, 114, 46, 0 ], "i8", ALLOC_NORMAL);
    _encodefuncs = allocate(80, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0 ], ALLOC_NORMAL);
    __str33409 = allocate([ 97, 115, 99, 105, 105, 0 ], "i8", ALLOC_NORMAL);
    __str34410 = allocate([ 105, 115, 111, 56, 56, 53, 57, 45, 49, 0 ], "i8", ALLOC_NORMAL);
    __str35411 = allocate([ 117, 116, 102, 45, 56, 0 ], "i8", ALLOC_NORMAL);
    __str36412 = allocate([ 117, 116, 102, 45, 49, 54, 45, 98, 101, 0 ], "i8", ALLOC_NORMAL);
    __str37413 = allocate([ 117, 116, 102, 45, 49, 54, 45, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str38414 = allocate([ 117, 116, 102, 45, 49, 54, 0 ], "i8", ALLOC_NORMAL);
    __str39415 = allocate([ 117, 116, 102, 45, 51, 50, 45, 98, 101, 0 ], "i8", ALLOC_NORMAL);
    __str40416 = allocate([ 117, 116, 102, 45, 51, 50, 45, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str41417 = allocate([ 117, 116, 102, 45, 51, 50, 0 ], "i8", ALLOC_NORMAL);
    _C_89_9102 = allocate(24, "i8*", ALLOC_NORMAL);
    __str42418 = allocate([ 98, 117, 102, 102, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    __str43419 = allocate([ 110, 101, 119, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str44420 = allocate([ 108, 105, 110, 101, 95, 98, 117, 102, 102, 101, 114, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str45421 = allocate([ 79, 124, 122, 122, 122, 105, 58, 102, 105, 108, 101, 105, 111, 0 ], "i8", ALLOC_NORMAL);
    __str46422 = allocate([ 105, 108, 108, 101, 103, 97, 108, 32, 110, 101, 119, 108, 105, 110, 101, 32, 118, 97, 108, 117, 101, 58, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str47423 = allocate([ 108, 111, 99, 97, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str48424 = allocate([ 103, 101, 116, 112, 114, 101, 102, 101, 114, 114, 101, 100, 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str49425 = allocate([ 99, 111, 117, 108, 100, 32, 110, 111, 116, 32, 100, 101, 116, 101, 114, 109, 105, 110, 101, 32, 100, 101, 102, 97, 117, 108, 116, 32, 101, 110, 99, 111, 100, 105, 110, 103, 0 ], "i8", ALLOC_NORMAL);
    __str50426 = allocate([ 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str51427 = allocate([ 79, 105, 0 ], "i8", ALLOC_NORMAL);
    __str52428 = allocate([ 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str53429 = allocate([ 110, 97, 109, 101, 0 ], "i8", ALLOC_NORMAL);
    __str54430 = allocate([ 114, 97, 119, 0 ], "i8", ALLOC_NORMAL);
    __str55431 = allocate([ 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str56432 = allocate([ 103, 45, 62, 103, 99, 46, 103, 99, 95, 114, 101, 102, 115, 32, 33, 61, 32, 40, 45, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___9643 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 100, 101, 97, 108, 108, 111, 99, 0 ], "i8", ALLOC_NORMAL);
    __str57433 = allocate([ 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 98, 117, 102, 102, 101, 114, 32, 104, 97, 115, 32, 98, 101, 101, 110, 32, 100, 101, 116, 97, 99, 104, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str58434 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 117, 110, 105, 110, 105, 116, 105, 97, 108, 105, 122, 101, 100, 32, 111, 98, 106, 101, 99, 116, 0 ], "i8", ALLOC_NORMAL);
    __str59435 = allocate([ 85, 58, 119, 114, 105, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str60436 = allocate([ 73, 47, 79, 32, 111, 112, 101, 114, 97, 116, 105, 111, 110, 32, 111, 110, 32, 99, 108, 111, 115, 101, 100, 32, 102, 105, 108, 101, 46, 0 ], "i8", ALLOC_NORMAL);
    __str61437 = allocate([ 110, 111, 116, 32, 119, 114, 105, 116, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str62438 = allocate([ 114, 101, 112, 108, 97, 99, 101, 0 ], "i8", ALLOC_NORMAL);
    __str63439 = allocate([ 97, 118, 97, 105, 108, 32, 62, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10137 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 103, 101, 116, 95, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 0 ], "i8", ALLOC_NORMAL);
    __str64440 = allocate([ 110, 111, 116, 32, 114, 101, 97, 100, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str65441 = allocate([ 40, 79, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str66442 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 105, 110, 112, 117, 116, 95, 99, 104, 117, 110, 107, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 55, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10181 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 114, 101, 97, 100, 95, 99, 104, 117, 110, 107, 0 ], "i8", ALLOC_NORMAL);
    __str67443 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 110, 101, 120, 116, 95, 105, 110, 112, 117, 116, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 55, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str68444 = allocate([ 78, 78, 0 ], "i8", ALLOC_NORMAL);
    __str69445 = allocate([ 124, 79, 38, 58, 114, 101, 97, 100, 0 ], "i8", ALLOC_NORMAL);
    __str70446 = allocate([ 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 95, 117, 115, 101, 100, 32, 61, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___10683 = allocate([ 95, 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str71447 = allocate([ 124, 79, 58, 114, 101, 97, 100, 108, 105, 110, 101, 0 ], "i8", ALLOC_NORMAL);
    __str72448 = allocate([ 105, 110, 116, 101, 103, 101, 114, 32, 97, 114, 103, 117, 109, 101, 110, 116, 32, 101, 120, 112, 101, 99, 116, 101, 100, 44, 32, 103, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str73449 = allocate([ 40, 40, 115, 105, 41, 41, 0 ], "i8", ALLOC_NORMAL);
    __str74 = allocate([ 79, 124, 105, 58, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str75 = allocate([ 117, 110, 100, 101, 114, 108, 121, 105, 110, 103, 32, 115, 116, 114, 101, 97, 109, 32, 105, 115, 32, 110, 111, 116, 32, 115, 101, 101, 107, 97, 98, 108, 101, 0 ], "i8", ALLOC_NORMAL);
    __str76 = allocate([ 99, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 99, 117, 114, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    __str77 = allocate([ 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str78 = allocate([ 99, 97, 110, 39, 116, 32, 100, 111, 32, 110, 111, 110, 122, 101, 114, 111, 32, 101, 110, 100, 45, 114, 101, 108, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 115, 0 ], "i8", ALLOC_NORMAL);
    __str79 = allocate([ 102, 108, 117, 115, 104, 0 ], "i8", ALLOC_NORMAL);
    __str80 = allocate([ 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str81 = allocate([ 105, 105, 0 ], "i8", ALLOC_NORMAL);
    __str82 = allocate([ 105, 110, 118, 97, 108, 105, 100, 32, 119, 104, 101, 110, 99, 101, 32, 40, 37, 100, 44, 32, 115, 104, 111, 117, 108, 100, 32, 98, 101, 32, 48, 44, 32, 49, 32, 111, 114, 32, 50, 41, 0 ], "i8", ALLOC_NORMAL);
    __str83 = allocate([ 110, 101, 103, 97, 116, 105, 118, 101, 32, 115, 101, 101, 107, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 37, 115, 0 ], "i8", ALLOC_NORMAL);
    __str84 = allocate([ 105, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11136 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 115, 101, 101, 107, 0 ], "i8", ALLOC_NORMAL);
    __str85 = allocate([ 105, 78, 0 ], "i8", ALLOC_NORMAL);
    __str86 = allocate([ 99, 97, 110, 39, 116, 32, 114, 101, 115, 116, 111, 114, 101, 32, 108, 111, 103, 105, 99, 97, 108, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str87 = allocate([ 105, 115, 0 ], "i8", ALLOC_NORMAL);
    __str88 = allocate([ 116, 101, 108, 108, 105, 110, 103, 32, 112, 111, 115, 105, 116, 105, 111, 110, 32, 100, 105, 115, 97, 98, 108, 101, 100, 32, 98, 121, 32, 110, 101, 120, 116, 40, 41, 32, 99, 97, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str89 = allocate([ 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 32, 61, 61, 32, 40, 40, 118, 111, 105, 100, 32, 42, 41, 48, 41, 32, 124, 124, 32, 80, 121, 85, 110, 105, 99, 111, 100, 101, 85, 67, 83, 50, 95, 71, 101, 116, 83, 105, 122, 101, 40, 115, 101, 108, 102, 45, 62, 100, 101, 99, 111, 100, 101, 100, 95, 99, 104, 97, 114, 115, 41, 32, 61, 61, 32, 48, 0 ], "i8", ALLOC_NORMAL);
    ___PRETTY_FUNCTION___11423 = allocate([ 116, 101, 120, 116, 105, 111, 119, 114, 97, 112, 112, 101, 114, 95, 116, 101, 108, 108, 0 ], "i8", ALLOC_NORMAL);
    __str90 = allocate([ 40, 105, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str91 = allocate([ 115, 35, 0 ], "i8", ALLOC_NORMAL);
    __str92 = allocate([ 40, 40, 40, 40, 40, 40, 80, 121, 79, 98, 106, 101, 99, 116, 42, 41, 40, 100, 101, 99, 111, 100, 101, 100, 41, 41, 45, 62, 111, 98, 95, 116, 121, 112, 101, 41, 41, 45, 62, 116, 112, 95, 102, 108, 97, 103, 115, 32, 38, 32, 40, 40, 49, 76, 60, 60, 50, 56, 41, 41, 41, 32, 33, 61, 32, 48, 41, 0 ], "i8", ALLOC_NORMAL);
    __str93 = allocate([ 40, 115, 35, 105, 41, 0 ], "i8", ALLOC_NORMAL);
    __str94 = allocate([ 115, 105, 0 ], "i8", ALLOC_NORMAL);
    __str95 = allocate([ 99, 97, 110, 39, 116, 32, 114, 101, 99, 111, 110, 115, 116, 114, 117, 99, 116, 32, 108, 111, 103, 105, 99, 97, 108, 32, 102, 105, 108, 101, 32, 112, 111, 115, 105, 116, 105, 111, 110, 0 ], "i8", ALLOC_NORMAL);
    __str96 = allocate([ 40, 79, 41, 0 ], "i8", ALLOC_NORMAL);
    __str97 = allocate([ 124, 79, 58, 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    __str98 = allocate([ 60, 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 32, 101, 110, 99, 111, 100, 105, 110, 103, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str99 = allocate([ 60, 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 32, 110, 97, 109, 101, 61, 37, 115, 32, 101, 110, 99, 111, 100, 105, 110, 103, 61, 37, 115, 62, 0 ], "i8", ALLOC_NORMAL);
    __str100 = allocate([ 102, 105, 108, 101, 110, 111, 0 ], "i8", ALLOC_NORMAL);
    __str101 = allocate([ 105, 115, 97, 116, 116, 121, 0 ], "i8", ALLOC_NORMAL);
    __str102 = allocate([ 99, 108, 111, 115, 101, 0 ], "i8", ALLOC_NORMAL);
    __str103 = allocate([ 114, 101, 97, 100, 108, 105, 110, 101, 40, 41, 32, 115, 104, 111, 117, 108, 100, 32, 104, 97, 118, 101, 32, 114, 101, 116, 117, 114, 110, 101, 100, 32, 97, 110, 32, 115, 116, 114, 32, 111, 98, 106, 101, 99, 116, 44, 32, 110, 111, 116, 32, 39, 37, 46, 50, 48, 48, 115, 39, 0 ], "i8", ALLOC_NORMAL);
    __str104 = allocate([ 97, 32, 115, 116, 114, 105, 99, 116, 108, 121, 32, 112, 111, 115, 105, 116, 105, 118, 101, 32, 105, 110, 116, 101, 103, 101, 114, 32, 105, 115, 32, 114, 101, 113, 117, 105, 114, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str105 = allocate([ 116, 114, 117, 110, 99, 97, 116, 101, 0 ], "i8", ALLOC_NORMAL);
    _textiowrapper_methods = allocate([ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    _textiowrapper_members = allocate([ 0, 0, 0, 0, 6, 0, 0, 0, 24, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 20, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 0, 0, 0, 48, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str106 = allocate([ 99, 108, 111, 115, 101, 100, 0 ], "i8", ALLOC_NORMAL);
    __str107 = allocate([ 95, 67, 72, 85, 78, 75, 95, 83, 73, 90, 69, 0 ], "i8", ALLOC_NORMAL);
    _textiowrapper_getset = allocate(120, [ "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, i8*)*", 0, 0, 0, "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    __str108 = allocate([ 95, 105, 111, 46, 84, 101, 120, 116, 73, 79, 87, 114, 97, 112, 112, 101, 114, 0 ], "i8", ALLOC_NORMAL);
    _PyTextIOWrapper_Type = allocate([ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 148971, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 88, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ "i32", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32", 0, 0, 0, "i32", 0, 0, 0, "void (%struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.FILE*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*, i8*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyNumberMethods*", 0, 0, 0, "%struct.PySequenceMethods*", 0, 0, 0, "%struct.PyMappingMethods*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyBufferProcs*", 0, 0, 0, "i32", 0, 0, 0, "i8*", 0, 0, 0, "i32 (%struct.PyObject*, i32 (%struct.PyObject*, i8*)*, i8*)*", 0, 0, 0, "i32 (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, i32)*", 0, 0, 0, "i32", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*)*", 0, 0, 0, "%struct.PyMethodDef*", 0, 0, 0, "%struct.PyMemberDef*", 0, 0, 0, "%struct.PyGetSetDef*", 0, 0, 0, "%struct._typeobject*", 0, 0, 0, "%struct.PyObject*", 0, 0, 0, "%struct.PyObject* (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i32", 0, 0, 0, "i32 (%struct.PyObject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, i32)*", 0, 0, 0, "%struct.PyObject* (%struct._typeobject*, %struct.PyObject*, %struct.PyObject*)*", 0, 0, 0, "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8", "i8" ], ALLOC_NORMAL);
    HEAP[_bufferediobase_methods] = __str4;
    HEAP[_bufferediobase_methods + 4] = FUNCTION_TABLE_OFFSET + 4;
    HEAP[_bufferediobase_methods + 12] = _bufferediobase_detach_doc;
    HEAP[_bufferediobase_methods + 16] = __str1;
    HEAP[_bufferediobase_methods + 20] = FUNCTION_TABLE_OFFSET + 6;
    HEAP[_bufferediobase_methods + 28] = _bufferediobase_read_doc;
    HEAP[_bufferediobase_methods + 32] = __str5;
    HEAP[_bufferediobase_methods + 36] = FUNCTION_TABLE_OFFSET + 8;
    HEAP[_bufferediobase_methods + 44] = _bufferediobase_read1_doc;
    HEAP[_bufferediobase_methods + 48] = __str7;
    HEAP[_bufferediobase_methods + 52] = FUNCTION_TABLE_OFFSET + 10;
    HEAP[_bufferediobase_methods + 64] = __str6;
    HEAP[_bufferediobase_methods + 68] = FUNCTION_TABLE_OFFSET + 12;
    HEAP[_bufferediobase_methods + 76] = _bufferediobase_write_doc;
    HEAP[_PyBufferedIOBase_Type + 12] = __str8;
    HEAP[_PyBufferedIOBase_Type + 88] = _bufferediobase_doc;
    HEAP[_PyBufferedIOBase_Type + 116] = _bufferediobase_methods;
    HEAP[_PyBufferedIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_C_170_9977] = __str35;
    HEAP[_C_170_9977 + 4] = __str36;
    HEAP[_bufferedreader_methods] = __str4;
    HEAP[_bufferedreader_methods + 4] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedreader_methods + 16] = __str40;
    HEAP[_bufferedreader_methods + 20] = FUNCTION_TABLE_OFFSET + 16;
    HEAP[_bufferedreader_methods + 32] = __str41;
    HEAP[_bufferedreader_methods + 36] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedreader_methods + 48] = __str42;
    HEAP[_bufferedreader_methods + 52] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedreader_methods + 64] = __str43;
    HEAP[_bufferedreader_methods + 68] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedreader_methods + 80] = __str44;
    HEAP[_bufferedreader_methods + 84] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedreader_methods + 96] = __str45;
    HEAP[_bufferedreader_methods + 100] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedreader_methods + 112] = __str46;
    HEAP[_bufferedreader_methods + 116] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedreader_methods + 128] = __str1;
    HEAP[_bufferedreader_methods + 132] = FUNCTION_TABLE_OFFSET + 30;
    HEAP[_bufferedreader_methods + 144] = __str47;
    HEAP[_bufferedreader_methods + 148] = FUNCTION_TABLE_OFFSET + 32;
    HEAP[_bufferedreader_methods + 160] = __str5;
    HEAP[_bufferedreader_methods + 164] = FUNCTION_TABLE_OFFSET + 34;
    HEAP[_bufferedreader_methods + 176] = __str48;
    HEAP[_bufferedreader_methods + 180] = FUNCTION_TABLE_OFFSET + 36;
    HEAP[_bufferedreader_methods + 192] = __str49;
    HEAP[_bufferedreader_methods + 196] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedreader_methods + 208] = __str50;
    HEAP[_bufferedreader_methods + 212] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedreader_methods + 224] = __str51;
    HEAP[_bufferedreader_methods + 228] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedreader_members] = __str35;
    HEAP[_bufferedreader_getset] = __str52;
    HEAP[_bufferedreader_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedreader_getset + 20] = __str13;
    HEAP[_bufferedreader_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedreader_getset + 40] = __str14;
    HEAP[_bufferedreader_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedReader_Type + 12] = __str53;
    HEAP[_PyBufferedReader_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedReader_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedReader_Type + 88] = _bufferedreader_doc;
    HEAP[_PyBufferedReader_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedReader_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedReader_Type + 112] = FUNCTION_TABLE_OFFSET + 58;
    HEAP[_PyBufferedReader_Type + 116] = _bufferedreader_methods;
    HEAP[_PyBufferedReader_Type + 120] = _bufferedreader_members;
    HEAP[_PyBufferedReader_Type + 124] = _bufferedreader_getset;
    HEAP[_PyBufferedReader_Type + 148] = FUNCTION_TABLE_OFFSET + 60;
    HEAP[_PyBufferedReader_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_C_210_10512] = __str35;
    HEAP[_C_210_10512 + 4] = __str36;
    HEAP[_C_210_10512 + 8] = __str55;
    HEAP[_bufferedwriter_methods] = __str41;
    HEAP[_bufferedwriter_methods + 4] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedwriter_methods + 16] = __str4;
    HEAP[_bufferedwriter_methods + 20] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedwriter_methods + 32] = __str42;
    HEAP[_bufferedwriter_methods + 36] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedwriter_methods + 48] = __str43;
    HEAP[_bufferedwriter_methods + 52] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedwriter_methods + 64] = __str44;
    HEAP[_bufferedwriter_methods + 68] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedwriter_methods + 80] = __str45;
    HEAP[_bufferedwriter_methods + 84] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedwriter_methods + 96] = __str46;
    HEAP[_bufferedwriter_methods + 100] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedwriter_methods + 112] = __str6;
    HEAP[_bufferedwriter_methods + 116] = FUNCTION_TABLE_OFFSET + 64;
    HEAP[_bufferedwriter_methods + 128] = __str51;
    HEAP[_bufferedwriter_methods + 132] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedwriter_methods + 144] = __str40;
    HEAP[_bufferedwriter_methods + 148] = FUNCTION_TABLE_OFFSET + 66;
    HEAP[_bufferedwriter_methods + 160] = __str49;
    HEAP[_bufferedwriter_methods + 164] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedwriter_methods + 176] = __str50;
    HEAP[_bufferedwriter_methods + 180] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedwriter_members] = __str35;
    HEAP[_bufferedwriter_getset] = __str52;
    HEAP[_bufferedwriter_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedwriter_getset + 20] = __str13;
    HEAP[_bufferedwriter_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedwriter_getset + 40] = __str14;
    HEAP[_bufferedwriter_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedWriter_Type + 12] = __str61;
    HEAP[_PyBufferedWriter_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedWriter_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedWriter_Type + 88] = _bufferedwriter_doc;
    HEAP[_PyBufferedWriter_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedWriter_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedWriter_Type + 116] = _bufferedwriter_methods;
    HEAP[_PyBufferedWriter_Type + 120] = _bufferedwriter_members;
    HEAP[_PyBufferedWriter_Type + 124] = _bufferedwriter_getset;
    HEAP[_PyBufferedWriter_Type + 148] = FUNCTION_TABLE_OFFSET + 68;
    HEAP[_PyBufferedWriter_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_bufferedrwpair_methods] = __str1;
    HEAP[_bufferedrwpair_methods + 4] = FUNCTION_TABLE_OFFSET + 70;
    HEAP[_bufferedrwpair_methods + 16] = __str47;
    HEAP[_bufferedrwpair_methods + 20] = FUNCTION_TABLE_OFFSET + 72;
    HEAP[_bufferedrwpair_methods + 32] = __str5;
    HEAP[_bufferedrwpair_methods + 36] = FUNCTION_TABLE_OFFSET + 74;
    HEAP[_bufferedrwpair_methods + 48] = __str7;
    HEAP[_bufferedrwpair_methods + 52] = FUNCTION_TABLE_OFFSET + 76;
    HEAP[_bufferedrwpair_methods + 64] = __str6;
    HEAP[_bufferedrwpair_methods + 68] = FUNCTION_TABLE_OFFSET + 78;
    HEAP[_bufferedrwpair_methods + 80] = __str40;
    HEAP[_bufferedrwpair_methods + 84] = FUNCTION_TABLE_OFFSET + 80;
    HEAP[_bufferedrwpair_methods + 96] = __str43;
    HEAP[_bufferedrwpair_methods + 100] = FUNCTION_TABLE_OFFSET + 82;
    HEAP[_bufferedrwpair_methods + 112] = __str44;
    HEAP[_bufferedrwpair_methods + 116] = FUNCTION_TABLE_OFFSET + 84;
    HEAP[_bufferedrwpair_methods + 128] = __str41;
    HEAP[_bufferedrwpair_methods + 132] = FUNCTION_TABLE_OFFSET + 86;
    HEAP[_bufferedrwpair_methods + 144] = __str46;
    HEAP[_bufferedrwpair_methods + 148] = FUNCTION_TABLE_OFFSET + 88;
    HEAP[_bufferedrwpair_getset] = __str52;
    HEAP[_bufferedrwpair_getset + 4] = FUNCTION_TABLE_OFFSET + 90;
    HEAP[_PyBufferedRWPair_Type + 12] = __str64;
    HEAP[_PyBufferedRWPair_Type + 24] = FUNCTION_TABLE_OFFSET + 92;
    HEAP[_PyBufferedRWPair_Type + 88] = _bufferedrwpair_doc;
    HEAP[_PyBufferedRWPair_Type + 92] = FUNCTION_TABLE_OFFSET + 94;
    HEAP[_PyBufferedRWPair_Type + 96] = FUNCTION_TABLE_OFFSET + 96;
    HEAP[_PyBufferedRWPair_Type + 116] = _bufferedrwpair_methods;
    HEAP[_PyBufferedRWPair_Type + 124] = _bufferedrwpair_getset;
    HEAP[_PyBufferedRWPair_Type + 148] = FUNCTION_TABLE_OFFSET + 98;
    HEAP[_PyBufferedRWPair_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_C_248_11275] = __str35;
    HEAP[_C_248_11275 + 4] = __str36;
    HEAP[_C_248_11275 + 8] = __str55;
    HEAP[_bufferedrandom_methods] = __str41;
    HEAP[_bufferedrandom_methods + 4] = FUNCTION_TABLE_OFFSET + 18;
    HEAP[_bufferedrandom_methods + 16] = __str4;
    HEAP[_bufferedrandom_methods + 20] = FUNCTION_TABLE_OFFSET + 14;
    HEAP[_bufferedrandom_methods + 32] = __str42;
    HEAP[_bufferedrandom_methods + 36] = FUNCTION_TABLE_OFFSET + 20;
    HEAP[_bufferedrandom_methods + 48] = __str43;
    HEAP[_bufferedrandom_methods + 52] = FUNCTION_TABLE_OFFSET + 22;
    HEAP[_bufferedrandom_methods + 64] = __str44;
    HEAP[_bufferedrandom_methods + 68] = FUNCTION_TABLE_OFFSET + 24;
    HEAP[_bufferedrandom_methods + 80] = __str45;
    HEAP[_bufferedrandom_methods + 84] = FUNCTION_TABLE_OFFSET + 26;
    HEAP[_bufferedrandom_methods + 96] = __str46;
    HEAP[_bufferedrandom_methods + 100] = FUNCTION_TABLE_OFFSET + 28;
    HEAP[_bufferedrandom_methods + 112] = __str40;
    HEAP[_bufferedrandom_methods + 116] = FUNCTION_TABLE_OFFSET + 66;
    HEAP[_bufferedrandom_methods + 128] = __str49;
    HEAP[_bufferedrandom_methods + 132] = FUNCTION_TABLE_OFFSET + 38;
    HEAP[_bufferedrandom_methods + 144] = __str50;
    HEAP[_bufferedrandom_methods + 148] = FUNCTION_TABLE_OFFSET + 40;
    HEAP[_bufferedrandom_methods + 160] = __str51;
    HEAP[_bufferedrandom_methods + 164] = FUNCTION_TABLE_OFFSET + 42;
    HEAP[_bufferedrandom_methods + 176] = __str1;
    HEAP[_bufferedrandom_methods + 180] = FUNCTION_TABLE_OFFSET + 30;
    HEAP[_bufferedrandom_methods + 192] = __str5;
    HEAP[_bufferedrandom_methods + 196] = FUNCTION_TABLE_OFFSET + 34;
    HEAP[_bufferedrandom_methods + 208] = __str7;
    HEAP[_bufferedrandom_methods + 212] = FUNCTION_TABLE_OFFSET + 100;
    HEAP[_bufferedrandom_methods + 224] = __str48;
    HEAP[_bufferedrandom_methods + 228] = FUNCTION_TABLE_OFFSET + 36;
    HEAP[_bufferedrandom_methods + 240] = __str47;
    HEAP[_bufferedrandom_methods + 244] = FUNCTION_TABLE_OFFSET + 32;
    HEAP[_bufferedrandom_methods + 256] = __str6;
    HEAP[_bufferedrandom_methods + 260] = FUNCTION_TABLE_OFFSET + 64;
    HEAP[_bufferedrandom_members] = __str35;
    HEAP[_bufferedrandom_getset] = __str52;
    HEAP[_bufferedrandom_getset + 4] = FUNCTION_TABLE_OFFSET + 44;
    HEAP[_bufferedrandom_getset + 20] = __str13;
    HEAP[_bufferedrandom_getset + 24] = FUNCTION_TABLE_OFFSET + 46;
    HEAP[_bufferedrandom_getset + 40] = __str14;
    HEAP[_bufferedrandom_getset + 44] = FUNCTION_TABLE_OFFSET + 48;
    HEAP[_PyBufferedRandom_Type + 12] = __str65;
    HEAP[_PyBufferedRandom_Type + 24] = FUNCTION_TABLE_OFFSET + 50;
    HEAP[_PyBufferedRandom_Type + 44] = FUNCTION_TABLE_OFFSET + 52;
    HEAP[_PyBufferedRandom_Type + 88] = _bufferedrandom_doc;
    HEAP[_PyBufferedRandom_Type + 92] = FUNCTION_TABLE_OFFSET + 54;
    HEAP[_PyBufferedRandom_Type + 96] = FUNCTION_TABLE_OFFSET + 56;
    HEAP[_PyBufferedRandom_Type + 112] = FUNCTION_TABLE_OFFSET + 58;
    HEAP[_PyBufferedRandom_Type + 116] = _bufferedrandom_methods;
    HEAP[_PyBufferedRandom_Type + 120] = _bufferedrandom_members;
    HEAP[_PyBufferedRandom_Type + 124] = _bufferedrandom_getset;
    HEAP[_PyBufferedRandom_Type + 148] = FUNCTION_TABLE_OFFSET + 102;
    HEAP[_PyBufferedRandom_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_C_82_9238] = __str2793;
    HEAP[_bytesio_getsetlist] = __str2995;
    HEAP[_bytesio_getsetlist + 4] = FUNCTION_TABLE_OFFSET + 104;
    HEAP[_bytesio_getsetlist + 12] = __str3096;
    HEAP[_bytesio_methods] = __str3197;
    HEAP[_bytesio_methods + 4] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 16] = __str3298;
    HEAP[_bytesio_methods + 20] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 32] = __str3399;
    HEAP[_bytesio_methods + 36] = FUNCTION_TABLE_OFFSET + 106;
    HEAP[_bytesio_methods + 48] = __str34100;
    HEAP[_bytesio_methods + 52] = FUNCTION_TABLE_OFFSET + 108;
    HEAP[_bytesio_methods + 60] = _close_doc;
    HEAP[_bytesio_methods + 64] = __str35101;
    HEAP[_bytesio_methods + 68] = FUNCTION_TABLE_OFFSET + 110;
    HEAP[_bytesio_methods + 76] = _flush_doc;
    HEAP[_bytesio_methods + 80] = __str36102;
    HEAP[_bytesio_methods + 84] = FUNCTION_TABLE_OFFSET + 112;
    HEAP[_bytesio_methods + 92] = _isatty_doc;
    HEAP[_bytesio_methods + 96] = __str37103;
    HEAP[_bytesio_methods + 100] = FUNCTION_TABLE_OFFSET + 114;
    HEAP[_bytesio_methods + 108] = _tell_doc;
    HEAP[_bytesio_methods + 112] = __str38104;
    HEAP[_bytesio_methods + 116] = FUNCTION_TABLE_OFFSET + 116;
    HEAP[_bytesio_methods + 124] = _write_doc;
    HEAP[_bytesio_methods + 128] = __str39105;
    HEAP[_bytesio_methods + 132] = FUNCTION_TABLE_OFFSET + 118;
    HEAP[_bytesio_methods + 140] = _writelines_doc;
    HEAP[_bytesio_methods + 144] = __str40106;
    HEAP[_bytesio_methods + 148] = FUNCTION_TABLE_OFFSET + 120;
    HEAP[_bytesio_methods + 156] = _read1_doc;
    HEAP[_bytesio_methods + 160] = __str41107;
    HEAP[_bytesio_methods + 164] = FUNCTION_TABLE_OFFSET + 122;
    HEAP[_bytesio_methods + 172] = _readinto_doc;
    HEAP[_bytesio_methods + 176] = __str42108;
    HEAP[_bytesio_methods + 180] = FUNCTION_TABLE_OFFSET + 124;
    HEAP[_bytesio_methods + 188] = _readline_doc;
    HEAP[_bytesio_methods + 192] = __str43109;
    HEAP[_bytesio_methods + 196] = FUNCTION_TABLE_OFFSET + 126;
    HEAP[_bytesio_methods + 204] = _readlines_doc;
    HEAP[_bytesio_methods + 208] = __str44110;
    HEAP[_bytesio_methods + 212] = FUNCTION_TABLE_OFFSET + 128;
    HEAP[_bytesio_methods + 220] = _read_doc;
    HEAP[_bytesio_methods + 224] = __str45111;
    HEAP[_bytesio_methods + 228] = FUNCTION_TABLE_OFFSET + 130;
    HEAP[_bytesio_methods + 236] = _getval_doc;
    HEAP[_bytesio_methods + 240] = __str46112;
    HEAP[_bytesio_methods + 244] = FUNCTION_TABLE_OFFSET + 132;
    HEAP[_bytesio_methods + 252] = _seek_doc;
    HEAP[_bytesio_methods + 256] = __str47113;
    HEAP[_bytesio_methods + 260] = FUNCTION_TABLE_OFFSET + 134;
    HEAP[_bytesio_methods + 268] = _truncate_doc;
    HEAP[_bytesio_methods + 272] = __str48114;
    HEAP[_bytesio_methods + 276] = FUNCTION_TABLE_OFFSET + 136;
    HEAP[_bytesio_methods + 288] = __str49115;
    HEAP[_bytesio_methods + 292] = FUNCTION_TABLE_OFFSET + 138;
    HEAP[_PyBytesIO_Type + 12] = __str50116;
    HEAP[_PyBytesIO_Type + 24] = FUNCTION_TABLE_OFFSET + 140;
    HEAP[_PyBytesIO_Type + 88] = _bytesio_doc;
    HEAP[_PyBytesIO_Type + 92] = FUNCTION_TABLE_OFFSET + 142;
    HEAP[_PyBytesIO_Type + 96] = FUNCTION_TABLE_OFFSET + 144;
    HEAP[_PyBytesIO_Type + 108] = FUNCTION_TABLE_OFFSET + 146;
    HEAP[_PyBytesIO_Type + 112] = FUNCTION_TABLE_OFFSET + 148;
    HEAP[_PyBytesIO_Type + 116] = _bytesio_methods;
    HEAP[_PyBytesIO_Type + 124] = _bytesio_getsetlist;
    HEAP[_PyBytesIO_Type + 148] = FUNCTION_TABLE_OFFSET + 150;
    HEAP[_PyBytesIO_Type + 156] = FUNCTION_TABLE_OFFSET + 152;
    HEAP[_kwlist_8591] = __str9126;
    HEAP[_kwlist_8591 + 4] = __str10127;
    HEAP[_kwlist_8591 + 8] = __str11128;
    HEAP[_fileio_methods] = __str37162;
    HEAP[_fileio_methods + 4] = FUNCTION_TABLE_OFFSET + 154;
    HEAP[_fileio_methods + 12] = _read_doc154;
    HEAP[_fileio_methods + 16] = __str38163;
    HEAP[_fileio_methods + 20] = FUNCTION_TABLE_OFFSET + 156;
    HEAP[_fileio_methods + 28] = _readall_doc;
    HEAP[_fileio_methods + 32] = __str39164;
    HEAP[_fileio_methods + 36] = FUNCTION_TABLE_OFFSET + 158;
    HEAP[_fileio_methods + 44] = _readinto_doc159;
    HEAP[_fileio_methods + 48] = __str40165;
    HEAP[_fileio_methods + 52] = FUNCTION_TABLE_OFFSET + 160;
    HEAP[_fileio_methods + 60] = _write_doc155;
    HEAP[_fileio_methods + 64] = __str41166;
    HEAP[_fileio_methods + 68] = FUNCTION_TABLE_OFFSET + 162;
    HEAP[_fileio_methods + 76] = _seek_doc156;
    HEAP[_fileio_methods + 80] = __str42167;
    HEAP[_fileio_methods + 84] = FUNCTION_TABLE_OFFSET + 164;
    HEAP[_fileio_methods + 92] = _tell_doc158;
    HEAP[_fileio_methods + 96] = __str43168;
    HEAP[_fileio_methods + 100] = FUNCTION_TABLE_OFFSET + 166;
    HEAP[_fileio_methods + 108] = _truncate_doc157;
    HEAP[_fileio_methods + 112] = __str117;
    HEAP[_fileio_methods + 116] = FUNCTION_TABLE_OFFSET + 168;
    HEAP[_fileio_methods + 124] = _close_doc160;
    HEAP[_fileio_methods + 128] = __str44169;
    HEAP[_fileio_methods + 132] = FUNCTION_TABLE_OFFSET + 170;
    HEAP[_fileio_methods + 140] = _seekable_doc;
    HEAP[_fileio_methods + 144] = __str45170;
    HEAP[_fileio_methods + 148] = FUNCTION_TABLE_OFFSET + 172;
    HEAP[_fileio_methods + 156] = _readable_doc;
    HEAP[_fileio_methods + 160] = __str46171;
    HEAP[_fileio_methods + 164] = FUNCTION_TABLE_OFFSET + 174;
    HEAP[_fileio_methods + 172] = _writable_doc;
    HEAP[_fileio_methods + 176] = __str47172;
    HEAP[_fileio_methods + 180] = FUNCTION_TABLE_OFFSET + 176;
    HEAP[_fileio_methods + 188] = _fileno_doc;
    HEAP[_fileio_methods + 192] = __str48173;
    HEAP[_fileio_methods + 196] = FUNCTION_TABLE_OFFSET + 178;
    HEAP[_fileio_methods + 204] = _isatty_doc161;
    HEAP[_fileio_getsetlist] = __str49174;
    HEAP[_fileio_getsetlist + 4] = FUNCTION_TABLE_OFFSET + 180;
    HEAP[_fileio_getsetlist + 12] = __str50175;
    HEAP[_fileio_getsetlist + 20] = __str11128;
    HEAP[_fileio_getsetlist + 24] = FUNCTION_TABLE_OFFSET + 182;
    HEAP[_fileio_getsetlist + 32] = __str51176;
    HEAP[_fileio_getsetlist + 40] = __str10127;
    HEAP[_fileio_getsetlist + 44] = FUNCTION_TABLE_OFFSET + 184;
    HEAP[_fileio_getsetlist + 52] = __str52177;
    HEAP[_PyFileIO_Type + 12] = __str53178;
    HEAP[_PyFileIO_Type + 24] = FUNCTION_TABLE_OFFSET + 186;
    HEAP[_PyFileIO_Type + 44] = FUNCTION_TABLE_OFFSET + 188;
    HEAP[_PyFileIO_Type + 72] = FUNCTION_TABLE_OFFSET + 190;
    HEAP[_PyFileIO_Type + 88] = _fileio_doc;
    HEAP[_PyFileIO_Type + 92] = FUNCTION_TABLE_OFFSET + 192;
    HEAP[_PyFileIO_Type + 96] = FUNCTION_TABLE_OFFSET + 194;
    HEAP[_PyFileIO_Type + 116] = _fileio_methods;
    HEAP[_PyFileIO_Type + 124] = _fileio_getsetlist;
    HEAP[_PyFileIO_Type + 148] = FUNCTION_TABLE_OFFSET + 196;
    HEAP[_PyFileIO_Type + 152] = FUNCTION_TABLE_OFFSET + 198;
    HEAP[_PyFileIO_Type + 156] = FUNCTION_TABLE_OFFSET + 200;
    HEAP[_PyFileIO_Type + 160] = FUNCTION_TABLE_OFFSET + 202;
    HEAP[_iobase_methods] = __str181;
    HEAP[_iobase_methods + 4] = FUNCTION_TABLE_OFFSET + 204;
    HEAP[_iobase_methods + 12] = _iobase_seek_doc;
    HEAP[_iobase_methods + 16] = __str23204;
    HEAP[_iobase_methods + 20] = FUNCTION_TABLE_OFFSET + 206;
    HEAP[_iobase_methods + 28] = _iobase_tell_doc;
    HEAP[_iobase_methods + 32] = __str2183;
    HEAP[_iobase_methods + 36] = FUNCTION_TABLE_OFFSET + 208;
    HEAP[_iobase_methods + 44] = _iobase_truncate_doc;
    HEAP[_iobase_methods + 48] = __str24205;
    HEAP[_iobase_methods + 52] = FUNCTION_TABLE_OFFSET + 210;
    HEAP[_iobase_methods + 60] = _iobase_flush_doc;
    HEAP[_iobase_methods + 64] = __str25206;
    HEAP[_iobase_methods + 68] = FUNCTION_TABLE_OFFSET + 212;
    HEAP[_iobase_methods + 76] = _iobase_close_doc;
    HEAP[_iobase_methods + 80] = __str26207;
    HEAP[_iobase_methods + 84] = FUNCTION_TABLE_OFFSET + 214;
    HEAP[_iobase_methods + 92] = _iobase_seekable_doc;
    HEAP[_iobase_methods + 96] = __str27208;
    HEAP[_iobase_methods + 100] = FUNCTION_TABLE_OFFSET + 216;
    HEAP[_iobase_methods + 108] = _iobase_readable_doc;
    HEAP[_iobase_methods + 112] = __str28209;
    HEAP[_iobase_methods + 116] = FUNCTION_TABLE_OFFSET + 218;
    HEAP[_iobase_methods + 124] = _iobase_writable_doc;
    HEAP[_iobase_methods + 128] = __str29210;
    HEAP[_iobase_methods + 132] = FUNCTION_TABLE_OFFSET + 220;
    HEAP[_iobase_methods + 144] = __str30211;
    HEAP[_iobase_methods + 148] = FUNCTION_TABLE_OFFSET + 222;
    HEAP[_iobase_methods + 160] = __str31212;
    HEAP[_iobase_methods + 164] = FUNCTION_TABLE_OFFSET + 224;
    HEAP[_iobase_methods + 176] = __str32213;
    HEAP[_iobase_methods + 180] = FUNCTION_TABLE_OFFSET + 226;
    HEAP[_iobase_methods + 192] = __str10191;
    HEAP[_iobase_methods + 196] = FUNCTION_TABLE_OFFSET + 228;
    HEAP[_iobase_methods + 204] = _iobase_fileno_doc;
    HEAP[_iobase_methods + 208] = __str33214;
    HEAP[_iobase_methods + 212] = FUNCTION_TABLE_OFFSET + 230;
    HEAP[_iobase_methods + 220] = _iobase_isatty_doc;
    HEAP[_iobase_methods + 224] = __str34215;
    HEAP[_iobase_methods + 228] = FUNCTION_TABLE_OFFSET + 232;
    HEAP[_iobase_methods + 240] = __str35216;
    HEAP[_iobase_methods + 244] = FUNCTION_TABLE_OFFSET + 234;
    HEAP[_iobase_methods + 256] = __str36217;
    HEAP[_iobase_methods + 260] = FUNCTION_TABLE_OFFSET + 236;
    HEAP[_iobase_methods + 268] = _iobase_readline_doc;
    HEAP[_iobase_methods + 272] = __str37218;
    HEAP[_iobase_methods + 276] = FUNCTION_TABLE_OFFSET + 238;
    HEAP[_iobase_methods + 284] = _iobase_readlines_doc;
    HEAP[_iobase_methods + 288] = __str38219;
    HEAP[_iobase_methods + 292] = FUNCTION_TABLE_OFFSET + 240;
    HEAP[_iobase_getset] = __str39220;
    HEAP[_iobase_getset + 4] = FUNCTION_TABLE_OFFSET + 242;
    HEAP[_PyIOBase_Type + 12] = __str40221;
    HEAP[_PyIOBase_Type + 24] = FUNCTION_TABLE_OFFSET + 244;
    HEAP[_PyIOBase_Type + 88] = _iobase_doc;
    HEAP[_PyIOBase_Type + 92] = FUNCTION_TABLE_OFFSET + 246;
    HEAP[_PyIOBase_Type + 96] = FUNCTION_TABLE_OFFSET + 248;
    HEAP[_PyIOBase_Type + 108] = FUNCTION_TABLE_OFFSET + 250;
    HEAP[_PyIOBase_Type + 112] = FUNCTION_TABLE_OFFSET + 252;
    HEAP[_PyIOBase_Type + 116] = _iobase_methods;
    HEAP[_PyIOBase_Type + 124] = _iobase_getset;
    HEAP[_PyIOBase_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_rawiobase_methods] = __str15196;
    HEAP[_rawiobase_methods + 4] = FUNCTION_TABLE_OFFSET + 254;
    HEAP[_rawiobase_methods + 16] = __str42224;
    HEAP[_rawiobase_methods + 20] = FUNCTION_TABLE_OFFSET + 256;
    HEAP[_rawiobase_methods + 28] = _rawiobase_readall_doc;
    HEAP[_PyRawIOBase_Type + 12] = __str44226;
    HEAP[_PyRawIOBase_Type + 88] = _rawiobase_doc;
    HEAP[_PyRawIOBase_Type + 116] = _rawiobase_methods;
    HEAP[_PyRawIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_blockingioerror_members] = __str3235;
    HEAP[__PyExc_BlockingIOError + 12] = __str4236;
    HEAP[__PyExc_BlockingIOError + 88] = __str5237;
    HEAP[__PyExc_BlockingIOError + 120] = _blockingioerror_members;
    HEAP[__PyExc_BlockingIOError + 148] = FUNCTION_TABLE_OFFSET + 258;
    HEAP[_PyExc_BlockingIOError] = __PyExc_BlockingIOError;
    HEAP[_C_6_8496] = __str6239;
    HEAP[_C_6_8496 + 4] = __str7240;
    HEAP[_C_6_8496 + 8] = __str8241;
    HEAP[_C_6_8496 + 12] = __str9242;
    HEAP[_C_6_8496 + 16] = __str10243;
    HEAP[_C_6_8496 + 20] = __str11244;
    HEAP[_C_6_8496 + 24] = __str12245;
    HEAP[_module_methods] = __str34268;
    HEAP[_module_methods + 4] = FUNCTION_TABLE_OFFSET + 260;
    HEAP[_module_methods + 12] = _open_doc;
    HEAP[_C_71_9078] = __str23342;
    HEAP[_C_71_9078 + 4] = __str24343;
    HEAP[_stringio_methods] = __str36355;
    HEAP[_stringio_methods + 4] = FUNCTION_TABLE_OFFSET + 262;
    HEAP[_stringio_methods + 12] = _stringio_close_doc;
    HEAP[_stringio_methods + 16] = __str37356;
    HEAP[_stringio_methods + 20] = FUNCTION_TABLE_OFFSET + 264;
    HEAP[_stringio_methods + 28] = _stringio_getvalue_doc;
    HEAP[_stringio_methods + 32] = __str38357;
    HEAP[_stringio_methods + 36] = FUNCTION_TABLE_OFFSET + 266;
    HEAP[_stringio_methods + 44] = _stringio_read_doc;
    HEAP[_stringio_methods + 48] = __str39358;
    HEAP[_stringio_methods + 52] = FUNCTION_TABLE_OFFSET + 268;
    HEAP[_stringio_methods + 60] = _stringio_readline_doc;
    HEAP[_stringio_methods + 64] = __str40359;
    HEAP[_stringio_methods + 68] = FUNCTION_TABLE_OFFSET + 270;
    HEAP[_stringio_methods + 76] = _stringio_tell_doc;
    HEAP[_stringio_methods + 80] = __str41360;
    HEAP[_stringio_methods + 84] = FUNCTION_TABLE_OFFSET + 272;
    HEAP[_stringio_methods + 92] = _stringio_truncate_doc;
    HEAP[_stringio_methods + 96] = __str42361;
    HEAP[_stringio_methods + 100] = FUNCTION_TABLE_OFFSET + 274;
    HEAP[_stringio_methods + 108] = _stringio_seek_doc;
    HEAP[_stringio_methods + 112] = __str43362;
    HEAP[_stringio_methods + 116] = FUNCTION_TABLE_OFFSET + 276;
    HEAP[_stringio_methods + 124] = _stringio_write_doc;
    HEAP[_stringio_methods + 128] = __str44363;
    HEAP[_stringio_methods + 132] = FUNCTION_TABLE_OFFSET + 278;
    HEAP[_stringio_methods + 144] = __str45364;
    HEAP[_stringio_methods + 148] = FUNCTION_TABLE_OFFSET + 280;
    HEAP[_stringio_methods + 160] = __str46365;
    HEAP[_stringio_methods + 164] = FUNCTION_TABLE_OFFSET + 282;
    HEAP[_stringio_methods + 176] = __str47366;
    HEAP[_stringio_methods + 180] = FUNCTION_TABLE_OFFSET + 284;
    HEAP[_stringio_methods + 192] = __str48367;
    HEAP[_stringio_methods + 196] = FUNCTION_TABLE_OFFSET + 286;
    HEAP[_stringio_getset] = __str49368;
    HEAP[_stringio_getset + 4] = FUNCTION_TABLE_OFFSET + 288;
    HEAP[_stringio_getset + 20] = __str50369;
    HEAP[_stringio_getset + 24] = FUNCTION_TABLE_OFFSET + 290;
    HEAP[_stringio_getset + 40] = __str51370;
    HEAP[_stringio_getset + 44] = FUNCTION_TABLE_OFFSET + 292;
    HEAP[_PyStringIO_Type + 12] = __str52371;
    HEAP[_PyStringIO_Type + 24] = FUNCTION_TABLE_OFFSET + 294;
    HEAP[_PyStringIO_Type + 88] = _stringio_doc;
    HEAP[_PyStringIO_Type + 92] = FUNCTION_TABLE_OFFSET + 296;
    HEAP[_PyStringIO_Type + 96] = FUNCTION_TABLE_OFFSET + 298;
    HEAP[_PyStringIO_Type + 112] = FUNCTION_TABLE_OFFSET + 300;
    HEAP[_PyStringIO_Type + 116] = _stringio_methods;
    HEAP[_PyStringIO_Type + 124] = _stringio_getset;
    HEAP[_PyStringIO_Type + 148] = FUNCTION_TABLE_OFFSET + 302;
    HEAP[_PyStringIO_Type + 156] = FUNCTION_TABLE_OFFSET + 304;
    HEAP[_textiobase_methods] = __str374;
    HEAP[_textiobase_methods + 4] = FUNCTION_TABLE_OFFSET + 306;
    HEAP[_textiobase_methods + 12] = _textiobase_detach_doc;
    HEAP[_textiobase_methods + 16] = __str1375;
    HEAP[_textiobase_methods + 20] = FUNCTION_TABLE_OFFSET + 308;
    HEAP[_textiobase_methods + 28] = _textiobase_read_doc;
    HEAP[_textiobase_methods + 32] = __str2376;
    HEAP[_textiobase_methods + 36] = FUNCTION_TABLE_OFFSET + 310;
    HEAP[_textiobase_methods + 44] = _textiobase_readline_doc;
    HEAP[_textiobase_methods + 48] = __str3377;
    HEAP[_textiobase_methods + 52] = FUNCTION_TABLE_OFFSET + 312;
    HEAP[_textiobase_methods + 60] = _textiobase_write_doc;
    HEAP[_textiobase_getset] = __str4378;
    HEAP[_textiobase_getset + 4] = FUNCTION_TABLE_OFFSET + 314;
    HEAP[_textiobase_getset + 12] = _textiobase_encoding_doc;
    HEAP[_textiobase_getset + 20] = __str5379;
    HEAP[_textiobase_getset + 24] = FUNCTION_TABLE_OFFSET + 316;
    HEAP[_textiobase_getset + 32] = _textiobase_newlines_doc;
    HEAP[_textiobase_getset + 40] = __str6380;
    HEAP[_textiobase_getset + 44] = FUNCTION_TABLE_OFFSET + 318;
    HEAP[_textiobase_getset + 52] = _textiobase_errors_doc;
    HEAP[_PyTextIOBase_Type + 12] = __str7381;
    HEAP[_PyTextIOBase_Type + 88] = _textiobase_doc;
    HEAP[_PyTextIOBase_Type + 116] = _textiobase_methods;
    HEAP[_PyTextIOBase_Type + 124] = _textiobase_getset;
    HEAP[_PyTextIOBase_Type + 128] = _PyIOBase_Type;
    HEAP[_C_1_8453] = __str8383;
    HEAP[_C_1_8453 + 4] = __str9384;
    HEAP[_C_1_8453 + 8] = __str6380;
    HEAP[_C_56_8766] = __str16391;
    HEAP[_C_56_8766 + 4] = __str17392;
    HEAP[_incrementalnewlinedecoder_methods] = __str29404;
    HEAP[_incrementalnewlinedecoder_methods + 4] = FUNCTION_TABLE_OFFSET + 320;
    HEAP[_incrementalnewlinedecoder_methods + 16] = __str30405;
    HEAP[_incrementalnewlinedecoder_methods + 20] = FUNCTION_TABLE_OFFSET + 322;
    HEAP[_incrementalnewlinedecoder_methods + 32] = __str22397;
    HEAP[_incrementalnewlinedecoder_methods + 36] = FUNCTION_TABLE_OFFSET + 324;
    HEAP[_incrementalnewlinedecoder_methods + 48] = __str31406;
    HEAP[_incrementalnewlinedecoder_methods + 52] = FUNCTION_TABLE_OFFSET + 326;
    HEAP[_incrementalnewlinedecoder_getset] = __str5379;
    HEAP[_incrementalnewlinedecoder_getset + 4] = FUNCTION_TABLE_OFFSET + 328;
    HEAP[_PyIncrementalNewlineDecoder_Type + 12] = __str32407;
    HEAP[_PyIncrementalNewlineDecoder_Type + 24] = FUNCTION_TABLE_OFFSET + 330;
    HEAP[_PyIncrementalNewlineDecoder_Type + 88] = _incrementalnewlinedecoder_doc;
    HEAP[_PyIncrementalNewlineDecoder_Type + 116] = _incrementalnewlinedecoder_methods;
    HEAP[_PyIncrementalNewlineDecoder_Type + 124] = _incrementalnewlinedecoder_getset;
    HEAP[_PyIncrementalNewlineDecoder_Type + 148] = FUNCTION_TABLE_OFFSET + 332;
    HEAP[_PyIncrementalNewlineDecoder_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    HEAP[_encodefuncs] = __str33409;
    HEAP[_encodefuncs + 4] = FUNCTION_TABLE_OFFSET + 334;
    HEAP[_encodefuncs + 8] = __str34410;
    HEAP[_encodefuncs + 12] = FUNCTION_TABLE_OFFSET + 336;
    HEAP[_encodefuncs + 16] = __str35411;
    HEAP[_encodefuncs + 20] = FUNCTION_TABLE_OFFSET + 338;
    HEAP[_encodefuncs + 24] = __str36412;
    HEAP[_encodefuncs + 28] = FUNCTION_TABLE_OFFSET + 340;
    HEAP[_encodefuncs + 32] = __str37413;
    HEAP[_encodefuncs + 36] = FUNCTION_TABLE_OFFSET + 342;
    HEAP[_encodefuncs + 40] = __str38414;
    HEAP[_encodefuncs + 44] = FUNCTION_TABLE_OFFSET + 344;
    HEAP[_encodefuncs + 48] = __str39415;
    HEAP[_encodefuncs + 52] = FUNCTION_TABLE_OFFSET + 346;
    HEAP[_encodefuncs + 56] = __str40416;
    HEAP[_encodefuncs + 60] = FUNCTION_TABLE_OFFSET + 348;
    HEAP[_encodefuncs + 64] = __str41417;
    HEAP[_encodefuncs + 68] = FUNCTION_TABLE_OFFSET + 350;
    HEAP[_C_89_9102] = __str42418;
    HEAP[_C_89_9102 + 4] = __str4378;
    HEAP[_C_89_9102 + 8] = __str6380;
    HEAP[_C_89_9102 + 12] = __str43419;
    HEAP[_C_89_9102 + 16] = __str44420;
    HEAP[_textiowrapper_methods] = __str374;
    HEAP[_textiowrapper_methods + 4] = FUNCTION_TABLE_OFFSET + 352;
    HEAP[_textiowrapper_methods + 16] = __str3377;
    HEAP[_textiowrapper_methods + 20] = FUNCTION_TABLE_OFFSET + 354;
    HEAP[_textiowrapper_methods + 32] = __str1375;
    HEAP[_textiowrapper_methods + 36] = FUNCTION_TABLE_OFFSET + 356;
    HEAP[_textiowrapper_methods + 48] = __str2376;
    HEAP[_textiowrapper_methods + 52] = FUNCTION_TABLE_OFFSET + 358;
    HEAP[_textiowrapper_methods + 64] = __str79;
    HEAP[_textiowrapper_methods + 68] = FUNCTION_TABLE_OFFSET + 360;
    HEAP[_textiowrapper_methods + 80] = __str102;
    HEAP[_textiowrapper_methods + 84] = FUNCTION_TABLE_OFFSET + 362;
    HEAP[_textiowrapper_methods + 96] = __str100;
    HEAP[_textiowrapper_methods + 100] = FUNCTION_TABLE_OFFSET + 364;
    HEAP[_textiowrapper_methods + 112] = __str55431;
    HEAP[_textiowrapper_methods + 116] = FUNCTION_TABLE_OFFSET + 366;
    HEAP[_textiowrapper_methods + 128] = __str50426;
    HEAP[_textiowrapper_methods + 132] = FUNCTION_TABLE_OFFSET + 368;
    HEAP[_textiowrapper_methods + 144] = __str52428;
    HEAP[_textiowrapper_methods + 148] = FUNCTION_TABLE_OFFSET + 370;
    HEAP[_textiowrapper_methods + 160] = __str101;
    HEAP[_textiowrapper_methods + 164] = FUNCTION_TABLE_OFFSET + 372;
    HEAP[_textiowrapper_methods + 176] = __str80;
    HEAP[_textiowrapper_methods + 180] = FUNCTION_TABLE_OFFSET + 374;
    HEAP[_textiowrapper_methods + 192] = __str77;
    HEAP[_textiowrapper_methods + 196] = FUNCTION_TABLE_OFFSET + 376;
    HEAP[_textiowrapper_methods + 208] = __str105;
    HEAP[_textiowrapper_methods + 212] = FUNCTION_TABLE_OFFSET + 378;
    HEAP[_textiowrapper_members] = __str4378;
    HEAP[_textiowrapper_members + 20] = __str42418;
    HEAP[_textiowrapper_members + 40] = __str44420;
    HEAP[_textiowrapper_getset] = __str53429;
    HEAP[_textiowrapper_getset + 4] = FUNCTION_TABLE_OFFSET + 380;
    HEAP[_textiowrapper_getset + 20] = __str106;
    HEAP[_textiowrapper_getset + 24] = FUNCTION_TABLE_OFFSET + 382;
    HEAP[_textiowrapper_getset + 40] = __str5379;
    HEAP[_textiowrapper_getset + 44] = FUNCTION_TABLE_OFFSET + 384;
    HEAP[_textiowrapper_getset + 60] = __str6380;
    HEAP[_textiowrapper_getset + 64] = FUNCTION_TABLE_OFFSET + 386;
    HEAP[_textiowrapper_getset + 80] = __str107;
    HEAP[_textiowrapper_getset + 84] = FUNCTION_TABLE_OFFSET + 388;
    HEAP[_textiowrapper_getset + 88] = FUNCTION_TABLE_OFFSET + 390;
    HEAP[_PyTextIOWrapper_Type + 12] = __str108;
    HEAP[_PyTextIOWrapper_Type + 24] = FUNCTION_TABLE_OFFSET + 392;
    HEAP[_PyTextIOWrapper_Type + 44] = FUNCTION_TABLE_OFFSET + 394;
    HEAP[_PyTextIOWrapper_Type + 88] = _textiowrapper_doc;
    HEAP[_PyTextIOWrapper_Type + 92] = FUNCTION_TABLE_OFFSET + 396;
    HEAP[_PyTextIOWrapper_Type + 96] = FUNCTION_TABLE_OFFSET + 398;
    HEAP[_PyTextIOWrapper_Type + 112] = FUNCTION_TABLE_OFFSET + 400;
    HEAP[_PyTextIOWrapper_Type + 116] = _textiowrapper_methods;
    HEAP[_PyTextIOWrapper_Type + 120] = _textiowrapper_members;
    HEAP[_PyTextIOWrapper_Type + 124] = _textiowrapper_getset;
    HEAP[_PyTextIOWrapper_Type + 148] = FUNCTION_TABLE_OFFSET + 402;
    HEAP[_PyTextIOWrapper_Type + 156] = FUNCTION_TABLE_OFFSET + 62;
    __globalConstructor__();
  }
  Module["run"] = run;
  run();
  return Module;
});
