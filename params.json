{"name":"Empydom","body":"# Empydom\r\n---\r\nThanks to https://github.com/replit/empythoned for making Empythoned and https://github.com/max99x for\r\nhelping me out when I had some questions.\r\n\r\nThanks to Evan Shapiro for helping on some of the core parts in the bridge\r\n\r\nThanks to Professor David Kosbie for providing the idea for and giving me the opportunity to work on this project\r\n\r\n## About\r\nEmpydom is a Python-DOM bridge built on top of replit's empythoned\r\nEmpydom lets you use Python in `<script>` tags within an HTML document to manipulate the DOM\r\n\r\n\r\n## How to use\r\nInstall the `empydom.user.js` for Chrome or `empydom.xpi` for Firefox by dragging and dropping the file into your chosen browser.\r\n\r\nYou can now visit pages that use Empydom.\r\n\r\n* See http://www.bridgejs.com/test-bridge.html for an example with a console for input and ouput\r\n* See http://www.bridgejs.com/script-tag-example.html for a large script-tag example with canvas\r\n* See http://www.bridgejs.com/fast-clock.html for a faster version of the same demo with most logic in JavaScript\r\n\r\n### Programming with Empydom\r\nInclude \r\n```html\r\n<div id='give_me_empydom_please'></div> \r\n```\r\n\r\nsomewhere in the body of your HTML page.\r\nThis ensures that the extension knows about Empydom.\r\n\r\n---\r\n\r\nAbove your Python code, include any JavaScript libraries that you want to use within your Python code\r\n\r\n---\r\n\r\nBelow your Python code, include this: \r\n```html\r\n<script> window.onEmpydomReady = function() { window.empydom.executePythonScripts(); }; </script>`\r\n```\r\n\r\nThe extension calls `window.onEmpydomReady()` when it finishes being loaded.\r\n`window.empydom.executePythonScripts()` executes Python within all `<script text=\"text/python\">`\r\n\r\nIf you pass a function to `executePythonScripts()` that function will be called with the character code to output as a buffer.\r\nThe default function which outputs each line to the console is:\r\n```javascript\r\nfunction(chr) {\r\n   if (chr !== null) {\r\n     realChar = String.fromCharCode(chr);\r\n     charBuffer += realChar;\r\n     if (realChar == '\\n') {\r\n       console.log(charBuffer);\r\n       charBuffer = \"\";\r\n     }\r\n   }\r\n};\r\n```\r\nNote: `charBuffer` is a variable declared as the empty string outside of the function body.\r\n\r\n---\r\n\r\nAll of your Python code goes in `<script type=\"text/python\">` tags.\r\nMost Python modules are supported, a few are included within the extesion, but many more must be downloaded from whichever server is hosting the page from an `extern` folder\r\n\r\n---\r\n\r\nIn Python, you have access to the JavaScript object `window` as a Python object.\r\n* You add properties to `window`, you can read values from properties within `window`, and you can call functions from properties within `window`.\r\n* You can pass Python strings, numbers, lists, dictionaries, and functions as parameters to any function in `window` and they will be interpreted\r\nas JavaScript strings, numbers, arrays, objects, and functions respectively.\r\n* JavaScript errors are percolated up to the Python stack trace and the output function is called for each character of\r\nthe JavaScript state\r\n\r\n## Quirks\r\n\r\nIn Firefox, the page doesn't render until Empydom loads completely, while in Chrome it renders immediately then loads Empydom.\r\n\r\nFirefox sometimes thinks the script is unresponsive. This is partly related to the overhead of initializing Empythoned and \r\npartly related to initializing the DOM bridge. Hopefully, with optimizations, this will stop soon.\r\n\r\nThese problems could be partially alleviated if Empydom worked in a web-worker since it would be running in the background in a dedicated thread.\r\nSee issue #7, most of the infrastructure of porting Empydom is there, the only problem is the lack of a blocking recieve or\r\na force check for messages for the web-worker.\r\n\r\nDo not make calls passing functions as parameters in tight-loops. Function memory management is non-existant. The problem is that\r\nJavaScript can call a passed function at anytime so we can't free it from Python.\r\nAdditionally, blobs are never freed from JavaScript -- but the overhead from this is much less than the function issue. Fixing\r\nthe blob memory issue will probably require including a reference to the parent blob object for each blob.","tagline":"Python-Javascript DOM bridge","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}